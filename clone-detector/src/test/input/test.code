u'1,from .client import Client\n'
u'2,import redis\nimport uuid\nimport json\nimport textwrap\nimport shlex\nimport base64\nimport signal\nimport socket\nimport logging\nimport time\nimport sys\nfrom . import typchk\n\n\nDefaultTimeout = 10  # seconds\n\nlogger = logging.getLogger(\'g8core\')\n\n\nclass Timeout(Exception):\n    pass\n\n\nclass JobNotFound(Exception):\n    pass\n\n\nclass Return:\n\n    def __init__(self, payload):\n        self._payload = payload\n\n    @property\n    def payload(self):\n        """\n        Raw return object data\n        :return: dict\n        """\n        return self._payload\n\n    @property\n    def id(self):\n        """\n        Job ID\n        :return: string\n        """\n        return self._payload[\'id\']\n\n    @property\n    def data(self):\n        """\n        Data returned by the process. Only available if process\n        output data with the correct core level\n\n        For example, if a job returns a json object the self.level will be 20 and the data will contain the serialized\n        json object, other levels exists for yaml, toml, etc... it really depends on the running job\n        return: python primitive (str, number, dict or array)\n        """\n        return self._payload[\'data\']\n\n    @property\n    def level(self):\n        """\n        Data message level (if any)\n        """\n        return self._payload[\'level\']\n\n    @property\n    def starttime(self):\n        """\n        Starttime as a timestamp\n        """\n        return self._payload[\'starttime\'] / 1000\n\n    @property\n    def time(self):\n        """\n        Execution time in millisecond\n        """\n        return self._payload[\'time\']\n\n    @property\n    def state(self):\n        """\n        Exit state\n        :return: str one of [SUCCESS, ERROR, KILLED, TIMEOUT, UNKNOWN_CMD, DUPLICATE_ID]\n        """\n        return self._payload[\'state\']\n\n    @property\n    def stdout(self):\n        """\n        The job stdout\n        :return: string or None\n        """\n        streams = self._payload.get(\'streams\', None)\n        return streams[0] if streams is not None and len(streams) >= 1 else \'\'\n\n    @property\n    def stderr(self):\n        """\n        The job stderr\n        :return: string or None\n        """\n        streams = self._payload.get(\'streams\', None)\n        return streams[1] if streams is not None and len(streams) >= 2 else \'\'\n\n    def __repr__(self):\n        return str(self)\n\n    def __str__(self):\n        tmpl = """\\\n        STATE: {state}\n        STDOUT:\n        {stdout}\n        STDERR:\n        {stderr}\n        DATA:\n        {data}\n        """\n\n        return textwrap.dedent(tmpl).format(state=self.state, stdout=self.stdout, stderr=self.stderr, data=self.data)\n\n\nclass Response:\n\n    def __init__(self, client, id):\n        self._client = client\n        self._id = id\n        self._queue = \'result:{}\'.format(id)\n\n    @property\n    def id(self):\n        """\n        Job ID\n        :return: string\n        """\n        return self._id\n\n    @property\n    def exists(self):\n        """\n        Returns true if the job is still running or zero-os still knows about this job ID\n\n        After a job is finished, a job remains on zero-os for max of 5min where you still can read the job result\n        after the 5 min is gone, the job result is no more fetchable\n        :return: bool\n        """\n        r = self._client._redis\n        flag = \'{}:flag\'.format(self._queue)\n        return bool(r.execute_command(\'LKEYEXISTS\', flag))\n\n    @property\n    def running(self):\n        """\n        Returns true if job still in running state\n        :return:\n        """\n        r = self._client._redis\n        flag = \'{}:flag\'.format(self._queue)\n        if bool(r.execute_command(\'LKEYEXISTS\', flag)):\n            return r.execute_command(\'LTTL\', flag) == -1\n\n        return False\n\n    def stream(self, out=sys.stdout, err=sys.stderr):\n        """\n        Runtime copy of job stdout and stderr. This required the \'stream` flag to be set to True otherwise it will\n        not be able to copy any output, while it will block until the process exits.\n\n        :note: This function will block until it reaches end of stream or the process is no longer running.\n\n        :param out: Output stream\n        :param err: Error stream\n\n        :return: None\n        """\n        queue = \'stream:%s\' % self.id\n        r = self._client._redis\n\n        # we can terminate quickly by checking if the process is not running and it has no queued output.\n        if not self.running and r.llen(queue) == 0:\n            return\n\n        while True:\n            data = r.blpop(queue, 10)\n            if data is None:\n                if not self.running:\n                    break\n                continue\n            _, body = data\n            payload = json.loads(body.decode())\n            message = payload[\'message\']\n            line = message[\'message\']\n            meta = message[\'meta\']\n            if meta & 0x0006 != 0:\n                #eof flags are 0x2 (success) or 0x4 error\n                break\n            level = meta >> 16\n            w = out if level == 1 else err\n\n            if w is not None:\n                w.write(line)\n                w.write(\'\\n\')\n\n    def get(self, timeout=None):\n        """\n        Waits for a job to finish (max of given timeout seconds) and return job results. When a job exits get() will\n        keep returning the same result until zero-os doesn\'t remember the job anymore (self.exists == False)\n\n        :notes: the timeout here is a client side timeout, it\'s different than the timeout given to the job on start\n        (like in system method) witch will cause the job to be killed if it exceeded this timeout.\n\n        :param timeout: max time to wait for the job to finish in seconds\n        :return: Return object\n        """\n        if timeout is None:\n            timeout = self._client.timeout\n        r = self._client._redis\n        start = time.time()\n        maxwait = timeout\n        while maxwait > 0:\n            if not self.exists:\n                raise JobNotFound(self.id)\n            v = r.brpoplpush(self._queue, self._queue, 10)\n            if v is not None:\n                payload = json.loads(v.decode())\n                r = Return(payload)\n                logger.debug(\'%s << %s, stdout="%s", stderr="%s", data="%s"\',\n                             self._id, r.state, r.stdout, r.stderr, r.data[:1000])\n                return r\n            logger.debug(\'%s still waiting (%ss)\', self._id, int(time.time() - start))\n            maxwait -= 10\n        raise Timeout()\n\n\nclass InfoManager:\n\n    def __init__(self, client):\n        self._client = client\n\n    def cpu(self):\n        """\n        CPU information\n        :return:\n        """\n        return self._client.json(\'info.cpu\', {})\n\n    def nic(self):\n        """\n        Return (physical) network devices information including IPs\n        :return:\n        """\n        return self._client.json(\'info.nic\', {})\n\n    def mem(self):\n        """\n        Memory information\n        :return:\n        """\n        return self._client.json(\'info.mem\', {})\n\n    def disk(self):\n        """\n        Disk information\n        :return:\n        """\n        return self._client.json(\'info.disk\', {})\n\n    def os(self):\n        """\n        Operating system info\n        :return:\n        """\n        return self._client.json(\'info.os\', {})\n\n    def port(self):\n        """\n        Return information about open ports on the system (similar to netstat)\n        :return:\n        """\n        return self._client.json(\'info.port\', {})\n\n    def version(self):\n        """\n        Return OS version\n        :return:\n        """\n        return self._client.json(\'info.version\', {})\n\n\nclass JobManager:\n    _job_chk = typchk.Checker({\n        \'id\': typchk.Or(str, typchk.IsNone()),\n    })\n\n    _kill_chk = typchk.Checker({\n        \'id\': str,\n        \'signal\': int,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def list(self, id=None):\n        """\n        List all running jobs\n\n        :param id: optional ID for the job to list\n        """\n        args = {\'id\': id}\n        self._job_chk.check(args)\n        return self._client.json(\'job.list\', args)\n\n    def kill(self, id, signal=signal.SIGTERM):\n        """\n        Kill a job with given id\n\n        :WARNING: beware of what u kill, if u killed redis for example core0 or coreX won\'t be reachable\n\n        :param id: job id to kill\n        """\n        args = {\n            \'id\': id,\n            \'signal\': int(signal),\n        }\n        self._kill_chk.check(args)\n        return self._client.json(\'job.kill\', args)\n\n\nclass ProcessManager:\n    _process_chk = typchk.Checker({\n        \'pid\': typchk.Or(int, typchk.IsNone()),\n    })\n\n    _kill_chk = typchk.Checker({\n        \'pid\': int,\n        \'signal\': int,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def list(self, id=None):\n        """\n        List all running processes\n\n        :param id: optional PID for the process to list\n        """\n        args = {\'pid\': id}\n        self._process_chk.check(args)\n        return self._client.json(\'process.list\', args)\n\n    def kill(self, pid, signal=signal.SIGTERM):\n        """\n        Kill a process with given pid\n\n        :WARNING: beware of what u kill, if u killed redis for example core0 or coreX won\'t be reachable\n\n        :param pid: PID to kill\n        """\n        args = {\n            \'pid\': pid,\n            \'signal\': int(signal),\n        }\n        self._kill_chk.check(args)\n        return self._client.json(\'process.kill\', args)\n\n\nclass FilesystemManager:\n\n    def __init__(self, client):\n        self._client = client\n\n    def open(self, file, mode=\'r\', perm=0o0644):\n        """\n        Opens a file on the node\n\n        :param file: file path to open\n        :param mode: open mode\n        :param perm: file permission in octet form\n\n        mode:\n          \'r\' read only\n          \'w\' write only (truncate)\n          \'+\' read/write\n          \'x\' create if not exist\n          \'a\' append\n        :return: a file descriptor\n        """\n        args = {\n            \'file\': file,\n            \'mode\': mode,\n            \'perm\': perm,\n        }\n\n        return self._client.json(\'filesystem.open\', args)\n\n    def exists(self, path):\n        """\n        Check if path exists\n\n        :param path: path to file/dir\n        :return: boolean\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.exists\', args)\n\n    def list(self, path):\n        """\n        List all entries in directory\n        :param path: path to dir\n        :return: list of director entries\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.list\', args)\n\n    def mkdir(self, path):\n        """\n        Make a new directory == mkdir -p path\n        :param path: path to directory to create\n        :return:\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.mkdir\', args)\n\n    def remove(self, path):\n        """\n        Removes a path (recursively)\n\n        :param path: path to remove\n        :return:\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.remove\', args)\n\n    def move(self, path, destination):\n        """\n        Move a path to destination\n\n        :param path: source\n        :param destination: destination\n        :return:\n        """\n        args = {\n            \'path\': path,\n            \'destination\': destination,\n        }\n\n        return self._client.json(\'filesystem.move\', args)\n\n    def chmod(self, path, mode, recursive=False):\n        """\n        Change file/dir permission\n\n        :param path: path of file/dir to change\n        :param mode: octet mode\n        :param recursive: apply chmod recursively\n        :return:\n        """\n        args = {\n            \'path\': path,\n            \'mode\': mode,\n            \'recursive\': recursive,\n        }\n\n        return self._client.json(\'filesystem.chmod\', args)\n\n    def chown(self, path, user, group, recursive=False):\n        """\n        Change file/dir owner\n\n        :param path: path of file/dir\n        :param user: user name\n        :param group: group name\n        :param recursive: apply chown recursively\n        :return:\n        """\n        args = {\n            \'path\': path,\n            \'user\': user,\n            \'group\': group,\n            \'recursive\': recursive,\n        }\n\n        return self._client.json(\'filesystem.chown\', args)\n\n    def read(self, fd):\n        """\n        Read a block from the given file descriptor\n\n        :param fd: file descriptor\n        :return: bytes\n        """\n        args = {\n            \'fd\': fd,\n        }\n\n        data = self._client.json(\'filesystem.read\', args)\n        return base64.decodebytes(data.encode())\n\n    def write(self, fd, bytes):\n        """\n        Write a block of bytes to an open file descriptor (that is open with one of the writing modes\n\n        :param fd: file descriptor\n        :param bytes: bytes block to write\n        :return:\n\n        :note: don\'t overkill the node with large byte chunks, also for large file upload check the upload method.\n        """\n        args = {\n            \'fd\': fd,\n            \'block\': base64.encodebytes(bytes).decode(),\n        }\n\n        return self._client.json(\'filesystem.write\', args)\n\n    def close(self, fd):\n        """\n        Close file\n        :param fd: file descriptor\n        :return:\n        """\n        args = {\n            \'fd\': fd,\n        }\n\n        return self._client.json(\'filesystem.close\', args)\n\n    def upload(self, remote, reader):\n        """\n        Uploads a file\n        :param remote: remote file name\n        :param reader: an object that implements the read(size) method (typically a file descriptor)\n        :return:\n        """\n\n        fd = self.open(remote, \'w\')\n        while True:\n            chunk = reader.read(512 * 1024)\n            if chunk == b\'\':\n                break\n            self.write(fd, chunk)\n        self.close(fd)\n\n    def download(self, remote, writer):\n        """\n        Downloads a file\n        :param remote: remote file name\n        :param writer: an object the implements the write(bytes) interface (typical a file descriptor)\n        :return:\n        """\n\n        fd = self.open(remote)\n        while True:\n            chunk = self.read(fd)\n            if chunk == b\'\':\n                break\n            writer.write(chunk)\n        self.close(fd)\n\n    def upload_file(self, remote, local):\n        """\n        Uploads a file\n        :param remote: remote file name\n        :param local: local file name\n        :return:\n        """\n        file = open(local, \'rb\')\n        self.upload(remote, file)\n\n    def download_file(self, remote, local):\n        """\n        Downloads a file\n        :param remote: remote file name\n        :param local: local file name\n        :return:\n        """\n        file = open(local, \'wb\')\n        self.download(remote, file)\n\n\nclass BaseClient:\n    _system_chk = typchk.Checker({\n        \'name\': str,\n        \'args\': [str],\n        \'dir\': str,\n        \'stdin\': str,\n        \'env\': typchk.Or(typchk.Map(str, str), typchk.IsNone()),\n    })\n\n    _bash_chk = typchk.Checker({\n        \'stdin\': str,\n        \'script\': str,\n    })\n\n    def __init__(self, timeout=None):\n        if timeout is None:\n            self.timeout = DefaultTimeout\n        else:\n            self.timeout = timeout\n        self._info = InfoManager(self)\n        self._job = JobManager(self)\n        self._process = ProcessManager(self)\n        self._filesystem = FilesystemManager(self)\n        self._ip = IPManager(self)\n\n    @property\n    def info(self):\n        """\n        info manager\n        :return:\n        """\n        return self._info\n\n    @property\n    def job(self):\n        """\n        job manager\n        :return:\n        """\n        return self._job\n\n    @property\n    def process(self):\n        """\n        process manager\n        :return:\n        """\n        return self._process\n\n    @property\n    def filesystem(self):\n        """\n        filesystem manager\n        :return:\n        """\n        return self._filesystem\n\n    @property\n    def ip(self):\n        """\n        ip manager\n        :return:\n        """\n        return self._ip\n\n    def raw(self, command, arguments, queue=None, max_time=None, stream=False):\n        """\n        Implements the low level command call, this needs to build the command structure\n        and push it on the correct queue.\n\n        :param command: Command name to execute supported by the node (ex: core.system, info.cpu, etc...)\n                        check documentation for list of built in commands\n        :param arguments: A dict of required command arguments depends on the command name.\n        :param queue: command queue (commands on the same queue are executed sequentially)\n        :param max_time: kill job server side if it exceeded this amount of seconds\n        :param stream: If True, process stdout and stderr are pushed to a special queue (stream:<id>) so\n            client can stream output\n        :return: Response object\n        """\n        raise NotImplemented()\n\n    def sync(self, command, arguments):\n        """\n        Same as self.raw except it do a response.get() waiting for the command execution to finish and reads the result\n\n        :return: Result object\n        """\n        response = self.raw(command, arguments)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'invalid response: %s\' % result.state, result)\n\n        return result\n\n    def json(self, command, arguments):\n        """\n        Same as self.sync except it assumes the returned result is json, and loads the payload of the return object\n        if the returned (data) is not of level (20) an error is raised.\n        :Return: Data\n        """\n        result = self.sync(command, arguments)\n        if result.level != 20:\n            raise RuntimeError(\'invalid result level, expecting json(20) got (%d)\' % result.level)\n\n        return json.loads(result.data)\n\n    def ping(self):\n        """\n        Ping a node, checking for it\'s availability. a Ping should never fail unless the node is not reachable\n        or not responsive.\n        :return:\n        """\n        response = self.raw(\'core.ping\', {})\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'invalid response: %s\' % result.state)\n\n        return json.loads(result.data)\n\n    def system(self, command, dir=\'\', stdin=\'\', env=None, queue=None, max_time=None, stream=False):\n        """\n        Execute a command\n\n        :param command:  command to execute (with its arguments) ex: `ls -l /root`\n        :param dir: CWD of command\n        :param stdin: Stdin data to feed to the command stdin\n        :param env: dict with ENV variables that will be exported to the command\n        :return:\n        """\n        parts = shlex.split(command)\n        if len(parts) == 0:\n            raise ValueError(\'invalid command\')\n\n        args = {\n            \'name\': parts[0],\n            \'args\': parts[1:],\n            \'dir\': dir,\n            \'stdin\': stdin,\n            \'env\': env,\n        }\n\n        self._system_chk.check(args)\n        response = self.raw(command=\'core.system\', arguments=args,\n                            queue=queue, max_time=max_time, stream=stream)\n\n        return response\n\n    def bash(self, script, stdin=\'\', queue=None, max_time=None, stream=False):\n        """\n        Execute a bash script, or run a process inside a bash shell.\n\n        :param script: Script to execute (can be multiline script)\n        :param stdin: Stdin data to feed to the script\n        :return:\n        """\n        args = {\n            \'script\': script,\n            \'stdin\': stdin,\n        }\n        self._bash_chk.check(args)\n        response = self.raw(command=\'bash\', arguments=args,\n                            queue=queue, max_time=max_time, stream=stream)\n\n        return response\n\n\nclass ContainerClient(BaseClient):\n    class ContainerZerotierManager:\n        def __init__(self, client, container):\n            self._container = container\n            self._client = client\n\n        def info(self):\n            return self._client.json(\'corex.zerotier.info\', {\'container\': self._container})\n\n        def list(self):\n            return self._client.json(\'corex.zerotier.list\', {\'container\': self._container})\n\n    _raw_chk = typchk.Checker({\n        \'container\': int,\n        \'command\': {\n            \'command\': str,\n            \'arguments\': typchk.Any(),\n            \'queue\': typchk.Or(str, typchk.IsNone()),\n            \'max_time\': typchk.Or(int, typchk.IsNone()),\n            \'stream\': bool\n        }\n    })\n\n    def __init__(self, client, container):\n        super().__init__(client.timeout)\n\n        self._client = client\n        self._container = container\n        self._zerotier = ContainerClient.ContainerZerotierManager(client, container)  # not (self) we use core0 client\n\n    @property\n    def container(self):\n        """\n        :return: container id\n        """\n        return self._container\n\n    @property\n    def zerotier(self):\n        """\n        information about zerotier id\n        :return:\n        """\n        return self._zerotier\n\n    def raw(self, command, arguments, queue=None, max_time=None, stream=False):\n        """\n        Implements the low level command call, this needs to build the command structure\n        and push it on the correct queue.\n\n        :param command: Command name to execute supported by the node (ex: core.system, info.cpu, etc...)\n                        check documentation for list of built in commands\n        :param arguments: A dict of required command arguments depends on the command name.\n        :param queue: command queue (commands on the same queue are executed sequentially)\n        :param max_time: kill job server side if it exceeded this amount of seconds\n        :param stream: If True, process stdout and stderr are pushed to a special queue (stream:<id>) so\n            client can stream output\n        :return: Response object\n        """\n        args = {\n            \'container\': self._container,\n            \'command\': {\n                \'command\': command,\n                \'arguments\': arguments,\n                \'queue\': queue,\n                \'max_time\': max_time,\n                \'stream\': stream,\n            },\n        }\n\n        # check input\n        self._raw_chk.check(args)\n\n        response = self._client.raw(\'corex.dispatch\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to dispatch command to container: %s\' % result.data)\n\n        cmd_id = json.loads(result.data)\n        return self._client.response_for(cmd_id)\n\n\nclass ContainerManager:\n    _create_chk = typchk.Checker({\n        \'root\': str,\n        \'mount\': typchk.Or(\n            typchk.Map(str, str),\n            typchk.IsNone()\n        ),\n        \'host_network\': bool,\n        \'nics\': [{\n            \'type\': typchk.Enum(\'default\', \'bridge\', \'zerotier\', \'vlan\', \'vxlan\'),\n            \'id\': typchk.Or(str, typchk.Missing()),\n            \'name\': typchk.Or(str, typchk.Missing()),\n            \'hwaddr\': typchk.Or(str, typchk.Missing()),\n            \'config\': typchk.Or(\n                typchk.Missing(),\n                {\n                    \'dhcp\': typchk.Or(bool, typchk.Missing()),\n                    \'cidr\': typchk.Or(str, typchk.Missing()),\n                    \'gateway\': typchk.Or(str, typchk.Missing()),\n                    \'dns\': typchk.Or([str], typchk.Missing()),\n                }\n            )\n        }],\n        \'port\': typchk.Or(\n            typchk.Map(int, int),\n            typchk.IsNone()\n        ),\n        \'privileged\': bool,\n        \'hostname\': typchk.Or(\n            str,\n            typchk.IsNone()\n        ),\n        \'storage\': typchk.Or(str, typchk.IsNone()),\n        \'tags\': typchk.Or([str], typchk.IsNone())\n    })\n\n    _client_chk = typchk.Checker(\n        typchk.Or(int, str)\n    )\n\n    DefaultNetworking = object()\n\n    class ContainerResponse(Response):\n        def get(self, timeout=None):\n            """\n            Get container ID\n            :param timeout: client side timeout in seconds (for the container ID to return)\n            :return: int\n            """\n            result = super().get(timeout)\n            if result.state != \'SUCCESS\':\n                raise Exception(\'failed to create container: %s\' % result.data)\n\n            return json.loads(result.data)\n\n    def __init__(self, client):\n        self._client = client\n\n    def create(self, root_url, mount=None, host_network=False, nics=DefaultNetworking, port=None, hostname=None, privileged=False, storage=None, tags=None):\n        """\n        Creater a new container with the given root flist, mount points and\n        zerotier id, and connected to the given bridges\n        :param root_url: The root filesystem flist\n        :param mount: a dict with {host_source: container_target} mount points.\n                      where host_source directory must exists.\n                      host_source can be a url to a flist to mount.\n        :param host_network: Specify if the container should share the same network stack as the host.\n                             if True, container creation ignores both zerotier, bridge and ports arguments below. Not\n                             giving errors if provided.\n        :param nics: Configure the attached nics to the container\n                     each nic object is a dict of the format\n                     {\n                        \'type\': nic_type # default, bridge, zerotier, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n                        \'id\': id # depends on the type, bridge name, zerotier network id, the vlan tag or the vxlan id\n                        \'name\': name of the nic inside the container (ignored in zerotier type)\n                        \'hwaddr\': Mac address of nic.\n                        \'config\': { # config is only honored for bridge, vlan, and vxlan types\n                            \'dhcp\': bool,\n                            \'cidr\': static_ip # ip/mask\n                            \'gateway\': gateway\n                            \'dns\': [dns]\n                        }\n                     }\n        :param port: A dict of host_port: container_port pairs (only if default networking is enabled)\n                       Example:\n                        `port={8080: 80, 7000:7000}`\n        :param hostname: Specific hostname you want to give to the container.\n                         if None it will automatically be set to core-x,\n                         x beeing the ID of the container\n        :param privileged: If true, container runs in privileged mode.\n        :param storage: A Url to the ardb storage to use to mount the root flist (or any other mount that requires g8fs)\n                        if not provided, the default one from core0 configuration will be used.\n        """\n\n        if nics == self.DefaultNetworking:\n            nics = [{\'type\': \'default\'}]\n        elif nics is None:\n            nics = []\n\n        args = {\n            \'root\': root_url,\n            \'mount\': mount,\n            \'host_network\': host_network,\n            \'nics\': nics,\n            \'port\': port,\n            \'hostname\': hostname,\n            \'privileged\': privileged,\n            \'storage\': storage,\n            \'tags\': tags,\n        }\n\n        # validate input\n        self._create_chk.check(args)\n\n        response = self._client.raw(\'corex.create\', args)\n\n        return self.ContainerResponse(self._client, response.id)\n\n    def list(self):\n        """\n        List running containers\n        :return: a dict with {container_id: <container info object>}\n        """\n        return self._client.json(\'corex.list\', {})\n\n    def find(self, *tags):\n        """\n        Find containers that matches set of tags\n        :param tags:\n        :return:\n        """\n        tags = list(map(str, tags))\n        return self._client.json(\'corex.find\', {\'tags\': tags})\n\n    def terminate(self, container):\n        """\n        Terminate a container given it\'s id\n\n        :param container: container id\n        :return:\n        """\n        self._client_chk.check(container)\n        args = {\n            \'container\': int(container),\n        }\n        response = self._client.raw(\'corex.terminate\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to terminate container: %s\' % result.data)\n\n    def client(self, container):\n        """\n        Return a client instance that is bound to that container.\n\n        :param container: container id\n        :return: Client object bound to the specified container id\n        Return a ContainerResponse from container.create\n        """\n\n        self._client_chk.check(container)\n        return ContainerClient(self._client, int(container))\n\n\nclass IPManager:\n    class IPBridgeManager:\n        def __init__(self, client):\n            self._client = client\n\n        def add(self, name, hwaddr=None):\n            """\n            Add bridge with given name and optional hardware address\n\n            For more advanced bridge options please check the `bridge` manager.\n            :param name: bridge name\n            :param hwaddr: mac address (str)\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'hwaddr\': hwaddr,\n            }\n\n            return self._client.json("ip.bridge.add", args)\n\n        def delete(self, name):\n            """\n            Delete bridge with given name\n            :param name: bridge name to delete\n            :return:\n            """\n            args = {\n                \'name\': name,\n            }\n\n            return self._client.json("ip.bridge.del", args)\n\n        def addif(self, name, inf):\n            """\n            Add interface to bridge\n            :param name: bridge name\n            :param inf: interface name to add\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'inf\': inf,\n            }\n\n            return self._client.json(\'ip.bridge.addif\', args)\n\n        def delif(self, name, inf):\n            """\n            Delete interface from bridge\n            :param name: bridge name\n            :param inf: interface to remove\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'inf\': inf,\n            }\n\n            return self._client.json(\'ip.bridge.delif\', args)\n\n    class IPLinkManager:\n        def __init__(self, client):\n            self._client = client\n\n        def up(self, link):\n            """\n            Set interface state to UP\n\n            :param link: link/interface name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.link.up\', args)\n\n        def down(self, link):\n            """\n            Set link/interface state to DOWN\n\n            :param link: link/interface name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.link.down\', args)\n\n        def name(self, link, name):\n            """\n            Rename link\n\n            :param link: link to rename\n            :param name: new name\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'new\': name,\n            }\n            return self._client.json(\'ip.link.name\', args)\n\n        def list(self):\n            return self._client.json(\'ip.link.list\', {})\n\n    class IPAddrManager:\n        def __init__(self, client):\n            self._client = client\n\n        def add(self, link, ip):\n            """\n            Add IP to link\n\n            :param link: link\n            :param ip: ip address to add\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'ip\': ip,\n            }\n            return self._client.json(\'ip.addr.add\', args)\n\n        def delete(self, link, ip):\n            """\n            Delete IP from link\n\n            :param link: link\n            :param ip: ip address to remove\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'ip\': ip,\n            }\n            return self._client.json(\'ip.addr.del\', args)\n\n        def list(self, link):\n            """\n            List IPs of a link\n\n            :param link: link name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.addr.list\', args)\n\n    class IPRouteManager:\n        def __init__(self, client):\n            self._client = client\n\n        def add(self, dev, dst, gw=None):\n            """\n            Add a route\n\n            :param dev: device name\n            :param dst: destination network\n            :param gw: optional gateway\n            :return:\n            """\n            args = {\n                \'dev\': dev,\n                \'dst\': dst,\n                \'gw\': gw,\n            }\n            return self._client.json(\'ip.route.add\', args)\n\n        def delete(self, dev, dst, gw=None):\n            """\n            Delete a route\n\n            :param dev: device name\n            :param dst: destination network\n            :param gw: optional gateway\n            :return:\n            """\n            args = {\n                \'dev\': dev,\n                \'dst\': dst,\n                \'gw\': gw,\n            }\n            return self._client.json(\'ip.route.del\', args)\n\n        def list(self):\n            return self._client.json(\'ip.route.list\', {})\n\n    def __init__(self, client):\n        self._client = client\n        self._bridge = IPManager.IPBridgeManager(client)\n        self._link = IPManager.IPLinkManager(client)\n        self._addr = IPManager.IPAddrManager(client)\n        self._route = IPManager.IPRouteManager(client)\n\n    @property\n    def bridge(self):\n        """\n        Bridge manager\n        :return:\n        """\n        return self._bridge\n\n    @property\n    def link(self):\n        """\n        Link manager\n        :return:\n        """\n        return self._link\n\n    @property\n    def addr(self):\n        """\n        Address manager\n        :return:\n        """\n        return self._addr\n\n    @property\n    def route(self):\n        """\n        Route manager\n        :return:\n        """\n        return self._route\n\n\nclass BridgeManager:\n    _bridge_create_chk = typchk.Checker({\n        \'name\': str,\n        \'hwaddr\': typchk.Or(str, typchk.IsNone()),\n        \'network\': {\n            \'mode\': typchk.Or(typchk.Enum(\'static\', \'dnsmasq\'), typchk.IsNone()),\n            \'nat\': bool,\n            \'settings\': typchk.Map(str, str),\n        }\n    })\n\n    _bridge_delete_chk = typchk.Checker({\n        \'name\': str,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def create(self, name, hwaddr=None, network=None, nat=False, settings={}):\n        """\n        Create a bridge with the given name, hwaddr and networking setup\n        :param name: name of the bridge (must be unique), 15 characters or less, and not equal to "default".\n        :param hwaddr: MAC address of the bridge. If none, a one will be created for u\n        :param network: Networking mode, options are none, static, and dnsmasq\n        :param nat: If true, SNAT will be enabled on this bridge. (IF and ONLY IF an IP is set on the bridge\n                    via the settings, otherwise flag will be ignored) (the cidr attribute of either static, or dnsmasq modes)\n        :param settings: Networking setting, depending on the selected mode.\n                        none:\n                            no settings, bridge won\'t get any ip settings\n                        static:\n                            settings={\'cidr\': \'ip/net\'}\n                            bridge will get assigned the given IP address\n                        dnsmasq:\n                            settings={\'cidr\': \'ip/net\', \'start\': \'ip\', \'end\': \'ip\'}\n                            bridge will get assigned the ip in cidr\n                            and each running container that is attached to this IP will get\n                            IP from the start/end range. Netmask of the range is the netmask\n                            part of the provided cidr.\n                            if nat is true, SNAT rules will be automatically added in the firewall.\n        """\n        args = {\n            \'name\': name,\n            \'hwaddr\': hwaddr,\n            \'network\': {\n                \'mode\': network,\n                \'nat\': nat,\n                \'settings\': settings,\n            }\n        }\n\n        self._bridge_create_chk.check(args)\n\n        response = self._client.raw(\'bridge.create\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to create bridge %s\' % result.data)\n\n        return json.loads(result.data)\n\n    def list(self):\n        """\n        List all available bridges\n        :return: list of bridge names\n        """\n        response = self._client.raw(\'bridge.list\', {})\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to list bridges: %s\' % result.data)\n\n        return json.loads(result.data)\n\n    def delete(self, bridge):\n        """\n        Delete a bridge by name\n\n        :param bridge: bridge name\n        :return:\n        """\n        args = {\n            \'name\': bridge,\n        }\n\n        self._bridge_delete_chk.check(args)\n\n        response = self._client.raw(\'bridge.delete\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to list delete: %s\' % result.data)\n\n\nclass DiskManager:\n    _mktable_chk = typchk.Checker({\n        \'disk\': str,\n        \'table_type\': typchk.Enum(\'aix\', \'amiga\', \'bsd\', \'dvh\', \'gpt\', \'mac\', \'msdos\', \'pc98\', \'sun\', \'loop\')\n    })\n\n    _mkpart_chk = typchk.Checker({\n        \'disk\': str,\n        \'start\': typchk.Or(int, str),\n        \'end\': typchk.Or(int, str),\n        \'part_type\': typchk.Enum(\'primary\', \'logical\', \'extended\'),\n    })\n\n    _getpart_chk = typchk.Checker({\n        \'disk\': str,\n        \'part\': str,\n    })\n\n    _rmpart_chk = typchk.Checker({\n        \'disk\': str,\n        \'number\': int,\n    })\n\n    _mount_chk = typchk.Checker({\n        \'options\': str,\n        \'source\': str,\n        \'target\': str,\n    })\n\n    _umount_chk = typchk.Checker({\n        \'source\': str,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def list(self):\n        """\n        List available block devices\n        """\n        response = self._client.raw(\'disk.list\', {})\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to list disks: %s\' % result.stderr)\n\n        if result.level != 20:  # 20 is JSON output.\n            raise RuntimeError(\'invalid response type from disk.list command\')\n\n        data = result.data.strip()\n        if data:\n            return json.loads(data)\n        else:\n            return {}\n\n    def mktable(self, disk, table_type=\'gpt\'):\n        """\n        Make partition table on block device.\n        :param disk: device name (sda, sdb, etc...)\n        :param table_type: Partition table type as accepted by parted\n        """\n        args = {\n            \'disk\': disk,\n            \'table_type\': table_type,\n        }\n\n        self._mktable_chk.check(args)\n\n        response = self._client.raw(\'disk.mktable\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to create table: %s\' % result.stderr)\n\n    def getinfo(self, disk, part=\'\'):\n        """\n        Get more info about a disk or a disk partition\n\n        :param disk: (sda, sdb, etc..)\n        :param part: (sda1, sdb2, etc...)\n        :return: a dict with {"blocksize", "start", "size", and "free" sections}\n        """\n        args = {\n            "disk": disk,\n            "part": part,\n        }\n\n        self._getpart_chk.check(args)\n\n        response = self._client.raw(\'disk.getinfo\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to get info: %s\' % result.data)\n\n        if result.level != 20:  # 20 is JSON output.\n            raise RuntimeError(\'invalid response type from disk.getinfo command\')\n\n        data = result.data.strip()\n        if data:\n            return json.loads(data)\n        else:\n            return {}\n\n    def mkpart(self, disk, start, end, part_type=\'primary\'):\n        """\n        Make partition on disk\n        :param disk: device name (sda, sdb, etc...)\n        :param start: partition start as accepted by parted mkpart\n        :param end: partition end as accepted by parted mkpart\n        :param part_type: partition type as accepted by parted mkpart\n        """\n        args = {\n            \'disk\': disk,\n            \'start\': start,\n            \'end\': end,\n            \'part_type\': part_type,\n        }\n\n        self._mkpart_chk.check(args)\n\n        response = self._client.raw(\'disk.mkpart\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to create partition: %s\' % result.stderr)\n\n    def rmpart(self, disk, number):\n        """\n        Remove partion from disk\n        :param disk: device name (sda, sdb, etc...)\n        :param number: Partition number (starting from 1)\n        """\n        args = {\n            \'disk\': disk,\n            \'number\': number,\n        }\n\n        self._rmpart_chk.check(args)\n\n        response = self._client.raw(\'disk.rmpart\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to remove partition: %s\' % result.stderr)\n\n    def mount(self, source, target, options=[]):\n        """\n        Mount partion on target\n        :param source: Full partition path like /dev/sda1\n        :param target: Mount point\n        :param options: Optional mount options\n        """\n\n        if len(options) == 0:\n            options = [\'\']\n\n        args = {\n            \'options\': \',\'.join(options),\n            \'source\': source,\n            \'target\': target,\n        }\n\n        self._mount_chk.check(args)\n        response = self._client.raw(\'disk.mount\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to mount partition: %s\' % result.stderr)\n\n    def umount(self, source):\n        """\n        Unmount partion\n        :param source: Full partition path like /dev/sda1\n        """\n\n        args = {\n            \'source\': source,\n        }\n        self._umount_chk.check(args)\n\n        response = self._client.raw(\'disk.umount\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to umount partition: %s\' % result.stderr)\n\n\nclass BtrfsManager:\n    _create_chk = typchk.Checker({\n        \'label\': str,\n        \'metadata\': typchk.Enum("raid0", "raid1", "raid5", "raid6", "raid10", "dup", "single", ""),\n        \'data\': typchk.Enum("raid0", "raid1", "raid5", "raid6", "raid10", "dup", "single", ""),\n        \'devices\': typchk.Length([str], 1),\n        \'overwrite\': bool,\n    })\n\n    _device_chk = typchk.Checker({\n        \'mountpoint\': str,\n        \'devices\': typchk.Length((str,), 1),\n    })\n\n    _subvol_chk = typchk.Checker({\n        \'path\': str,\n    })\n\n    _subvol_quota_chk = typchk.Checker({\n        \'path\': str,\n        \'limit\': str,\n    })\n\n    _subvol_snapshot_chk = typchk.Checker({\n        \'source\': str,\n        \'destination\': str,\n        \'read_only\': bool,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def list(self):\n        """\n        List all btrfs filesystem\n        """\n        return self._client.json(\'btrfs.list\', {})\n\n    def info(self, mountpoint):\n        """\n        Get btrfs fs info\n        """\n        return self._client.json(\'btrfs.info\', {\'mountpoint\': mountpoint})\n\n    def create(self, label, devices, metadata_profile="", data_profile="", overwrite=False):\n        """\n        Create a btrfs filesystem with the given label, devices, and profiles\n        :param label: name/label\n        :param devices : array of devices (/dev/sda1, etc...)\n        :metadata_profile: raid0, raid1, raid5, raid6, raid10, dup or single\n        :data_profile: same as metadata profile\n        :overwrite: force creation of the filesystem. Overwrite any existing filesystem\n        """\n        args = {\n            \'label\': label,\n            \'metadata\': metadata_profile,\n            \'data\': data_profile,\n            \'devices\': devices,\n            \'overwrite\': overwrite\n        }\n\n        self._create_chk.check(args)\n\n        self._client.sync(\'btrfs.create\', args)\n\n    def device_add(self, mountpoint, *device):\n        """\n        Add one or more devices to btrfs filesystem mounted under `mountpoint`\n\n        :param mountpoint: mount point of the btrfs system\n        :param devices: one ore more devices to add\n        :return:\n        """\n        if len(device) == 0:\n            return\n\n        args = {\n            \'mountpoint\': mountpoint,\n            \'devices\': device,\n        }\n\n        self._device_chk.check(args)\n\n        self._client.sync(\'btrfs.device_add\', args)\n\n    def device_remove(self, mountpoint, *device):\n        """\n        Remove one or more devices from btrfs filesystem mounted under `mountpoint`\n\n        :param mountpoint: mount point of the btrfs system\n        :param devices: one ore more devices to remove\n        :return:\n        """\n        if len(device) == 0:\n            return\n\n        args = {\n            \'mountpoint\': mountpoint,\n            \'devices\': device,\n        }\n\n        self._device_chk.check(args)\n\n        self._client.sync(\'btrfs.device_remove\', args)\n\n    def subvol_create(self, path):\n        """\n        Create a btrfs subvolume in the specified path\n        :param path: path to create\n        """\n        args = {\n            \'path\': path\n        }\n        self._subvol_chk.check(args)\n        self._client.sync(\'btrfs.subvol_create\', args)\n\n    def subvol_list(self, path):\n        """\n        List a btrfs subvolume in the specified path\n        :param path: path to be listed\n        """\n        return self._client.json(\'btrfs.subvol_list\', {\n            \'path\': path\n        })\n\n    def subvol_delete(self, path):\n        """\n        Delete a btrfs subvolume in the specified path\n        :param path: path to delete\n        """\n        args = {\n            \'path\': path\n        }\n\n        self._subvol_chk.check(args)\n\n        self._client.sync(\'btrfs.subvol_delete\', args)\n\n    def subvol_quota(self, path, limit):\n        """\n        Apply a quota to a btrfs subvolume in the specified path\n        :param path:  path to apply the quota for (it has to be the path of the subvol)\n        :param limit: the limit to Apply\n        """\n        args = {\n            \'path\': path,\n            \'limit\': limit,\n        }\n\n        self._subvol_quota_chk.check(args)\n\n        self._client.sync(\'btrfs.subvol_quota\', args)\n\n    def subvol_snapshot(self, source, destination, read_only=False):\n        """\n        Take a snapshot\n\n        :param source: source path of subvol\n        :param destination: destination path of snapshot\n        :param read_only: Set read-only on the snapshot\n        :return:\n        """\n\n        args = {\n            "source": source,\n            "destination": destination,\n            "read_only": read_only,\n        }\n\n        self._subvol_snapshot_chk.check(args)\n        self._client.sync(\'btrfs.subvol_snapshot\', args)\n\n\nclass ZerotierManager:\n    _network_chk = typchk.Checker({\n        \'network\': str,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def join(self, network):\n        """\n        Join a zerotier network\n\n        :param network: network id to join\n        :return:\n        """\n        args = {\'network\': network}\n        self._network_chk.check(args)\n        response = self._client.raw(\'zerotier.join\', args)\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to join zerotier network: %s\', result.stderr)\n\n    def leave(self, network):\n        """\n        Leave a zerotier network\n\n        :param network: network id to leave\n        :return:\n        """\n        args = {\'network\': network}\n        self._network_chk.check(args)\n        response = self._client.raw(\'zerotier.leave\', args)\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to leave zerotier network: %s\', result.stderr)\n\n    def list(self):\n        """\n        List joined zerotier networks\n\n        :return: list of joined networks with their info\n        """\n        return self._client.json(\'zerotier.list\', {})\n\n    def info(self):\n        """\n        Display zerotier status info\n\n        :return: dict of zerotier statusinfo\n        """\n        return self._client.json(\'zerotier.info\', {})\n\n\nclass KvmManager:\n    _iotune_dict = {\n        \'totalbytessecset\': typchk.Or(bool, typchk.Missing()),\n        \'totalbytessec\': typchk.Or(int, typchk.Missing()),\n        \'readbytessecset\': typchk.Or(bool, typchk.Missing()),\n        \'readbytessec\': typchk.Or(int, typchk.Missing()),\n        \'writebytessecset\': typchk.Or(bool, typchk.Missing()),\n        \'writebytessec\': typchk.Or(int, typchk.Missing()),\n        \'totaliopssecset\': typchk.Or(bool, typchk.Missing()),\n        \'totaliopssec\': typchk.Or(int, typchk.Missing()),\n        \'readiopssecset\': typchk.Or(bool, typchk.Missing()),\n        \'readiopssec\': typchk.Or(int, typchk.Missing()),\n        \'writeiopssecset\': typchk.Or(bool, typchk.Missing()),\n        \'writeiopssec\': typchk.Or(int, typchk.Missing()),\n        \'totalbytessecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'totalbytessecmax\': typchk.Or(int, typchk.Missing()),\n        \'readbytessecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'readbytessecmax\': typchk.Or(int, typchk.Missing()),\n        \'writebytessecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'writebytessecmax\': typchk.Or(int, typchk.Missing()),\n        \'totaliopssecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'totaliopssecmax\': typchk.Or(int, typchk.Missing()),\n        \'readiopssecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'readiopssecmax\': typchk.Or(int, typchk.Missing()),\n        \'writeiopssecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'writeiopssecmax\': typchk.Or(int, typchk.Missing()),\n        \'totalbytessecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'totalbytessecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'readbytessecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'readbytessecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'writebytessecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'writebytessecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'totaliopssecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'totaliopssecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'readiopssecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'readiopssecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'writeiopssecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'writeiopssecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'sizeiopssecset\': typchk.Or(bool, typchk.Missing()),\n        \'sizeiopssec\': typchk.Or(int, typchk.Missing()),\n        \'groupnameset\': typchk.Or(bool, typchk.Missing()),\n        \'groupname\': typchk.Or(str, typchk.Missing()),\n    }\n    _media_dict = {\n        \'type\': typchk.Or(\n            typchk.Enum(\'disk\', \'cdrom\'),\n            typchk.Missing()\n        ),\n        \'url\': str,\n        \'iotune\': typchk.Or(\n            _iotune_dict,\n            typchk.Missing()\n        )\n    }\n    _create_chk = typchk.Checker({\n        \'name\': str,\n        \'media\': typchk.Length([_media_dict], 1),\n        \'cpu\': int,\n        \'memory\': int,\n        \'nics\': [{\n            \'type\': typchk.Enum(\'default\', \'bridge\', \'vxlan\', \'vlan\'),\n            \'id\': typchk.Or(str, typchk.Missing()),\n            \'hwaddr\': typchk.Or(str, typchk.Missing()),\n        }],\n        \'port\': typchk.Or(\n            typchk.Map(int, int),\n            typchk.IsNone()\n        ),\n    })\n\n    _domain_action_chk = typchk.Checker({\n        \'uuid\': str,\n    })\n\n    _man_disk_action_chk = typchk.Checker({\n        \'uuid\': str,\n        \'media\': _media_dict,\n    })\n\n    _man_nic_action_chk = typchk.Checker({\n        \'uuid\': str,\n        \'type\': typchk.Enum(\'default\', \'bridge\', \'vxlan\', \'vlan\'),\n        \'id\': typchk.Or(str, typchk.Missing()),\n        \'hwaddr\': typchk.Or(str, typchk.Missing()),\n    })\n\n    _migrate_action_chk = typchk.Checker({\n        \'uuid\': str,\n        \'desturi\': str,\n    })\n\n    _limit_disk_io_dict = {\n        \'uuid\': str,\n        \'media\': _media_dict,\n    }\n\n    _limit_disk_io_dict.update(_iotune_dict)\n\n    _limit_disk_io_action_chk = typchk.Checker(_limit_disk_io_dict)\n\n    def __init__(self, client):\n        self._client = client\n\n    def create(self, name, media, cpu=2, memory=512, nics=None, port=None):\n        """\n        :param name: Name of the kvm domain\n        :param media: array of media objects to attach to the machine, where the first object is the boot device\n                      each media object is a dict of {url, type} where type can be one of \'disk\', or \'cdrom\', or empty (default to disk)\n                      example: [{\'url\': \'nbd+unix:///test?socket=/tmp/ndb.socket\'}, {\'type\': \'cdrom\': \'/somefile.iso\'}\n        :param cpu: number of vcpu cores\n        :param memory: memory in MiB\n        :param port: A dict of host_port: container_port pairs\n                       Example:\n                        `port={8080: 80, 7000:7000}`\n                     Only supported if default network is used\n        :param nics: Configure the attached nics to the container\n                     each nic object is a dict of the format\n                     {\n                        \'type\': nic_type # default, bridge, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n                        \'id\': id # depends on the type, bridge name (bridge type) zerotier network id (zertier type), the vlan tag or the vxlan id\n                     }\n        :return: uuid of the virtual machine\n        """\n\n        if nics is None:\n            nics = []\n\n        args = {\n            \'name\': name,\n            \'media\': media,\n            \'cpu\': cpu,\n            \'memory\': memory,\n            \'nics\': nics,\n            \'port\': port,\n        }\n        self._create_chk.check(args)\n\n        return self._client.sync(\'kvm.create\', args)\n\n    def destroy(self, uuid):\n        """\n        Destroy a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.destroy\', args)\n\n    def shutdown(self, uuid):\n        """\n        Shutdown a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.shutdown\', args)\n\n    def reboot(self, uuid):\n        """\n        Reboot a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.reboot\', args)\n\n    def reset(self, uuid):\n        """\n        Reset (Force reboot) a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.reset\', args)\n\n    def pause(self, uuid):\n        """\n        Pause a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.pause\', args)\n\n    def resume(self, uuid):\n        """\n        Resume a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.resume\', args)\n\n    def info(self, uuid):\n        """\n        Get info about a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        return self._client.json(\'kvm.info\', args)\n\n    def infops(self, uuid):\n        """\n        Get info per second about a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        return self._client.json(\'kvm.infops\', args)\n\n    def attach_disk(self, uuid, media):\n        """\n        Attach a disk to a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param media: the media object to attach to the machine\n                      media object is a dict of {url, and type} where type can be one of \'disk\', or \'cdrom\', or empty (default to disk)\n                      examples: {\'url\': \'nbd+unix:///test?socket=/tmp/ndb.socket\'}, {\'type\': \'cdrom\': \'/somefile.iso\'}\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'media\': media,\n        }\n        self._man_disk_action_chk.check(args)\n\n        self._client.sync(\'kvm.attach_disk\', args)\n\n    def detach_disk(self, uuid, media):\n        """\n        Detach a disk from a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param media: the media object to attach to the machine\n                      media object is a dict of {url, and type} where type can be one of \'disk\', or \'cdrom\', or empty (default to disk)\n                      examples: {\'url\': \'nbd+unix:///test?socket=/tmp/ndb.socket\'}, {\'type\': \'cdrom\': \'/somefile.iso\'}\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'media\': media,\n        }\n        self._man_disk_action_chk.check(args)\n\n        self._client.sync(\'kvm.detach_disk\', args)\n\n    def add_nic(self, uuid, type, id=None, hwaddr=None):\n        """\n        Add a nic to a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param type: nic_type # default, bridge, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n         param id: id # depends on the type, bridge name (bridge type) zerotier network id (zertier type), the vlan tag or the vxlan id\n         param hwaddr: the hardware address of the nic\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'type\': type,\n            \'id\': id,\n            \'hwaddr\': hwaddr,\n        }\n        self._man_nic_action_chk.check(args)\n\n        return self._client.json(\'kvm.add_nic\', args)\n\n    def remove_nic(self, uuid, type, id=None, hwaddr=None):\n        """\n        Remove a nic from a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param type: nic_type # default, bridge, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n         param id: id # depends on the type, bridge name (bridge type) zerotier network id (zertier type), the vlan tag or the vxlan id\n         param hwaddr: the hardware address of the nic\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'type\': type,\n            \'id\': id,\n            \'hwaddr\': hwaddr,\n        }\n        self._man_nic_action_chk.check(args)\n\n        return self._client.json(\'kvm.remove_nic\', args)\n\n    def limit_disk_io(self, uuid, media, totalbytessecset=False, totalbytessec=0, readbytessecset=False, readbytessec=0, writebytessecset=False,\n                      writebytessec=0, totaliopssecset=False, totaliopssec=0, readiopssecset=False, readiopssec=0, writeiopssecset=False, writeiopssec=0,\n                      totalbytessecmaxset=False, totalbytessecmax=0, readbytessecmaxset=False, readbytessecmax=0, writebytessecmaxset=False, writebytessecmax=0,\n                      totaliopssecmaxset=False, totaliopssecmax=0, readiopssecmaxset=False, readiopssecmax=0, writeiopssecmaxset=False, writeiopssecmax=0,\n                      totalbytessecmaxlengthset=False, totalbytessecmaxlength=0, readbytessecmaxlengthset=False, readbytessecmaxlength=0,\n                      writebytessecmaxlengthset=False, writebytessecmaxlength=0, totaliopssecmaxlengthset=False, totaliopssecmaxlength=0,\n                      readiopssecmaxlengthset=False, readiopssecmaxlength=0, writeiopssecmaxlengthset=False, writeiopssecmaxlength=0, sizeiopssecset=False,\n                      sizeiopssec=0, groupnameset=False, groupname=\'\'):\n        """\n        Remove a nic from a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param media: the media to limit the diskio\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'media\': media,\n            \'totalbytessecset\': totalbytessecset,\n            \'totalbytessec\': totalbytessec,\n            \'readbytessecset\': readbytessecset,\n            \'readbytessec\': readbytessec,\n            \'writebytessecset\': writebytessecset,\n            \'writebytessec\': writebytessec,\n            \'totaliopssecset\': totaliopssecset,\n            \'totaliopssec\': totaliopssec,\n            \'readiopssecset\': readiopssecset,\n            \'readiopssec\': readiopssec,\n            \'writeiopssecset\': writeiopssecset,\n            \'writeiopssec\': writeiopssec,\n            \'totalbytessecmaxset\': totalbytessecmaxset,\n            \'totalbytessecmax\': totalbytessecmax,\n            \'readbytessecmaxset\': readbytessecmaxset,\n            \'readbytessecmax\': readbytessecmax,\n            \'writebytessecmaxset\': writebytessecmaxset,\n            \'writebytessecmax\': writebytessecmax,\n            \'totaliopssecmaxset\': totaliopssecmaxset,\n            \'totaliopssecmax\': totaliopssecmax,\n            \'readiopssecmaxset\': readiopssecmaxset,\n            \'readiopssecmax\': readiopssecmax,\n            \'writeiopssecmaxset\': writeiopssecmaxset,\n            \'writeiopssecmax\': writeiopssecmax,\n            \'totalbytessecmaxlengthset\': totalbytessecmaxlengthset,\n            \'totalbytessecmaxlength\': totalbytessecmaxlength,\n            \'readbytessecmaxlengthset\': readbytessecmaxlengthset,\n            \'readbytessecmaxlength\': readbytessecmaxlength,\n            \'writebytessecmaxlengthset\': writebytessecmaxlengthset,\n            \'writebytessecmaxlength\': writebytessecmaxlength,\n            \'totaliopssecmaxlengthset\': totaliopssecmaxlengthset,\n            \'totaliopssecmaxlength\': totaliopssecmaxlength,\n            \'readiopssecmaxlengthset\': readiopssecmaxlengthset,\n            \'readiopssecmaxlength\': readiopssecmaxlength,\n            \'writeiopssecmaxlengthset\': writeiopssecmaxlengthset,\n            \'writeiopssecmaxlength\': writeiopssecmaxlength,\n            \'sizeiopssecset\': sizeiopssecset,\n            \'sizeiopssec\': sizeiopssec,\n            \'groupnameset\': groupnameset,\n            \'groupname\': groupname,\n        }\n        self._limit_disk_io_action_chk.check(args)\n\n        self._client.sync(\'kvm.limit_disk_io\', args)\n\n    def migrate(self, uuid, desturi):\n        """\n        Migrate a vm to another node\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param desturi: the uri of the destination node\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'desturi\': desturi,\n        }\n        self._migrate_action_chk.check(args)\n\n        self._client.sync(\'kvm.migrate\', args)\n\n    def list(self):\n        """\n        List configured domains\n\n        :return:\n        """\n        return self._client.json(\'kvm.list\', {})\n\n\nclass Logger:\n    _level_chk = typchk.Checker({\n        \'level\': typchk.Enum("CRITICAL", "ERROR", "WARNING", "NOTICE", "INFO", "DEBUG"),\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def set_level(self, level):\n        """\n        Set the log level of the g8os\n        :param level: the level to be set can be one of ("CRITICAL", "ERROR", "WARNING", "NOTICE", "INFO", "DEBUG")\n        """\n        args = {\n            \'level\': level,\n        }\n        self._level_chk.check(args)\n\n        return self._client.json(\'logger.set_level\', args)\n\n    def reopen(self):\n        """\n        Reopen log file (rotate)\n        """\n        return self._client.json(\'logger.reopen\', {})\n\n\nclass Nft:\n    _port_chk = typchk.Checker({\n        \'port\': int,\n        \'interface\': typchk.Or(str, typchk.IsNone()),\n        \'subnet\': typchk.Or(str, typchk.IsNone()),\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def open_port(self, port, interface=None, subnet=None):\n        """\n        open port\n        :param port: then port number\n        :param interface: an optional interface to open the port for\n        :param subnet: an optional subnet to open the port for\n        """\n        args = {\n            \'port\': port,\n            \'interface\': interface,\n            \'subnet\': subnet,\n        }\n        self._port_chk.check(args)\n\n        return self._client.json(\'nft.open_port\', args)\n\n    def drop_port(self, port, interface=None, subnet=None):\n        """\n        close an opened port (takes the same parameters passed in open)\n        :param port: then port number\n        :param interface: an optional interface to close the port for\n        :param subnet: an optional subnet to close the port for\n        """\n        args = {\n            \'port\': port,\n            \'interface\': interface,\n            \'subnet\': subnet,\n        }\n        self._port_chk.check(args)\n\n        return self._client.json(\'nft.drop_port\', args)\n\n    def list(self):\n        """\n        List open ports\n        """\n        return self._client.json(\'nft.list\', {})\n\n    def rule_exists(self, port, interface=None, subnet=None):\n        """\n        Check if a rule exists (takes the same parameters passed in open)\n        :param port: then port number\n        :param interface: an optional interface\n        :param subnet: an optional subnet\n        """\n        args = {\n            \'port\': port,\n            \'interface\': interface,\n            \'subnet\': subnet,\n        }\n        self._port_chk.check(args)\n\n        return self._client.json(\'nft.rule_exists\', args)\n\n\nclass Config:\n\n    def __init__(self, client):\n        self._client = client\n\n    def get(self):\n        """\n        Get the config of g8os\n        """\n        return self._client.json(\'config.get\', {})\n\n\nclass AggregatorManager:\n    _query_chk = typchk.Checker({\n        \'key\': typchk.Or(str, typchk.IsNone()),\n        \'tags\': typchk.Map(str, str),\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def query(self, key=None, **tags):\n        """\n        Query zero-os aggregator for current state object of monitored metrics.\n        \n        Note: ID is returned as part of the key (if set) to avoid conflict with similar metrics that\n        has same key. For example, a cpu core nr can be the id associated with \'machine.CPU.percent\' \n        so we can return all values for all the core numbers in the same dict.\n        \n        U can filter on the ID as a tag\n        :example:\n            self.query(key=key, id=value)\n            \n        :param key: metric key (ex: machine.memory.ram.available) \n        :param tags: optional tags filter\n        :return: dict of {\n            \'key[/id]\': state object\n        }\n        """\n        args = {\n            \'key\': key,\n            \'tags\': tags,\n        }\n        self._query_chk.check(args)\n\n        return self._client.json(\'aggregator.query\', args)\n\n\nclass Client(BaseClient):\n\n    def __init__(self, host, port=6379, password="", db=0, ssl=True, timeout=None, testConnectionAttempts=3):\n        super().__init__(timeout=timeout)\n\n        socket_timeout = (timeout + 5) if timeout else 15\n        socket_keepalive_options = dict()\n        if hasattr(socket, \'TCP_KEEPIDLE\'):\n            socket_keepalive_options[socket.TCP_KEEPIDLE] = 1\n        if hasattr(socket, \'TCP_KEEPINTVL\'):\n            socket_keepalive_options[socket.TCP_KEEPINTVL] = 1\n        if hasattr(socket, \'TCP_KEEPIDLE\'):\n            socket_keepalive_options[socket.TCP_KEEPIDLE] = 1\n        self._redis = redis.Redis(host=host, port=port, password=password, db=db, ssl=ssl,\n                                  socket_timeout=socket_timeout,\n                                  socket_keepalive=True, socket_keepalive_options=socket_keepalive_options)\n        self._container_manager = ContainerManager(self)\n        self._bridge_manager = BridgeManager(self)\n        self._disk_manager = DiskManager(self)\n        self._btrfs_manager = BtrfsManager(self)\n        self._zerotier = ZerotierManager(self)\n        self._kvm = KvmManager(self)\n        self._logger = Logger(self)\n        self._nft = Nft(self)\n        self._config = Config(self)\n        self._aggregator = AggregatorManager(self)\n\n        if testConnectionAttempts:\n            for _ in range(testConnectionAttempts):\n                try:\n                    self.ping()\n                except:\n                    pass\n                else:\n                    return\n            raise RuntimeError("Could not connect to remote host %s" % host)\n\n    @property\n    def container(self):\n        """\n        Container manager\n        :return:\n        """\n        return self._container_manager\n\n    @property\n    def bridge(self):\n        """\n        Bridge manager\n        :return:\n        """\n        return self._bridge_manager\n\n    @property\n    def disk(self):\n        """\n        Disk manager\n        :return:\n        """\n        return self._disk_manager\n\n    @property\n    def btrfs(self):\n        """\n        Btrfs manager\n        :return:\n        """\n        return self._btrfs_manager\n\n    @property\n    def zerotier(self):\n        """\n        Zerotier manager\n        :return:\n        """\n        return self._zerotier\n\n    @property\n    def kvm(self):\n        """\n        KVM manager\n        :return:\n        """\n        return self._kvm\n\n    @property\n    def logger(self):\n        """\n        Logger manager\n        :return:\n        """\n        return self._logger\n\n    @property\n    def nft(self):\n        """\n        NFT manager\n        :return:\n        """\n        return self._nft\n\n    @property\n    def config(self):\n        """\n        Config manager\n        :return:\n        """\n        return self._config\n\n    @property\n    def aggregator(self):\n        """\n        Aggregator manager\n        :return: \n        """\n        return self._aggregator\n\n    def raw(self, command, arguments, queue=None, max_time=None, stream=False):\n        """\n        Implements the low level command call, this needs to build the command structure\n        and push it on the correct queue.\n\n        :param command: Command name to execute supported by the node (ex: core.system, info.cpu, etc...)\n                        check documentation for list of built in commands\n        :param arguments: A dict of required command arguments depends on the command name.\n        :param queue: command queue (commands on the same queue are executed sequentially)\n        :param max_time: kill job server side if it exceeded this amount of seconds\n        :param stream: If True, process stdout and stderr are pushed to a special queue (stream:<id>) so\n            client can stream output\n        :return: Response object\n        """\n        id = str(uuid.uuid4())\n\n        payload = {\n            \'id\': id,\n            \'command\': command,\n            \'arguments\': arguments,\n            \'queue\': queue,\n            \'max_time\': max_time,\n            \'stream\': stream,\n        }\n\n        flag = \'result:{}:flag\'.format(id)\n        self._redis.rpush(\'core:default\', json.dumps(payload))\n        if self._redis.brpoplpush(flag, flag, DefaultTimeout) is None:\n            Timeout(\'failed to queue job {}\'.format(id))\n        logger.debug(\'%s >> g8core.%s(%s)\', id, command, \', \'.join(("%s=%s" % (k, v) for k, v in arguments.items())))\n\n        return Response(self, id)\n\n    def response_for(self, id):\n        return Response(self, id)\n'
u'3,class Timeout(Exception):\n    pass\n'
u'4,class JobNotFound(Exception):\n    pass\n'
u'5,class Return:\n\n    def __init__(self, payload):\n        self._payload = payload\n\n    @property\n    def payload(self):\n        """\n        Raw return object data\n        :return: dict\n        """\n        return self._payload\n\n    @property\n    def id(self):\n        """\n        Job ID\n        :return: string\n        """\n        return self._payload[\'id\']\n\n    @property\n    def data(self):\n        """\n        Data returned by the process. Only available if process\n        output data with the correct core level\n\n        For example, if a job returns a json object the self.level will be 20 and the data will contain the serialized\n        json object, other levels exists for yaml, toml, etc... it really depends on the running job\n        return: python primitive (str, number, dict or array)\n        """\n        return self._payload[\'data\']\n\n    @property\n    def level(self):\n        """\n        Data message level (if any)\n        """\n        return self._payload[\'level\']\n\n    @property\n    def starttime(self):\n        """\n        Starttime as a timestamp\n        """\n        return self._payload[\'starttime\'] / 1000\n\n    @property\n    def time(self):\n        """\n        Execution time in millisecond\n        """\n        return self._payload[\'time\']\n\n    @property\n    def state(self):\n        """\n        Exit state\n        :return: str one of [SUCCESS, ERROR, KILLED, TIMEOUT, UNKNOWN_CMD, DUPLICATE_ID]\n        """\n        return self._payload[\'state\']\n\n    @property\n    def stdout(self):\n        """\n        The job stdout\n        :return: string or None\n        """\n        streams = self._payload.get(\'streams\', None)\n        return streams[0] if streams is not None and len(streams) >= 1 else \'\'\n\n    @property\n    def stderr(self):\n        """\n        The job stderr\n        :return: string or None\n        """\n        streams = self._payload.get(\'streams\', None)\n        return streams[1] if streams is not None and len(streams) >= 2 else \'\'\n\n    def __repr__(self):\n        return str(self)\n\n    def __str__(self):\n        tmpl = """\\\n        STATE: {state}\n        STDOUT:\n        {stdout}\n        STDERR:\n        {stderr}\n        DATA:\n        {data}\n        """\n\n        return textwrap.dedent(tmpl).format(state=self.state, stdout=self.stdout, stderr=self.stderr, data=self.data)\n'
u'6,class Response:\n\n    def __init__(self, client, id):\n        self._client = client\n        self._id = id\n        self._queue = \'result:{}\'.format(id)\n\n    @property\n    def id(self):\n        """\n        Job ID\n        :return: string\n        """\n        return self._id\n\n    @property\n    def exists(self):\n        """\n        Returns true if the job is still running or zero-os still knows about this job ID\n\n        After a job is finished, a job remains on zero-os for max of 5min where you still can read the job result\n        after the 5 min is gone, the job result is no more fetchable\n        :return: bool\n        """\n        r = self._client._redis\n        flag = \'{}:flag\'.format(self._queue)\n        return bool(r.execute_command(\'LKEYEXISTS\', flag))\n\n    @property\n    def running(self):\n        """\n        Returns true if job still in running state\n        :return:\n        """\n        r = self._client._redis\n        flag = \'{}:flag\'.format(self._queue)\n        if bool(r.execute_command(\'LKEYEXISTS\', flag)):\n            return r.execute_command(\'LTTL\', flag) == -1\n\n        return False\n\n    def stream(self, out=sys.stdout, err=sys.stderr):\n        """\n        Runtime copy of job stdout and stderr. This required the \'stream` flag to be set to True otherwise it will\n        not be able to copy any output, while it will block until the process exits.\n\n        :note: This function will block until it reaches end of stream or the process is no longer running.\n\n        :param out: Output stream\n        :param err: Error stream\n\n        :return: None\n        """\n        queue = \'stream:%s\' % self.id\n        r = self._client._redis\n\n        # we can terminate quickly by checking if the process is not running and it has no queued output.\n        if not self.running and r.llen(queue) == 0:\n            return\n\n        while True:\n            data = r.blpop(queue, 10)\n            if data is None:\n                if not self.running:\n                    break\n                continue\n            _, body = data\n            payload = json.loads(body.decode())\n            message = payload[\'message\']\n            line = message[\'message\']\n            meta = message[\'meta\']\n            if meta & 0x0006 != 0:\n                #eof flags are 0x2 (success) or 0x4 error\n                break\n            level = meta >> 16\n            w = out if level == 1 else err\n\n            if w is not None:\n                w.write(line)\n                w.write(\'\\n\')\n\n    def get(self, timeout=None):\n        """\n        Waits for a job to finish (max of given timeout seconds) and return job results. When a job exits get() will\n        keep returning the same result until zero-os doesn\'t remember the job anymore (self.exists == False)\n\n        :notes: the timeout here is a client side timeout, it\'s different than the timeout given to the job on start\n        (like in system method) witch will cause the job to be killed if it exceeded this timeout.\n\n        :param timeout: max time to wait for the job to finish in seconds\n        :return: Return object\n        """\n        if timeout is None:\n            timeout = self._client.timeout\n        r = self._client._redis\n        start = time.time()\n        maxwait = timeout\n        while maxwait > 0:\n            if not self.exists:\n                raise JobNotFound(self.id)\n            v = r.brpoplpush(self._queue, self._queue, 10)\n            if v is not None:\n                payload = json.loads(v.decode())\n                r = Return(payload)\n                logger.debug(\'%s << %s, stdout="%s", stderr="%s", data="%s"\',\n                             self._id, r.state, r.stdout, r.stderr, r.data[:1000])\n                return r\n            logger.debug(\'%s still waiting (%ss)\', self._id, int(time.time() - start))\n            maxwait -= 10\n        raise Timeout()\n'
u'7,class InfoManager:\n\n    def __init__(self, client):\n        self._client = client\n\n    def cpu(self):\n        """\n        CPU information\n        :return:\n        """\n        return self._client.json(\'info.cpu\', {})\n\n    def nic(self):\n        """\n        Return (physical) network devices information including IPs\n        :return:\n        """\n        return self._client.json(\'info.nic\', {})\n\n    def mem(self):\n        """\n        Memory information\n        :return:\n        """\n        return self._client.json(\'info.mem\', {})\n\n    def disk(self):\n        """\n        Disk information\n        :return:\n        """\n        return self._client.json(\'info.disk\', {})\n\n    def os(self):\n        """\n        Operating system info\n        :return:\n        """\n        return self._client.json(\'info.os\', {})\n\n    def port(self):\n        """\n        Return information about open ports on the system (similar to netstat)\n        :return:\n        """\n        return self._client.json(\'info.port\', {})\n\n    def version(self):\n        """\n        Return OS version\n        :return:\n        """\n        return self._client.json(\'info.version\', {})\n'
u'8,class JobManager:\n    _job_chk = typchk.Checker({\n        \'id\': typchk.Or(str, typchk.IsNone()),\n    })\n\n    _kill_chk = typchk.Checker({\n        \'id\': str,\n        \'signal\': int,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def list(self, id=None):\n        """\n        List all running jobs\n\n        :param id: optional ID for the job to list\n        """\n        args = {\'id\': id}\n        self._job_chk.check(args)\n        return self._client.json(\'job.list\', args)\n\n    def kill(self, id, signal=signal.SIGTERM):\n        """\n        Kill a job with given id\n\n        :WARNING: beware of what u kill, if u killed redis for example core0 or coreX won\'t be reachable\n\n        :param id: job id to kill\n        """\n        args = {\n            \'id\': id,\n            \'signal\': int(signal),\n        }\n        self._kill_chk.check(args)\n        return self._client.json(\'job.kill\', args)\n'
u'9,class ProcessManager:\n    _process_chk = typchk.Checker({\n        \'pid\': typchk.Or(int, typchk.IsNone()),\n    })\n\n    _kill_chk = typchk.Checker({\n        \'pid\': int,\n        \'signal\': int,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def list(self, id=None):\n        """\n        List all running processes\n\n        :param id: optional PID for the process to list\n        """\n        args = {\'pid\': id}\n        self._process_chk.check(args)\n        return self._client.json(\'process.list\', args)\n\n    def kill(self, pid, signal=signal.SIGTERM):\n        """\n        Kill a process with given pid\n\n        :WARNING: beware of what u kill, if u killed redis for example core0 or coreX won\'t be reachable\n\n        :param pid: PID to kill\n        """\n        args = {\n            \'pid\': pid,\n            \'signal\': int(signal),\n        }\n        self._kill_chk.check(args)\n        return self._client.json(\'process.kill\', args)\n'
u'10,class FilesystemManager:\n\n    def __init__(self, client):\n        self._client = client\n\n    def open(self, file, mode=\'r\', perm=0o0644):\n        """\n        Opens a file on the node\n\n        :param file: file path to open\n        :param mode: open mode\n        :param perm: file permission in octet form\n\n        mode:\n          \'r\' read only\n          \'w\' write only (truncate)\n          \'+\' read/write\n          \'x\' create if not exist\n          \'a\' append\n        :return: a file descriptor\n        """\n        args = {\n            \'file\': file,\n            \'mode\': mode,\n            \'perm\': perm,\n        }\n\n        return self._client.json(\'filesystem.open\', args)\n\n    def exists(self, path):\n        """\n        Check if path exists\n\n        :param path: path to file/dir\n        :return: boolean\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.exists\', args)\n\n    def list(self, path):\n        """\n        List all entries in directory\n        :param path: path to dir\n        :return: list of director entries\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.list\', args)\n\n    def mkdir(self, path):\n        """\n        Make a new directory == mkdir -p path\n        :param path: path to directory to create\n        :return:\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.mkdir\', args)\n\n    def remove(self, path):\n        """\n        Removes a path (recursively)\n\n        :param path: path to remove\n        :return:\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.remove\', args)\n\n    def move(self, path, destination):\n        """\n        Move a path to destination\n\n        :param path: source\n        :param destination: destination\n        :return:\n        """\n        args = {\n            \'path\': path,\n            \'destination\': destination,\n        }\n\n        return self._client.json(\'filesystem.move\', args)\n\n    def chmod(self, path, mode, recursive=False):\n        """\n        Change file/dir permission\n\n        :param path: path of file/dir to change\n        :param mode: octet mode\n        :param recursive: apply chmod recursively\n        :return:\n        """\n        args = {\n            \'path\': path,\n            \'mode\': mode,\n            \'recursive\': recursive,\n        }\n\n        return self._client.json(\'filesystem.chmod\', args)\n\n    def chown(self, path, user, group, recursive=False):\n        """\n        Change file/dir owner\n\n        :param path: path of file/dir\n        :param user: user name\n        :param group: group name\n        :param recursive: apply chown recursively\n        :return:\n        """\n        args = {\n            \'path\': path,\n            \'user\': user,\n            \'group\': group,\n            \'recursive\': recursive,\n        }\n\n        return self._client.json(\'filesystem.chown\', args)\n\n    def read(self, fd):\n        """\n        Read a block from the given file descriptor\n\n        :param fd: file descriptor\n        :return: bytes\n        """\n        args = {\n            \'fd\': fd,\n        }\n\n        data = self._client.json(\'filesystem.read\', args)\n        return base64.decodebytes(data.encode())\n\n    def write(self, fd, bytes):\n        """\n        Write a block of bytes to an open file descriptor (that is open with one of the writing modes\n\n        :param fd: file descriptor\n        :param bytes: bytes block to write\n        :return:\n\n        :note: don\'t overkill the node with large byte chunks, also for large file upload check the upload method.\n        """\n        args = {\n            \'fd\': fd,\n            \'block\': base64.encodebytes(bytes).decode(),\n        }\n\n        return self._client.json(\'filesystem.write\', args)\n\n    def close(self, fd):\n        """\n        Close file\n        :param fd: file descriptor\n        :return:\n        """\n        args = {\n            \'fd\': fd,\n        }\n\n        return self._client.json(\'filesystem.close\', args)\n\n    def upload(self, remote, reader):\n        """\n        Uploads a file\n        :param remote: remote file name\n        :param reader: an object that implements the read(size) method (typically a file descriptor)\n        :return:\n        """\n\n        fd = self.open(remote, \'w\')\n        while True:\n            chunk = reader.read(512 * 1024)\n            if chunk == b\'\':\n                break\n            self.write(fd, chunk)\n        self.close(fd)\n\n    def download(self, remote, writer):\n        """\n        Downloads a file\n        :param remote: remote file name\n        :param writer: an object the implements the write(bytes) interface (typical a file descriptor)\n        :return:\n        """\n\n        fd = self.open(remote)\n        while True:\n            chunk = self.read(fd)\n            if chunk == b\'\':\n                break\n            writer.write(chunk)\n        self.close(fd)\n\n    def upload_file(self, remote, local):\n        """\n        Uploads a file\n        :param remote: remote file name\n        :param local: local file name\n        :return:\n        """\n        file = open(local, \'rb\')\n        self.upload(remote, file)\n\n    def download_file(self, remote, local):\n        """\n        Downloads a file\n        :param remote: remote file name\n        :param local: local file name\n        :return:\n        """\n        file = open(local, \'wb\')\n        self.download(remote, file)\n'
u'11,class BaseClient:\n    _system_chk = typchk.Checker({\n        \'name\': str,\n        \'args\': [str],\n        \'dir\': str,\n        \'stdin\': str,\n        \'env\': typchk.Or(typchk.Map(str, str), typchk.IsNone()),\n    })\n\n    _bash_chk = typchk.Checker({\n        \'stdin\': str,\n        \'script\': str,\n    })\n\n    def __init__(self, timeout=None):\n        if timeout is None:\n            self.timeout = DefaultTimeout\n        else:\n            self.timeout = timeout\n        self._info = InfoManager(self)\n        self._job = JobManager(self)\n        self._process = ProcessManager(self)\n        self._filesystem = FilesystemManager(self)\n        self._ip = IPManager(self)\n\n    @property\n    def info(self):\n        """\n        info manager\n        :return:\n        """\n        return self._info\n\n    @property\n    def job(self):\n        """\n        job manager\n        :return:\n        """\n        return self._job\n\n    @property\n    def process(self):\n        """\n        process manager\n        :return:\n        """\n        return self._process\n\n    @property\n    def filesystem(self):\n        """\n        filesystem manager\n        :return:\n        """\n        return self._filesystem\n\n    @property\n    def ip(self):\n        """\n        ip manager\n        :return:\n        """\n        return self._ip\n\n    def raw(self, command, arguments, queue=None, max_time=None, stream=False):\n        """\n        Implements the low level command call, this needs to build the command structure\n        and push it on the correct queue.\n\n        :param command: Command name to execute supported by the node (ex: core.system, info.cpu, etc...)\n                        check documentation for list of built in commands\n        :param arguments: A dict of required command arguments depends on the command name.\n        :param queue: command queue (commands on the same queue are executed sequentially)\n        :param max_time: kill job server side if it exceeded this amount of seconds\n        :param stream: If True, process stdout and stderr are pushed to a special queue (stream:<id>) so\n            client can stream output\n        :return: Response object\n        """\n        raise NotImplemented()\n\n    def sync(self, command, arguments):\n        """\n        Same as self.raw except it do a response.get() waiting for the command execution to finish and reads the result\n\n        :return: Result object\n        """\n        response = self.raw(command, arguments)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'invalid response: %s\' % result.state, result)\n\n        return result\n\n    def json(self, command, arguments):\n        """\n        Same as self.sync except it assumes the returned result is json, and loads the payload of the return object\n        if the returned (data) is not of level (20) an error is raised.\n        :Return: Data\n        """\n        result = self.sync(command, arguments)\n        if result.level != 20:\n            raise RuntimeError(\'invalid result level, expecting json(20) got (%d)\' % result.level)\n\n        return json.loads(result.data)\n\n    def ping(self):\n        """\n        Ping a node, checking for it\'s availability. a Ping should never fail unless the node is not reachable\n        or not responsive.\n        :return:\n        """\n        response = self.raw(\'core.ping\', {})\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'invalid response: %s\' % result.state)\n\n        return json.loads(result.data)\n\n    def system(self, command, dir=\'\', stdin=\'\', env=None, queue=None, max_time=None, stream=False):\n        """\n        Execute a command\n\n        :param command:  command to execute (with its arguments) ex: `ls -l /root`\n        :param dir: CWD of command\n        :param stdin: Stdin data to feed to the command stdin\n        :param env: dict with ENV variables that will be exported to the command\n        :return:\n        """\n        parts = shlex.split(command)\n        if len(parts) == 0:\n            raise ValueError(\'invalid command\')\n\n        args = {\n            \'name\': parts[0],\n            \'args\': parts[1:],\n            \'dir\': dir,\n            \'stdin\': stdin,\n            \'env\': env,\n        }\n\n        self._system_chk.check(args)\n        response = self.raw(command=\'core.system\', arguments=args,\n                            queue=queue, max_time=max_time, stream=stream)\n\n        return response\n\n    def bash(self, script, stdin=\'\', queue=None, max_time=None, stream=False):\n        """\n        Execute a bash script, or run a process inside a bash shell.\n\n        :param script: Script to execute (can be multiline script)\n        :param stdin: Stdin data to feed to the script\n        :return:\n        """\n        args = {\n            \'script\': script,\n            \'stdin\': stdin,\n        }\n        self._bash_chk.check(args)\n        response = self.raw(command=\'bash\', arguments=args,\n                            queue=queue, max_time=max_time, stream=stream)\n\n        return response\n'
u'12,class ContainerClient(BaseClient):\n    class ContainerZerotierManager:\n        def __init__(self, client, container):\n            self._container = container\n            self._client = client\n\n        def info(self):\n            return self._client.json(\'corex.zerotier.info\', {\'container\': self._container})\n\n        def list(self):\n            return self._client.json(\'corex.zerotier.list\', {\'container\': self._container})\n\n    _raw_chk = typchk.Checker({\n        \'container\': int,\n        \'command\': {\n            \'command\': str,\n            \'arguments\': typchk.Any(),\n            \'queue\': typchk.Or(str, typchk.IsNone()),\n            \'max_time\': typchk.Or(int, typchk.IsNone()),\n            \'stream\': bool\n        }\n    })\n\n    def __init__(self, client, container):\n        super().__init__(client.timeout)\n\n        self._client = client\n        self._container = container\n        self._zerotier = ContainerClient.ContainerZerotierManager(client, container)  # not (self) we use core0 client\n\n    @property\n    def container(self):\n        """\n        :return: container id\n        """\n        return self._container\n\n    @property\n    def zerotier(self):\n        """\n        information about zerotier id\n        :return:\n        """\n        return self._zerotier\n\n    def raw(self, command, arguments, queue=None, max_time=None, stream=False):\n        """\n        Implements the low level command call, this needs to build the command structure\n        and push it on the correct queue.\n\n        :param command: Command name to execute supported by the node (ex: core.system, info.cpu, etc...)\n                        check documentation for list of built in commands\n        :param arguments: A dict of required command arguments depends on the command name.\n        :param queue: command queue (commands on the same queue are executed sequentially)\n        :param max_time: kill job server side if it exceeded this amount of seconds\n        :param stream: If True, process stdout and stderr are pushed to a special queue (stream:<id>) so\n            client can stream output\n        :return: Response object\n        """\n        args = {\n            \'container\': self._container,\n            \'command\': {\n                \'command\': command,\n                \'arguments\': arguments,\n                \'queue\': queue,\n                \'max_time\': max_time,\n                \'stream\': stream,\n            },\n        }\n\n        # check input\n        self._raw_chk.check(args)\n\n        response = self._client.raw(\'corex.dispatch\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to dispatch command to container: %s\' % result.data)\n\n        cmd_id = json.loads(result.data)\n        return self._client.response_for(cmd_id)\n'
u'13,class ContainerManager:\n    _create_chk = typchk.Checker({\n        \'root\': str,\n        \'mount\': typchk.Or(\n            typchk.Map(str, str),\n            typchk.IsNone()\n        ),\n        \'host_network\': bool,\n        \'nics\': [{\n            \'type\': typchk.Enum(\'default\', \'bridge\', \'zerotier\', \'vlan\', \'vxlan\'),\n            \'id\': typchk.Or(str, typchk.Missing()),\n            \'name\': typchk.Or(str, typchk.Missing()),\n            \'hwaddr\': typchk.Or(str, typchk.Missing()),\n            \'config\': typchk.Or(\n                typchk.Missing(),\n                {\n                    \'dhcp\': typchk.Or(bool, typchk.Missing()),\n                    \'cidr\': typchk.Or(str, typchk.Missing()),\n                    \'gateway\': typchk.Or(str, typchk.Missing()),\n                    \'dns\': typchk.Or([str], typchk.Missing()),\n                }\n            )\n        }],\n        \'port\': typchk.Or(\n            typchk.Map(int, int),\n            typchk.IsNone()\n        ),\n        \'privileged\': bool,\n        \'hostname\': typchk.Or(\n            str,\n            typchk.IsNone()\n        ),\n        \'storage\': typchk.Or(str, typchk.IsNone()),\n        \'tags\': typchk.Or([str], typchk.IsNone())\n    })\n\n    _client_chk = typchk.Checker(\n        typchk.Or(int, str)\n    )\n\n    DefaultNetworking = object()\n\n    class ContainerResponse(Response):\n        def get(self, timeout=None):\n            """\n            Get container ID\n            :param timeout: client side timeout in seconds (for the container ID to return)\n            :return: int\n            """\n            result = super().get(timeout)\n            if result.state != \'SUCCESS\':\n                raise Exception(\'failed to create container: %s\' % result.data)\n\n            return json.loads(result.data)\n\n    def __init__(self, client):\n        self._client = client\n\n    def create(self, root_url, mount=None, host_network=False, nics=DefaultNetworking, port=None, hostname=None, privileged=False, storage=None, tags=None):\n        """\n        Creater a new container with the given root flist, mount points and\n        zerotier id, and connected to the given bridges\n        :param root_url: The root filesystem flist\n        :param mount: a dict with {host_source: container_target} mount points.\n                      where host_source directory must exists.\n                      host_source can be a url to a flist to mount.\n        :param host_network: Specify if the container should share the same network stack as the host.\n                             if True, container creation ignores both zerotier, bridge and ports arguments below. Not\n                             giving errors if provided.\n        :param nics: Configure the attached nics to the container\n                     each nic object is a dict of the format\n                     {\n                        \'type\': nic_type # default, bridge, zerotier, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n                        \'id\': id # depends on the type, bridge name, zerotier network id, the vlan tag or the vxlan id\n                        \'name\': name of the nic inside the container (ignored in zerotier type)\n                        \'hwaddr\': Mac address of nic.\n                        \'config\': { # config is only honored for bridge, vlan, and vxlan types\n                            \'dhcp\': bool,\n                            \'cidr\': static_ip # ip/mask\n                            \'gateway\': gateway\n                            \'dns\': [dns]\n                        }\n                     }\n        :param port: A dict of host_port: container_port pairs (only if default networking is enabled)\n                       Example:\n                        `port={8080: 80, 7000:7000}`\n        :param hostname: Specific hostname you want to give to the container.\n                         if None it will automatically be set to core-x,\n                         x beeing the ID of the container\n        :param privileged: If true, container runs in privileged mode.\n        :param storage: A Url to the ardb storage to use to mount the root flist (or any other mount that requires g8fs)\n                        if not provided, the default one from core0 configuration will be used.\n        """\n\n        if nics == self.DefaultNetworking:\n            nics = [{\'type\': \'default\'}]\n        elif nics is None:\n            nics = []\n\n        args = {\n            \'root\': root_url,\n            \'mount\': mount,\n            \'host_network\': host_network,\n            \'nics\': nics,\n            \'port\': port,\n            \'hostname\': hostname,\n            \'privileged\': privileged,\n            \'storage\': storage,\n            \'tags\': tags,\n        }\n\n        # validate input\n        self._create_chk.check(args)\n\n        response = self._client.raw(\'corex.create\', args)\n\n        return self.ContainerResponse(self._client, response.id)\n\n    def list(self):\n        """\n        List running containers\n        :return: a dict with {container_id: <container info object>}\n        """\n        return self._client.json(\'corex.list\', {})\n\n    def find(self, *tags):\n        """\n        Find containers that matches set of tags\n        :param tags:\n        :return:\n        """\n        tags = list(map(str, tags))\n        return self._client.json(\'corex.find\', {\'tags\': tags})\n\n    def terminate(self, container):\n        """\n        Terminate a container given it\'s id\n\n        :param container: container id\n        :return:\n        """\n        self._client_chk.check(container)\n        args = {\n            \'container\': int(container),\n        }\n        response = self._client.raw(\'corex.terminate\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to terminate container: %s\' % result.data)\n\n    def client(self, container):\n        """\n        Return a client instance that is bound to that container.\n\n        :param container: container id\n        :return: Client object bound to the specified container id\n        Return a ContainerResponse from container.create\n        """\n\n        self._client_chk.check(container)\n        return ContainerClient(self._client, int(container))\n'
u'14,class IPManager:\n    class IPBridgeManager:\n        def __init__(self, client):\n            self._client = client\n\n        def add(self, name, hwaddr=None):\n            """\n            Add bridge with given name and optional hardware address\n\n            For more advanced bridge options please check the `bridge` manager.\n            :param name: bridge name\n            :param hwaddr: mac address (str)\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'hwaddr\': hwaddr,\n            }\n\n            return self._client.json("ip.bridge.add", args)\n\n        def delete(self, name):\n            """\n            Delete bridge with given name\n            :param name: bridge name to delete\n            :return:\n            """\n            args = {\n                \'name\': name,\n            }\n\n            return self._client.json("ip.bridge.del", args)\n\n        def addif(self, name, inf):\n            """\n            Add interface to bridge\n            :param name: bridge name\n            :param inf: interface name to add\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'inf\': inf,\n            }\n\n            return self._client.json(\'ip.bridge.addif\', args)\n\n        def delif(self, name, inf):\n            """\n            Delete interface from bridge\n            :param name: bridge name\n            :param inf: interface to remove\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'inf\': inf,\n            }\n\n            return self._client.json(\'ip.bridge.delif\', args)\n\n    class IPLinkManager:\n        def __init__(self, client):\n            self._client = client\n\n        def up(self, link):\n            """\n            Set interface state to UP\n\n            :param link: link/interface name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.link.up\', args)\n\n        def down(self, link):\n            """\n            Set link/interface state to DOWN\n\n            :param link: link/interface name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.link.down\', args)\n\n        def name(self, link, name):\n            """\n            Rename link\n\n            :param link: link to rename\n            :param name: new name\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'new\': name,\n            }\n            return self._client.json(\'ip.link.name\', args)\n\n        def list(self):\n            return self._client.json(\'ip.link.list\', {})\n\n    class IPAddrManager:\n        def __init__(self, client):\n            self._client = client\n\n        def add(self, link, ip):\n            """\n            Add IP to link\n\n            :param link: link\n            :param ip: ip address to add\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'ip\': ip,\n            }\n            return self._client.json(\'ip.addr.add\', args)\n\n        def delete(self, link, ip):\n            """\n            Delete IP from link\n\n            :param link: link\n            :param ip: ip address to remove\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'ip\': ip,\n            }\n            return self._client.json(\'ip.addr.del\', args)\n\n        def list(self, link):\n            """\n            List IPs of a link\n\n            :param link: link name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.addr.list\', args)\n\n    class IPRouteManager:\n        def __init__(self, client):\n            self._client = client\n\n        def add(self, dev, dst, gw=None):\n            """\n            Add a route\n\n            :param dev: device name\n            :param dst: destination network\n            :param gw: optional gateway\n            :return:\n            """\n            args = {\n                \'dev\': dev,\n                \'dst\': dst,\n                \'gw\': gw,\n            }\n            return self._client.json(\'ip.route.add\', args)\n\n        def delete(self, dev, dst, gw=None):\n            """\n            Delete a route\n\n            :param dev: device name\n            :param dst: destination network\n            :param gw: optional gateway\n            :return:\n            """\n            args = {\n                \'dev\': dev,\n                \'dst\': dst,\n                \'gw\': gw,\n            }\n            return self._client.json(\'ip.route.del\', args)\n\n        def list(self):\n            return self._client.json(\'ip.route.list\', {})\n\n    def __init__(self, client):\n        self._client = client\n        self._bridge = IPManager.IPBridgeManager(client)\n        self._link = IPManager.IPLinkManager(client)\n        self._addr = IPManager.IPAddrManager(client)\n        self._route = IPManager.IPRouteManager(client)\n\n    @property\n    def bridge(self):\n        """\n        Bridge manager\n        :return:\n        """\n        return self._bridge\n\n    @property\n    def link(self):\n        """\n        Link manager\n        :return:\n        """\n        return self._link\n\n    @property\n    def addr(self):\n        """\n        Address manager\n        :return:\n        """\n        return self._addr\n\n    @property\n    def route(self):\n        """\n        Route manager\n        :return:\n        """\n        return self._route\n'
u'15,class BridgeManager:\n    _bridge_create_chk = typchk.Checker({\n        \'name\': str,\n        \'hwaddr\': typchk.Or(str, typchk.IsNone()),\n        \'network\': {\n            \'mode\': typchk.Or(typchk.Enum(\'static\', \'dnsmasq\'), typchk.IsNone()),\n            \'nat\': bool,\n            \'settings\': typchk.Map(str, str),\n        }\n    })\n\n    _bridge_delete_chk = typchk.Checker({\n        \'name\': str,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def create(self, name, hwaddr=None, network=None, nat=False, settings={}):\n        """\n        Create a bridge with the given name, hwaddr and networking setup\n        :param name: name of the bridge (must be unique), 15 characters or less, and not equal to "default".\n        :param hwaddr: MAC address of the bridge. If none, a one will be created for u\n        :param network: Networking mode, options are none, static, and dnsmasq\n        :param nat: If true, SNAT will be enabled on this bridge. (IF and ONLY IF an IP is set on the bridge\n                    via the settings, otherwise flag will be ignored) (the cidr attribute of either static, or dnsmasq modes)\n        :param settings: Networking setting, depending on the selected mode.\n                        none:\n                            no settings, bridge won\'t get any ip settings\n                        static:\n                            settings={\'cidr\': \'ip/net\'}\n                            bridge will get assigned the given IP address\n                        dnsmasq:\n                            settings={\'cidr\': \'ip/net\', \'start\': \'ip\', \'end\': \'ip\'}\n                            bridge will get assigned the ip in cidr\n                            and each running container that is attached to this IP will get\n                            IP from the start/end range. Netmask of the range is the netmask\n                            part of the provided cidr.\n                            if nat is true, SNAT rules will be automatically added in the firewall.\n        """\n        args = {\n            \'name\': name,\n            \'hwaddr\': hwaddr,\n            \'network\': {\n                \'mode\': network,\n                \'nat\': nat,\n                \'settings\': settings,\n            }\n        }\n\n        self._bridge_create_chk.check(args)\n\n        response = self._client.raw(\'bridge.create\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to create bridge %s\' % result.data)\n\n        return json.loads(result.data)\n\n    def list(self):\n        """\n        List all available bridges\n        :return: list of bridge names\n        """\n        response = self._client.raw(\'bridge.list\', {})\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to list bridges: %s\' % result.data)\n\n        return json.loads(result.data)\n\n    def delete(self, bridge):\n        """\n        Delete a bridge by name\n\n        :param bridge: bridge name\n        :return:\n        """\n        args = {\n            \'name\': bridge,\n        }\n\n        self._bridge_delete_chk.check(args)\n\n        response = self._client.raw(\'bridge.delete\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to list delete: %s\' % result.data)\n'
u'16,class DiskManager:\n    _mktable_chk = typchk.Checker({\n        \'disk\': str,\n        \'table_type\': typchk.Enum(\'aix\', \'amiga\', \'bsd\', \'dvh\', \'gpt\', \'mac\', \'msdos\', \'pc98\', \'sun\', \'loop\')\n    })\n\n    _mkpart_chk = typchk.Checker({\n        \'disk\': str,\n        \'start\': typchk.Or(int, str),\n        \'end\': typchk.Or(int, str),\n        \'part_type\': typchk.Enum(\'primary\', \'logical\', \'extended\'),\n    })\n\n    _getpart_chk = typchk.Checker({\n        \'disk\': str,\n        \'part\': str,\n    })\n\n    _rmpart_chk = typchk.Checker({\n        \'disk\': str,\n        \'number\': int,\n    })\n\n    _mount_chk = typchk.Checker({\n        \'options\': str,\n        \'source\': str,\n        \'target\': str,\n    })\n\n    _umount_chk = typchk.Checker({\n        \'source\': str,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def list(self):\n        """\n        List available block devices\n        """\n        response = self._client.raw(\'disk.list\', {})\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to list disks: %s\' % result.stderr)\n\n        if result.level != 20:  # 20 is JSON output.\n            raise RuntimeError(\'invalid response type from disk.list command\')\n\n        data = result.data.strip()\n        if data:\n            return json.loads(data)\n        else:\n            return {}\n\n    def mktable(self, disk, table_type=\'gpt\'):\n        """\n        Make partition table on block device.\n        :param disk: device name (sda, sdb, etc...)\n        :param table_type: Partition table type as accepted by parted\n        """\n        args = {\n            \'disk\': disk,\n            \'table_type\': table_type,\n        }\n\n        self._mktable_chk.check(args)\n\n        response = self._client.raw(\'disk.mktable\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to create table: %s\' % result.stderr)\n\n    def getinfo(self, disk, part=\'\'):\n        """\n        Get more info about a disk or a disk partition\n\n        :param disk: (sda, sdb, etc..)\n        :param part: (sda1, sdb2, etc...)\n        :return: a dict with {"blocksize", "start", "size", and "free" sections}\n        """\n        args = {\n            "disk": disk,\n            "part": part,\n        }\n\n        self._getpart_chk.check(args)\n\n        response = self._client.raw(\'disk.getinfo\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to get info: %s\' % result.data)\n\n        if result.level != 20:  # 20 is JSON output.\n            raise RuntimeError(\'invalid response type from disk.getinfo command\')\n\n        data = result.data.strip()\n        if data:\n            return json.loads(data)\n        else:\n            return {}\n\n    def mkpart(self, disk, start, end, part_type=\'primary\'):\n        """\n        Make partition on disk\n        :param disk: device name (sda, sdb, etc...)\n        :param start: partition start as accepted by parted mkpart\n        :param end: partition end as accepted by parted mkpart\n        :param part_type: partition type as accepted by parted mkpart\n        """\n        args = {\n            \'disk\': disk,\n            \'start\': start,\n            \'end\': end,\n            \'part_type\': part_type,\n        }\n\n        self._mkpart_chk.check(args)\n\n        response = self._client.raw(\'disk.mkpart\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to create partition: %s\' % result.stderr)\n\n    def rmpart(self, disk, number):\n        """\n        Remove partion from disk\n        :param disk: device name (sda, sdb, etc...)\n        :param number: Partition number (starting from 1)\n        """\n        args = {\n            \'disk\': disk,\n            \'number\': number,\n        }\n\n        self._rmpart_chk.check(args)\n\n        response = self._client.raw(\'disk.rmpart\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to remove partition: %s\' % result.stderr)\n\n    def mount(self, source, target, options=[]):\n        """\n        Mount partion on target\n        :param source: Full partition path like /dev/sda1\n        :param target: Mount point\n        :param options: Optional mount options\n        """\n\n        if len(options) == 0:\n            options = [\'\']\n\n        args = {\n            \'options\': \',\'.join(options),\n            \'source\': source,\n            \'target\': target,\n        }\n\n        self._mount_chk.check(args)\n        response = self._client.raw(\'disk.mount\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to mount partition: %s\' % result.stderr)\n\n    def umount(self, source):\n        """\n        Unmount partion\n        :param source: Full partition path like /dev/sda1\n        """\n\n        args = {\n            \'source\': source,\n        }\n        self._umount_chk.check(args)\n\n        response = self._client.raw(\'disk.umount\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to umount partition: %s\' % result.stderr)\n'
u'17,class BtrfsManager:\n    _create_chk = typchk.Checker({\n        \'label\': str,\n        \'metadata\': typchk.Enum("raid0", "raid1", "raid5", "raid6", "raid10", "dup", "single", ""),\n        \'data\': typchk.Enum("raid0", "raid1", "raid5", "raid6", "raid10", "dup", "single", ""),\n        \'devices\': typchk.Length([str], 1),\n        \'overwrite\': bool,\n    })\n\n    _device_chk = typchk.Checker({\n        \'mountpoint\': str,\n        \'devices\': typchk.Length((str,), 1),\n    })\n\n    _subvol_chk = typchk.Checker({\n        \'path\': str,\n    })\n\n    _subvol_quota_chk = typchk.Checker({\n        \'path\': str,\n        \'limit\': str,\n    })\n\n    _subvol_snapshot_chk = typchk.Checker({\n        \'source\': str,\n        \'destination\': str,\n        \'read_only\': bool,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def list(self):\n        """\n        List all btrfs filesystem\n        """\n        return self._client.json(\'btrfs.list\', {})\n\n    def info(self, mountpoint):\n        """\n        Get btrfs fs info\n        """\n        return self._client.json(\'btrfs.info\', {\'mountpoint\': mountpoint})\n\n    def create(self, label, devices, metadata_profile="", data_profile="", overwrite=False):\n        """\n        Create a btrfs filesystem with the given label, devices, and profiles\n        :param label: name/label\n        :param devices : array of devices (/dev/sda1, etc...)\n        :metadata_profile: raid0, raid1, raid5, raid6, raid10, dup or single\n        :data_profile: same as metadata profile\n        :overwrite: force creation of the filesystem. Overwrite any existing filesystem\n        """\n        args = {\n            \'label\': label,\n            \'metadata\': metadata_profile,\n            \'data\': data_profile,\n            \'devices\': devices,\n            \'overwrite\': overwrite\n        }\n\n        self._create_chk.check(args)\n\n        self._client.sync(\'btrfs.create\', args)\n\n    def device_add(self, mountpoint, *device):\n        """\n        Add one or more devices to btrfs filesystem mounted under `mountpoint`\n\n        :param mountpoint: mount point of the btrfs system\n        :param devices: one ore more devices to add\n        :return:\n        """\n        if len(device) == 0:\n            return\n\n        args = {\n            \'mountpoint\': mountpoint,\n            \'devices\': device,\n        }\n\n        self._device_chk.check(args)\n\n        self._client.sync(\'btrfs.device_add\', args)\n\n    def device_remove(self, mountpoint, *device):\n        """\n        Remove one or more devices from btrfs filesystem mounted under `mountpoint`\n\n        :param mountpoint: mount point of the btrfs system\n        :param devices: one ore more devices to remove\n        :return:\n        """\n        if len(device) == 0:\n            return\n\n        args = {\n            \'mountpoint\': mountpoint,\n            \'devices\': device,\n        }\n\n        self._device_chk.check(args)\n\n        self._client.sync(\'btrfs.device_remove\', args)\n\n    def subvol_create(self, path):\n        """\n        Create a btrfs subvolume in the specified path\n        :param path: path to create\n        """\n        args = {\n            \'path\': path\n        }\n        self._subvol_chk.check(args)\n        self._client.sync(\'btrfs.subvol_create\', args)\n\n    def subvol_list(self, path):\n        """\n        List a btrfs subvolume in the specified path\n        :param path: path to be listed\n        """\n        return self._client.json(\'btrfs.subvol_list\', {\n            \'path\': path\n        })\n\n    def subvol_delete(self, path):\n        """\n        Delete a btrfs subvolume in the specified path\n        :param path: path to delete\n        """\n        args = {\n            \'path\': path\n        }\n\n        self._subvol_chk.check(args)\n\n        self._client.sync(\'btrfs.subvol_delete\', args)\n\n    def subvol_quota(self, path, limit):\n        """\n        Apply a quota to a btrfs subvolume in the specified path\n        :param path:  path to apply the quota for (it has to be the path of the subvol)\n        :param limit: the limit to Apply\n        """\n        args = {\n            \'path\': path,\n            \'limit\': limit,\n        }\n\n        self._subvol_quota_chk.check(args)\n\n        self._client.sync(\'btrfs.subvol_quota\', args)\n\n    def subvol_snapshot(self, source, destination, read_only=False):\n        """\n        Take a snapshot\n\n        :param source: source path of subvol\n        :param destination: destination path of snapshot\n        :param read_only: Set read-only on the snapshot\n        :return:\n        """\n\n        args = {\n            "source": source,\n            "destination": destination,\n            "read_only": read_only,\n        }\n\n        self._subvol_snapshot_chk.check(args)\n        self._client.sync(\'btrfs.subvol_snapshot\', args)\n'
u'18,class ZerotierManager:\n    _network_chk = typchk.Checker({\n        \'network\': str,\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def join(self, network):\n        """\n        Join a zerotier network\n\n        :param network: network id to join\n        :return:\n        """\n        args = {\'network\': network}\n        self._network_chk.check(args)\n        response = self._client.raw(\'zerotier.join\', args)\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to join zerotier network: %s\', result.stderr)\n\n    def leave(self, network):\n        """\n        Leave a zerotier network\n\n        :param network: network id to leave\n        :return:\n        """\n        args = {\'network\': network}\n        self._network_chk.check(args)\n        response = self._client.raw(\'zerotier.leave\', args)\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to leave zerotier network: %s\', result.stderr)\n\n    def list(self):\n        """\n        List joined zerotier networks\n\n        :return: list of joined networks with their info\n        """\n        return self._client.json(\'zerotier.list\', {})\n\n    def info(self):\n        """\n        Display zerotier status info\n\n        :return: dict of zerotier statusinfo\n        """\n        return self._client.json(\'zerotier.info\', {})\n'
u'19,class KvmManager:\n    _iotune_dict = {\n        \'totalbytessecset\': typchk.Or(bool, typchk.Missing()),\n        \'totalbytessec\': typchk.Or(int, typchk.Missing()),\n        \'readbytessecset\': typchk.Or(bool, typchk.Missing()),\n        \'readbytessec\': typchk.Or(int, typchk.Missing()),\n        \'writebytessecset\': typchk.Or(bool, typchk.Missing()),\n        \'writebytessec\': typchk.Or(int, typchk.Missing()),\n        \'totaliopssecset\': typchk.Or(bool, typchk.Missing()),\n        \'totaliopssec\': typchk.Or(int, typchk.Missing()),\n        \'readiopssecset\': typchk.Or(bool, typchk.Missing()),\n        \'readiopssec\': typchk.Or(int, typchk.Missing()),\n        \'writeiopssecset\': typchk.Or(bool, typchk.Missing()),\n        \'writeiopssec\': typchk.Or(int, typchk.Missing()),\n        \'totalbytessecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'totalbytessecmax\': typchk.Or(int, typchk.Missing()),\n        \'readbytessecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'readbytessecmax\': typchk.Or(int, typchk.Missing()),\n        \'writebytessecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'writebytessecmax\': typchk.Or(int, typchk.Missing()),\n        \'totaliopssecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'totaliopssecmax\': typchk.Or(int, typchk.Missing()),\n        \'readiopssecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'readiopssecmax\': typchk.Or(int, typchk.Missing()),\n        \'writeiopssecmaxset\': typchk.Or(bool, typchk.Missing()),\n        \'writeiopssecmax\': typchk.Or(int, typchk.Missing()),\n        \'totalbytessecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'totalbytessecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'readbytessecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'readbytessecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'writebytessecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'writebytessecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'totaliopssecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'totaliopssecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'readiopssecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'readiopssecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'writeiopssecmaxlengthset\': typchk.Or(bool, typchk.Missing()),\n        \'writeiopssecmaxlength\': typchk.Or(int, typchk.Missing()),\n        \'sizeiopssecset\': typchk.Or(bool, typchk.Missing()),\n        \'sizeiopssec\': typchk.Or(int, typchk.Missing()),\n        \'groupnameset\': typchk.Or(bool, typchk.Missing()),\n        \'groupname\': typchk.Or(str, typchk.Missing()),\n    }\n    _media_dict = {\n        \'type\': typchk.Or(\n            typchk.Enum(\'disk\', \'cdrom\'),\n            typchk.Missing()\n        ),\n        \'url\': str,\n        \'iotune\': typchk.Or(\n            _iotune_dict,\n            typchk.Missing()\n        )\n    }\n    _create_chk = typchk.Checker({\n        \'name\': str,\n        \'media\': typchk.Length([_media_dict], 1),\n        \'cpu\': int,\n        \'memory\': int,\n        \'nics\': [{\n            \'type\': typchk.Enum(\'default\', \'bridge\', \'vxlan\', \'vlan\'),\n            \'id\': typchk.Or(str, typchk.Missing()),\n            \'hwaddr\': typchk.Or(str, typchk.Missing()),\n        }],\n        \'port\': typchk.Or(\n            typchk.Map(int, int),\n            typchk.IsNone()\n        ),\n    })\n\n    _domain_action_chk = typchk.Checker({\n        \'uuid\': str,\n    })\n\n    _man_disk_action_chk = typchk.Checker({\n        \'uuid\': str,\n        \'media\': _media_dict,\n    })\n\n    _man_nic_action_chk = typchk.Checker({\n        \'uuid\': str,\n        \'type\': typchk.Enum(\'default\', \'bridge\', \'vxlan\', \'vlan\'),\n        \'id\': typchk.Or(str, typchk.Missing()),\n        \'hwaddr\': typchk.Or(str, typchk.Missing()),\n    })\n\n    _migrate_action_chk = typchk.Checker({\n        \'uuid\': str,\n        \'desturi\': str,\n    })\n\n    _limit_disk_io_dict = {\n        \'uuid\': str,\n        \'media\': _media_dict,\n    }\n\n    _limit_disk_io_dict.update(_iotune_dict)\n\n    _limit_disk_io_action_chk = typchk.Checker(_limit_disk_io_dict)\n\n    def __init__(self, client):\n        self._client = client\n\n    def create(self, name, media, cpu=2, memory=512, nics=None, port=None):\n        """\n        :param name: Name of the kvm domain\n        :param media: array of media objects to attach to the machine, where the first object is the boot device\n                      each media object is a dict of {url, type} where type can be one of \'disk\', or \'cdrom\', or empty (default to disk)\n                      example: [{\'url\': \'nbd+unix:///test?socket=/tmp/ndb.socket\'}, {\'type\': \'cdrom\': \'/somefile.iso\'}\n        :param cpu: number of vcpu cores\n        :param memory: memory in MiB\n        :param port: A dict of host_port: container_port pairs\n                       Example:\n                        `port={8080: 80, 7000:7000}`\n                     Only supported if default network is used\n        :param nics: Configure the attached nics to the container\n                     each nic object is a dict of the format\n                     {\n                        \'type\': nic_type # default, bridge, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n                        \'id\': id # depends on the type, bridge name (bridge type) zerotier network id (zertier type), the vlan tag or the vxlan id\n                     }\n        :return: uuid of the virtual machine\n        """\n\n        if nics is None:\n            nics = []\n\n        args = {\n            \'name\': name,\n            \'media\': media,\n            \'cpu\': cpu,\n            \'memory\': memory,\n            \'nics\': nics,\n            \'port\': port,\n        }\n        self._create_chk.check(args)\n\n        return self._client.sync(\'kvm.create\', args)\n\n    def destroy(self, uuid):\n        """\n        Destroy a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.destroy\', args)\n\n    def shutdown(self, uuid):\n        """\n        Shutdown a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.shutdown\', args)\n\n    def reboot(self, uuid):\n        """\n        Reboot a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.reboot\', args)\n\n    def reset(self, uuid):\n        """\n        Reset (Force reboot) a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.reset\', args)\n\n    def pause(self, uuid):\n        """\n        Pause a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.pause\', args)\n\n    def resume(self, uuid):\n        """\n        Resume a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.resume\', args)\n\n    def info(self, uuid):\n        """\n        Get info about a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        return self._client.json(\'kvm.info\', args)\n\n    def infops(self, uuid):\n        """\n        Get info per second about a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        return self._client.json(\'kvm.infops\', args)\n\n    def attach_disk(self, uuid, media):\n        """\n        Attach a disk to a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param media: the media object to attach to the machine\n                      media object is a dict of {url, and type} where type can be one of \'disk\', or \'cdrom\', or empty (default to disk)\n                      examples: {\'url\': \'nbd+unix:///test?socket=/tmp/ndb.socket\'}, {\'type\': \'cdrom\': \'/somefile.iso\'}\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'media\': media,\n        }\n        self._man_disk_action_chk.check(args)\n\n        self._client.sync(\'kvm.attach_disk\', args)\n\n    def detach_disk(self, uuid, media):\n        """\n        Detach a disk from a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param media: the media object to attach to the machine\n                      media object is a dict of {url, and type} where type can be one of \'disk\', or \'cdrom\', or empty (default to disk)\n                      examples: {\'url\': \'nbd+unix:///test?socket=/tmp/ndb.socket\'}, {\'type\': \'cdrom\': \'/somefile.iso\'}\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'media\': media,\n        }\n        self._man_disk_action_chk.check(args)\n\n        self._client.sync(\'kvm.detach_disk\', args)\n\n    def add_nic(self, uuid, type, id=None, hwaddr=None):\n        """\n        Add a nic to a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param type: nic_type # default, bridge, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n         param id: id # depends on the type, bridge name (bridge type) zerotier network id (zertier type), the vlan tag or the vxlan id\n         param hwaddr: the hardware address of the nic\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'type\': type,\n            \'id\': id,\n            \'hwaddr\': hwaddr,\n        }\n        self._man_nic_action_chk.check(args)\n\n        return self._client.json(\'kvm.add_nic\', args)\n\n    def remove_nic(self, uuid, type, id=None, hwaddr=None):\n        """\n        Remove a nic from a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param type: nic_type # default, bridge, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n         param id: id # depends on the type, bridge name (bridge type) zerotier network id (zertier type), the vlan tag or the vxlan id\n         param hwaddr: the hardware address of the nic\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'type\': type,\n            \'id\': id,\n            \'hwaddr\': hwaddr,\n        }\n        self._man_nic_action_chk.check(args)\n\n        return self._client.json(\'kvm.remove_nic\', args)\n\n    def limit_disk_io(self, uuid, media, totalbytessecset=False, totalbytessec=0, readbytessecset=False, readbytessec=0, writebytessecset=False,\n                      writebytessec=0, totaliopssecset=False, totaliopssec=0, readiopssecset=False, readiopssec=0, writeiopssecset=False, writeiopssec=0,\n                      totalbytessecmaxset=False, totalbytessecmax=0, readbytessecmaxset=False, readbytessecmax=0, writebytessecmaxset=False, writebytessecmax=0,\n                      totaliopssecmaxset=False, totaliopssecmax=0, readiopssecmaxset=False, readiopssecmax=0, writeiopssecmaxset=False, writeiopssecmax=0,\n                      totalbytessecmaxlengthset=False, totalbytessecmaxlength=0, readbytessecmaxlengthset=False, readbytessecmaxlength=0,\n                      writebytessecmaxlengthset=False, writebytessecmaxlength=0, totaliopssecmaxlengthset=False, totaliopssecmaxlength=0,\n                      readiopssecmaxlengthset=False, readiopssecmaxlength=0, writeiopssecmaxlengthset=False, writeiopssecmaxlength=0, sizeiopssecset=False,\n                      sizeiopssec=0, groupnameset=False, groupname=\'\'):\n        """\n        Remove a nic from a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param media: the media to limit the diskio\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'media\': media,\n            \'totalbytessecset\': totalbytessecset,\n            \'totalbytessec\': totalbytessec,\n            \'readbytessecset\': readbytessecset,\n            \'readbytessec\': readbytessec,\n            \'writebytessecset\': writebytessecset,\n            \'writebytessec\': writebytessec,\n            \'totaliopssecset\': totaliopssecset,\n            \'totaliopssec\': totaliopssec,\n            \'readiopssecset\': readiopssecset,\n            \'readiopssec\': readiopssec,\n            \'writeiopssecset\': writeiopssecset,\n            \'writeiopssec\': writeiopssec,\n            \'totalbytessecmaxset\': totalbytessecmaxset,\n            \'totalbytessecmax\': totalbytessecmax,\n            \'readbytessecmaxset\': readbytessecmaxset,\n            \'readbytessecmax\': readbytessecmax,\n            \'writebytessecmaxset\': writebytessecmaxset,\n            \'writebytessecmax\': writebytessecmax,\n            \'totaliopssecmaxset\': totaliopssecmaxset,\n            \'totaliopssecmax\': totaliopssecmax,\n            \'readiopssecmaxset\': readiopssecmaxset,\n            \'readiopssecmax\': readiopssecmax,\n            \'writeiopssecmaxset\': writeiopssecmaxset,\n            \'writeiopssecmax\': writeiopssecmax,\n            \'totalbytessecmaxlengthset\': totalbytessecmaxlengthset,\n            \'totalbytessecmaxlength\': totalbytessecmaxlength,\n            \'readbytessecmaxlengthset\': readbytessecmaxlengthset,\n            \'readbytessecmaxlength\': readbytessecmaxlength,\n            \'writebytessecmaxlengthset\': writebytessecmaxlengthset,\n            \'writebytessecmaxlength\': writebytessecmaxlength,\n            \'totaliopssecmaxlengthset\': totaliopssecmaxlengthset,\n            \'totaliopssecmaxlength\': totaliopssecmaxlength,\n            \'readiopssecmaxlengthset\': readiopssecmaxlengthset,\n            \'readiopssecmaxlength\': readiopssecmaxlength,\n            \'writeiopssecmaxlengthset\': writeiopssecmaxlengthset,\n            \'writeiopssecmaxlength\': writeiopssecmaxlength,\n            \'sizeiopssecset\': sizeiopssecset,\n            \'sizeiopssec\': sizeiopssec,\n            \'groupnameset\': groupnameset,\n            \'groupname\': groupname,\n        }\n        self._limit_disk_io_action_chk.check(args)\n\n        self._client.sync(\'kvm.limit_disk_io\', args)\n\n    def migrate(self, uuid, desturi):\n        """\n        Migrate a vm to another node\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param desturi: the uri of the destination node\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'desturi\': desturi,\n        }\n        self._migrate_action_chk.check(args)\n\n        self._client.sync(\'kvm.migrate\', args)\n\n    def list(self):\n        """\n        List configured domains\n\n        :return:\n        """\n        return self._client.json(\'kvm.list\', {})\n'
u'20,class Logger:\n    _level_chk = typchk.Checker({\n        \'level\': typchk.Enum("CRITICAL", "ERROR", "WARNING", "NOTICE", "INFO", "DEBUG"),\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def set_level(self, level):\n        """\n        Set the log level of the g8os\n        :param level: the level to be set can be one of ("CRITICAL", "ERROR", "WARNING", "NOTICE", "INFO", "DEBUG")\n        """\n        args = {\n            \'level\': level,\n        }\n        self._level_chk.check(args)\n\n        return self._client.json(\'logger.set_level\', args)\n\n    def reopen(self):\n        """\n        Reopen log file (rotate)\n        """\n        return self._client.json(\'logger.reopen\', {})\n'
u'21,class Nft:\n    _port_chk = typchk.Checker({\n        \'port\': int,\n        \'interface\': typchk.Or(str, typchk.IsNone()),\n        \'subnet\': typchk.Or(str, typchk.IsNone()),\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def open_port(self, port, interface=None, subnet=None):\n        """\n        open port\n        :param port: then port number\n        :param interface: an optional interface to open the port for\n        :param subnet: an optional subnet to open the port for\n        """\n        args = {\n            \'port\': port,\n            \'interface\': interface,\n            \'subnet\': subnet,\n        }\n        self._port_chk.check(args)\n\n        return self._client.json(\'nft.open_port\', args)\n\n    def drop_port(self, port, interface=None, subnet=None):\n        """\n        close an opened port (takes the same parameters passed in open)\n        :param port: then port number\n        :param interface: an optional interface to close the port for\n        :param subnet: an optional subnet to close the port for\n        """\n        args = {\n            \'port\': port,\n            \'interface\': interface,\n            \'subnet\': subnet,\n        }\n        self._port_chk.check(args)\n\n        return self._client.json(\'nft.drop_port\', args)\n\n    def list(self):\n        """\n        List open ports\n        """\n        return self._client.json(\'nft.list\', {})\n\n    def rule_exists(self, port, interface=None, subnet=None):\n        """\n        Check if a rule exists (takes the same parameters passed in open)\n        :param port: then port number\n        :param interface: an optional interface\n        :param subnet: an optional subnet\n        """\n        args = {\n            \'port\': port,\n            \'interface\': interface,\n            \'subnet\': subnet,\n        }\n        self._port_chk.check(args)\n\n        return self._client.json(\'nft.rule_exists\', args)\n'
u'22,class Config:\n\n    def __init__(self, client):\n        self._client = client\n\n    def get(self):\n        """\n        Get the config of g8os\n        """\n        return self._client.json(\'config.get\', {})\n'
u'23,class AggregatorManager:\n    _query_chk = typchk.Checker({\n        \'key\': typchk.Or(str, typchk.IsNone()),\n        \'tags\': typchk.Map(str, str),\n    })\n\n    def __init__(self, client):\n        self._client = client\n\n    def query(self, key=None, **tags):\n        """\n        Query zero-os aggregator for current state object of monitored metrics.\n        \n        Note: ID is returned as part of the key (if set) to avoid conflict with similar metrics that\n        has same key. For example, a cpu core nr can be the id associated with \'machine.CPU.percent\' \n        so we can return all values for all the core numbers in the same dict.\n        \n        U can filter on the ID as a tag\n        :example:\n            self.query(key=key, id=value)\n            \n        :param key: metric key (ex: machine.memory.ram.available) \n        :param tags: optional tags filter\n        :return: dict of {\n            \'key[/id]\': state object\n        }\n        """\n        args = {\n            \'key\': key,\n            \'tags\': tags,\n        }\n        self._query_chk.check(args)\n\n        return self._client.json(\'aggregator.query\', args)\n'
u'24,class Client(BaseClient):\n\n    def __init__(self, host, port=6379, password="", db=0, ssl=True, timeout=None, testConnectionAttempts=3):\n        super().__init__(timeout=timeout)\n\n        socket_timeout = (timeout + 5) if timeout else 15\n        socket_keepalive_options = dict()\n        if hasattr(socket, \'TCP_KEEPIDLE\'):\n            socket_keepalive_options[socket.TCP_KEEPIDLE] = 1\n        if hasattr(socket, \'TCP_KEEPINTVL\'):\n            socket_keepalive_options[socket.TCP_KEEPINTVL] = 1\n        if hasattr(socket, \'TCP_KEEPIDLE\'):\n            socket_keepalive_options[socket.TCP_KEEPIDLE] = 1\n        self._redis = redis.Redis(host=host, port=port, password=password, db=db, ssl=ssl,\n                                  socket_timeout=socket_timeout,\n                                  socket_keepalive=True, socket_keepalive_options=socket_keepalive_options)\n        self._container_manager = ContainerManager(self)\n        self._bridge_manager = BridgeManager(self)\n        self._disk_manager = DiskManager(self)\n        self._btrfs_manager = BtrfsManager(self)\n        self._zerotier = ZerotierManager(self)\n        self._kvm = KvmManager(self)\n        self._logger = Logger(self)\n        self._nft = Nft(self)\n        self._config = Config(self)\n        self._aggregator = AggregatorManager(self)\n\n        if testConnectionAttempts:\n            for _ in range(testConnectionAttempts):\n                try:\n                    self.ping()\n                except:\n                    pass\n                else:\n                    return\n            raise RuntimeError("Could not connect to remote host %s" % host)\n\n    @property\n    def container(self):\n        """\n        Container manager\n        :return:\n        """\n        return self._container_manager\n\n    @property\n    def bridge(self):\n        """\n        Bridge manager\n        :return:\n        """\n        return self._bridge_manager\n\n    @property\n    def disk(self):\n        """\n        Disk manager\n        :return:\n        """\n        return self._disk_manager\n\n    @property\n    def btrfs(self):\n        """\n        Btrfs manager\n        :return:\n        """\n        return self._btrfs_manager\n\n    @property\n    def zerotier(self):\n        """\n        Zerotier manager\n        :return:\n        """\n        return self._zerotier\n\n    @property\n    def kvm(self):\n        """\n        KVM manager\n        :return:\n        """\n        return self._kvm\n\n    @property\n    def logger(self):\n        """\n        Logger manager\n        :return:\n        """\n        return self._logger\n\n    @property\n    def nft(self):\n        """\n        NFT manager\n        :return:\n        """\n        return self._nft\n\n    @property\n    def config(self):\n        """\n        Config manager\n        :return:\n        """\n        return self._config\n\n    @property\n    def aggregator(self):\n        """\n        Aggregator manager\n        :return: \n        """\n        return self._aggregator\n\n    def raw(self, command, arguments, queue=None, max_time=None, stream=False):\n        """\n        Implements the low level command call, this needs to build the command structure\n        and push it on the correct queue.\n\n        :param command: Command name to execute supported by the node (ex: core.system, info.cpu, etc...)\n                        check documentation for list of built in commands\n        :param arguments: A dict of required command arguments depends on the command name.\n        :param queue: command queue (commands on the same queue are executed sequentially)\n        :param max_time: kill job server side if it exceeded this amount of seconds\n        :param stream: If True, process stdout and stderr are pushed to a special queue (stream:<id>) so\n            client can stream output\n        :return: Response object\n        """\n        id = str(uuid.uuid4())\n\n        payload = {\n            \'id\': id,\n            \'command\': command,\n            \'arguments\': arguments,\n            \'queue\': queue,\n            \'max_time\': max_time,\n            \'stream\': stream,\n        }\n\n        flag = \'result:{}:flag\'.format(id)\n        self._redis.rpush(\'core:default\', json.dumps(payload))\n        if self._redis.brpoplpush(flag, flag, DefaultTimeout) is None:\n            Timeout(\'failed to queue job {}\'.format(id))\n        logger.debug(\'%s >> g8core.%s(%s)\', id, command, \', \'.join(("%s=%s" % (k, v) for k, v in arguments.items())))\n\n        return Response(self, id)\n\n    def response_for(self, id):\n        return Response(self, id)\n'
u'25,    def __init__(self, payload):\n        self._payload = payload\n'
u'26,    @property\n    def payload(self):\n        """\n        Raw return object data\n        :return: dict\n        """\n        return self._payload\n'
u'27,    @property\n    def id(self):\n        """\n        Job ID\n        :return: string\n        """\n        return self._payload[\'id\']\n'
u'28,    @property\n    def data(self):\n        """\n        Data returned by the process. Only available if process\n        output data with the correct core level\n\n        For example, if a job returns a json object the self.level will be 20 and the data will contain the serialized\n        json object, other levels exists for yaml, toml, etc... it really depends on the running job\n        return: python primitive (str, number, dict or array)\n        """\n        return self._payload[\'data\']\n'
u'29,    @property\n    def level(self):\n        """\n        Data message level (if any)\n        """\n        return self._payload[\'level\']\n'
u'30,    @property\n    def starttime(self):\n        """\n        Starttime as a timestamp\n        """\n        return self._payload[\'starttime\'] / 1000\n'
u'31,    @property\n    def time(self):\n        """\n        Execution time in millisecond\n        """\n        return self._payload[\'time\']\n'
u'32,    @property\n    def state(self):\n        """\n        Exit state\n        :return: str one of [SUCCESS, ERROR, KILLED, TIMEOUT, UNKNOWN_CMD, DUPLICATE_ID]\n        """\n        return self._payload[\'state\']\n'
u'33,    @property\n    def stdout(self):\n        """\n        The job stdout\n        :return: string or None\n        """\n        streams = self._payload.get(\'streams\', None)\n        return streams[0] if streams is not None and len(streams) >= 1 else \'\'\n'
u'34,    @property\n    def stderr(self):\n        """\n        The job stderr\n        :return: string or None\n        """\n        streams = self._payload.get(\'streams\', None)\n        return streams[1] if streams is not None and len(streams) >= 2 else \'\'\n'
u'35,    def __repr__(self):\n        return str(self)\n'
u'36,    def __str__(self):\n        tmpl = """\\\n        STATE: {state}\n        STDOUT:\n        {stdout}\n        STDERR:\n        {stderr}\n        DATA:\n        {data}\n        """\n\n        return textwrap.dedent(tmpl).format(state=self.state, stdout=self.stdout, stderr=self.stderr, data=self.data)\n'
u"37,    def __init__(self, client, id):\n        self._client = client\n        self._id = id\n        self._queue = 'result:{}'.format(id)\n"
u'38,    @property\n    def id(self):\n        """\n        Job ID\n        :return: string\n        """\n        return self._id\n'
u'39,    @property\n    def exists(self):\n        """\n        Returns true if the job is still running or zero-os still knows about this job ID\n\n        After a job is finished, a job remains on zero-os for max of 5min where you still can read the job result\n        after the 5 min is gone, the job result is no more fetchable\n        :return: bool\n        """\n        r = self._client._redis\n        flag = \'{}:flag\'.format(self._queue)\n        return bool(r.execute_command(\'LKEYEXISTS\', flag))\n'
u'40,    @property\n    def running(self):\n        """\n        Returns true if job still in running state\n        :return:\n        """\n        r = self._client._redis\n        flag = \'{}:flag\'.format(self._queue)\n        if bool(r.execute_command(\'LKEYEXISTS\', flag)):\n            return r.execute_command(\'LTTL\', flag) == -1\n\n        return False\n'
u'41,    def stream(self, out=sys.stdout, err=sys.stderr):\n        """\n        Runtime copy of job stdout and stderr. This required the \'stream` flag to be set to True otherwise it will\n        not be able to copy any output, while it will block until the process exits.\n\n        :note: This function will block until it reaches end of stream or the process is no longer running.\n\n        :param out: Output stream\n        :param err: Error stream\n\n        :return: None\n        """\n        queue = \'stream:%s\' % self.id\n        r = self._client._redis\n\n        # we can terminate quickly by checking if the process is not running and it has no queued output.\n        if not self.running and r.llen(queue) == 0:\n            return\n\n        while True:\n            data = r.blpop(queue, 10)\n            if data is None:\n                if not self.running:\n                    break\n                continue\n            _, body = data\n            payload = json.loads(body.decode())\n            message = payload[\'message\']\n            line = message[\'message\']\n            meta = message[\'meta\']\n            if meta & 0x0006 != 0:\n                #eof flags are 0x2 (success) or 0x4 error\n                break\n            level = meta >> 16\n            w = out if level == 1 else err\n\n            if w is not None:\n                w.write(line)\n                w.write(\'\\n\')\n'
u'42,    def get(self, timeout=None):\n        """\n        Waits for a job to finish (max of given timeout seconds) and return job results. When a job exits get() will\n        keep returning the same result until zero-os doesn\'t remember the job anymore (self.exists == False)\n\n        :notes: the timeout here is a client side timeout, it\'s different than the timeout given to the job on start\n        (like in system method) witch will cause the job to be killed if it exceeded this timeout.\n\n        :param timeout: max time to wait for the job to finish in seconds\n        :return: Return object\n        """\n        if timeout is None:\n            timeout = self._client.timeout\n        r = self._client._redis\n        start = time.time()\n        maxwait = timeout\n        while maxwait > 0:\n            if not self.exists:\n                raise JobNotFound(self.id)\n            v = r.brpoplpush(self._queue, self._queue, 10)\n            if v is not None:\n                payload = json.loads(v.decode())\n                r = Return(payload)\n                logger.debug(\'%s << %s, stdout="%s", stderr="%s", data="%s"\',\n                             self._id, r.state, r.stdout, r.stderr, r.data[:1000])\n                return r\n            logger.debug(\'%s still waiting (%ss)\', self._id, int(time.time() - start))\n            maxwait -= 10\n        raise Timeout()\n'
u'43,    def __init__(self, client):\n        self._client = client\n'
u'44,    def cpu(self):\n        """\n        CPU information\n        :return:\n        """\n        return self._client.json(\'info.cpu\', {})\n'
u'45,    def nic(self):\n        """\n        Return (physical) network devices information including IPs\n        :return:\n        """\n        return self._client.json(\'info.nic\', {})\n'
u'46,    def mem(self):\n        """\n        Memory information\n        :return:\n        """\n        return self._client.json(\'info.mem\', {})\n'
u'47,    def disk(self):\n        """\n        Disk information\n        :return:\n        """\n        return self._client.json(\'info.disk\', {})\n'
u'48,    def os(self):\n        """\n        Operating system info\n        :return:\n        """\n        return self._client.json(\'info.os\', {})\n'
u'49,    def port(self):\n        """\n        Return information about open ports on the system (similar to netstat)\n        :return:\n        """\n        return self._client.json(\'info.port\', {})\n'
u'50,    def version(self):\n        """\n        Return OS version\n        :return:\n        """\n        return self._client.json(\'info.version\', {})\n'
u'51,    def __init__(self, client):\n        self._client = client\n'
u'52,    def list(self, id=None):\n        """\n        List all running jobs\n\n        :param id: optional ID for the job to list\n        """\n        args = {\'id\': id}\n        self._job_chk.check(args)\n        return self._client.json(\'job.list\', args)\n'
u'53,    def kill(self, id, signal=signal.SIGTERM):\n        """\n        Kill a job with given id\n\n        :WARNING: beware of what u kill, if u killed redis for example core0 or coreX won\'t be reachable\n\n        :param id: job id to kill\n        """\n        args = {\n            \'id\': id,\n            \'signal\': int(signal),\n        }\n        self._kill_chk.check(args)\n        return self._client.json(\'job.kill\', args)\n'
u'54,    def __init__(self, client):\n        self._client = client\n'
u'55,    def list(self, id=None):\n        """\n        List all running processes\n\n        :param id: optional PID for the process to list\n        """\n        args = {\'pid\': id}\n        self._process_chk.check(args)\n        return self._client.json(\'process.list\', args)\n'
u'56,    def kill(self, pid, signal=signal.SIGTERM):\n        """\n        Kill a process with given pid\n\n        :WARNING: beware of what u kill, if u killed redis for example core0 or coreX won\'t be reachable\n\n        :param pid: PID to kill\n        """\n        args = {\n            \'pid\': pid,\n            \'signal\': int(signal),\n        }\n        self._kill_chk.check(args)\n        return self._client.json(\'process.kill\', args)\n'
u'57,    def __init__(self, client):\n        self._client = client\n'
u'58,    def open(self, file, mode=\'r\', perm=0o0644):\n        """\n        Opens a file on the node\n\n        :param file: file path to open\n        :param mode: open mode\n        :param perm: file permission in octet form\n\n        mode:\n          \'r\' read only\n          \'w\' write only (truncate)\n          \'+\' read/write\n          \'x\' create if not exist\n          \'a\' append\n        :return: a file descriptor\n        """\n        args = {\n            \'file\': file,\n            \'mode\': mode,\n            \'perm\': perm,\n        }\n\n        return self._client.json(\'filesystem.open\', args)\n'
u'59,    def exists(self, path):\n        """\n        Check if path exists\n\n        :param path: path to file/dir\n        :return: boolean\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.exists\', args)\n'
u'60,    def list(self, path):\n        """\n        List all entries in directory\n        :param path: path to dir\n        :return: list of director entries\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.list\', args)\n'
u'61,    def mkdir(self, path):\n        """\n        Make a new directory == mkdir -p path\n        :param path: path to directory to create\n        :return:\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.mkdir\', args)\n'
u'62,    def remove(self, path):\n        """\n        Removes a path (recursively)\n\n        :param path: path to remove\n        :return:\n        """\n        args = {\n            \'path\': path,\n        }\n\n        return self._client.json(\'filesystem.remove\', args)\n'
u'63,    def move(self, path, destination):\n        """\n        Move a path to destination\n\n        :param path: source\n        :param destination: destination\n        :return:\n        """\n        args = {\n            \'path\': path,\n            \'destination\': destination,\n        }\n\n        return self._client.json(\'filesystem.move\', args)\n'
u'64,    def chmod(self, path, mode, recursive=False):\n        """\n        Change file/dir permission\n\n        :param path: path of file/dir to change\n        :param mode: octet mode\n        :param recursive: apply chmod recursively\n        :return:\n        """\n        args = {\n            \'path\': path,\n            \'mode\': mode,\n            \'recursive\': recursive,\n        }\n\n        return self._client.json(\'filesystem.chmod\', args)\n'
u'65,    def chown(self, path, user, group, recursive=False):\n        """\n        Change file/dir owner\n\n        :param path: path of file/dir\n        :param user: user name\n        :param group: group name\n        :param recursive: apply chown recursively\n        :return:\n        """\n        args = {\n            \'path\': path,\n            \'user\': user,\n            \'group\': group,\n            \'recursive\': recursive,\n        }\n\n        return self._client.json(\'filesystem.chown\', args)\n'
u'66,    def read(self, fd):\n        """\n        Read a block from the given file descriptor\n\n        :param fd: file descriptor\n        :return: bytes\n        """\n        args = {\n            \'fd\': fd,\n        }\n\n        data = self._client.json(\'filesystem.read\', args)\n        return base64.decodebytes(data.encode())\n'
u'67,    def write(self, fd, bytes):\n        """\n        Write a block of bytes to an open file descriptor (that is open with one of the writing modes\n\n        :param fd: file descriptor\n        :param bytes: bytes block to write\n        :return:\n\n        :note: don\'t overkill the node with large byte chunks, also for large file upload check the upload method.\n        """\n        args = {\n            \'fd\': fd,\n            \'block\': base64.encodebytes(bytes).decode(),\n        }\n\n        return self._client.json(\'filesystem.write\', args)\n'
u'68,    def close(self, fd):\n        """\n        Close file\n        :param fd: file descriptor\n        :return:\n        """\n        args = {\n            \'fd\': fd,\n        }\n\n        return self._client.json(\'filesystem.close\', args)\n'
u'69,    def upload(self, remote, reader):\n        """\n        Uploads a file\n        :param remote: remote file name\n        :param reader: an object that implements the read(size) method (typically a file descriptor)\n        :return:\n        """\n\n        fd = self.open(remote, \'w\')\n        while True:\n            chunk = reader.read(512 * 1024)\n            if chunk == b\'\':\n                break\n            self.write(fd, chunk)\n        self.close(fd)\n'
u'70,    def download(self, remote, writer):\n        """\n        Downloads a file\n        :param remote: remote file name\n        :param writer: an object the implements the write(bytes) interface (typical a file descriptor)\n        :return:\n        """\n\n        fd = self.open(remote)\n        while True:\n            chunk = self.read(fd)\n            if chunk == b\'\':\n                break\n            writer.write(chunk)\n        self.close(fd)\n'
u'71,    def upload_file(self, remote, local):\n        """\n        Uploads a file\n        :param remote: remote file name\n        :param local: local file name\n        :return:\n        """\n        file = open(local, \'rb\')\n        self.upload(remote, file)\n'
u'72,    def download_file(self, remote, local):\n        """\n        Downloads a file\n        :param remote: remote file name\n        :param local: local file name\n        :return:\n        """\n        file = open(local, \'wb\')\n        self.download(remote, file)\n'
u'73,    def __init__(self, timeout=None):\n        if timeout is None:\n            self.timeout = DefaultTimeout\n        else:\n            self.timeout = timeout\n        self._info = InfoManager(self)\n        self._job = JobManager(self)\n        self._process = ProcessManager(self)\n        self._filesystem = FilesystemManager(self)\n        self._ip = IPManager(self)\n'
u'74,    @property\n    def info(self):\n        """\n        info manager\n        :return:\n        """\n        return self._info\n'
u'75,    @property\n    def job(self):\n        """\n        job manager\n        :return:\n        """\n        return self._job\n'
u'76,    @property\n    def process(self):\n        """\n        process manager\n        :return:\n        """\n        return self._process\n'
u'77,    @property\n    def filesystem(self):\n        """\n        filesystem manager\n        :return:\n        """\n        return self._filesystem\n'
u'78,    @property\n    def ip(self):\n        """\n        ip manager\n        :return:\n        """\n        return self._ip\n'
u'79,    def raw(self, command, arguments, queue=None, max_time=None, stream=False):\n        """\n        Implements the low level command call, this needs to build the command structure\n        and push it on the correct queue.\n\n        :param command: Command name to execute supported by the node (ex: core.system, info.cpu, etc...)\n                        check documentation for list of built in commands\n        :param arguments: A dict of required command arguments depends on the command name.\n        :param queue: command queue (commands on the same queue are executed sequentially)\n        :param max_time: kill job server side if it exceeded this amount of seconds\n        :param stream: If True, process stdout and stderr are pushed to a special queue (stream:<id>) so\n            client can stream output\n        :return: Response object\n        """\n        raise NotImplemented()\n'
u'80,    def sync(self, command, arguments):\n        """\n        Same as self.raw except it do a response.get() waiting for the command execution to finish and reads the result\n\n        :return: Result object\n        """\n        response = self.raw(command, arguments)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'invalid response: %s\' % result.state, result)\n\n        return result\n'
u'81,    def json(self, command, arguments):\n        """\n        Same as self.sync except it assumes the returned result is json, and loads the payload of the return object\n        if the returned (data) is not of level (20) an error is raised.\n        :Return: Data\n        """\n        result = self.sync(command, arguments)\n        if result.level != 20:\n            raise RuntimeError(\'invalid result level, expecting json(20) got (%d)\' % result.level)\n\n        return json.loads(result.data)\n'
u'82,    def ping(self):\n        """\n        Ping a node, checking for it\'s availability. a Ping should never fail unless the node is not reachable\n        or not responsive.\n        :return:\n        """\n        response = self.raw(\'core.ping\', {})\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'invalid response: %s\' % result.state)\n\n        return json.loads(result.data)\n'
u'83,    def system(self, command, dir=\'\', stdin=\'\', env=None, queue=None, max_time=None, stream=False):\n        """\n        Execute a command\n\n        :param command:  command to execute (with its arguments) ex: `ls -l /root`\n        :param dir: CWD of command\n        :param stdin: Stdin data to feed to the command stdin\n        :param env: dict with ENV variables that will be exported to the command\n        :return:\n        """\n        parts = shlex.split(command)\n        if len(parts) == 0:\n            raise ValueError(\'invalid command\')\n\n        args = {\n            \'name\': parts[0],\n            \'args\': parts[1:],\n            \'dir\': dir,\n            \'stdin\': stdin,\n            \'env\': env,\n        }\n\n        self._system_chk.check(args)\n        response = self.raw(command=\'core.system\', arguments=args,\n                            queue=queue, max_time=max_time, stream=stream)\n\n        return response\n'
u'84,    def bash(self, script, stdin=\'\', queue=None, max_time=None, stream=False):\n        """\n        Execute a bash script, or run a process inside a bash shell.\n\n        :param script: Script to execute (can be multiline script)\n        :param stdin: Stdin data to feed to the script\n        :return:\n        """\n        args = {\n            \'script\': script,\n            \'stdin\': stdin,\n        }\n        self._bash_chk.check(args)\n        response = self.raw(command=\'bash\', arguments=args,\n                            queue=queue, max_time=max_time, stream=stream)\n\n        return response\n'
u"85,    class ContainerZerotierManager:\n        def __init__(self, client, container):\n            self._container = container\n            self._client = client\n\n        def info(self):\n            return self._client.json('corex.zerotier.info', {'container': self._container})\n\n        def list(self):\n            return self._client.json('corex.zerotier.list', {'container': self._container})\n"
u'86,    def __init__(self, client, container):\n        super().__init__(client.timeout)\n\n        self._client = client\n        self._container = container\n        self._zerotier = ContainerClient.ContainerZerotierManager(client, container)\n'
u'87,    @property\n    def container(self):\n        """\n        :return: container id\n        """\n        return self._container\n'
u'88,    @property\n    def zerotier(self):\n        """\n        information about zerotier id\n        :return:\n        """\n        return self._zerotier\n'
u'89,    def raw(self, command, arguments, queue=None, max_time=None, stream=False):\n        """\n        Implements the low level command call, this needs to build the command structure\n        and push it on the correct queue.\n\n        :param command: Command name to execute supported by the node (ex: core.system, info.cpu, etc...)\n                        check documentation for list of built in commands\n        :param arguments: A dict of required command arguments depends on the command name.\n        :param queue: command queue (commands on the same queue are executed sequentially)\n        :param max_time: kill job server side if it exceeded this amount of seconds\n        :param stream: If True, process stdout and stderr are pushed to a special queue (stream:<id>) so\n            client can stream output\n        :return: Response object\n        """\n        args = {\n            \'container\': self._container,\n            \'command\': {\n                \'command\': command,\n                \'arguments\': arguments,\n                \'queue\': queue,\n                \'max_time\': max_time,\n                \'stream\': stream,\n            },\n        }\n\n        # check input\n        self._raw_chk.check(args)\n\n        response = self._client.raw(\'corex.dispatch\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to dispatch command to container: %s\' % result.data)\n\n        cmd_id = json.loads(result.data)\n        return self._client.response_for(cmd_id)\n'
u'90,    class ContainerResponse(Response):\n        def get(self, timeout=None):\n            """\n            Get container ID\n            :param timeout: client side timeout in seconds (for the container ID to return)\n            :return: int\n            """\n            result = super().get(timeout)\n            if result.state != \'SUCCESS\':\n                raise Exception(\'failed to create container: %s\' % result.data)\n\n            return json.loads(result.data)\n'
u'91,    def __init__(self, client):\n        self._client = client\n'
u'92,    def create(self, root_url, mount=None, host_network=False, nics=DefaultNetworking, port=None, hostname=None, privileged=False, storage=None, tags=None):\n        """\n        Creater a new container with the given root flist, mount points and\n        zerotier id, and connected to the given bridges\n        :param root_url: The root filesystem flist\n        :param mount: a dict with {host_source: container_target} mount points.\n                      where host_source directory must exists.\n                      host_source can be a url to a flist to mount.\n        :param host_network: Specify if the container should share the same network stack as the host.\n                             if True, container creation ignores both zerotier, bridge and ports arguments below. Not\n                             giving errors if provided.\n        :param nics: Configure the attached nics to the container\n                     each nic object is a dict of the format\n                     {\n                        \'type\': nic_type # default, bridge, zerotier, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n                        \'id\': id # depends on the type, bridge name, zerotier network id, the vlan tag or the vxlan id\n                        \'name\': name of the nic inside the container (ignored in zerotier type)\n                        \'hwaddr\': Mac address of nic.\n                        \'config\': { # config is only honored for bridge, vlan, and vxlan types\n                            \'dhcp\': bool,\n                            \'cidr\': static_ip # ip/mask\n                            \'gateway\': gateway\n                            \'dns\': [dns]\n                        }\n                     }\n        :param port: A dict of host_port: container_port pairs (only if default networking is enabled)\n                       Example:\n                        `port={8080: 80, 7000:7000}`\n        :param hostname: Specific hostname you want to give to the container.\n                         if None it will automatically be set to core-x,\n                         x beeing the ID of the container\n        :param privileged: If true, container runs in privileged mode.\n        :param storage: A Url to the ardb storage to use to mount the root flist (or any other mount that requires g8fs)\n                        if not provided, the default one from core0 configuration will be used.\n        """\n\n        if nics == self.DefaultNetworking:\n            nics = [{\'type\': \'default\'}]\n        elif nics is None:\n            nics = []\n\n        args = {\n            \'root\': root_url,\n            \'mount\': mount,\n            \'host_network\': host_network,\n            \'nics\': nics,\n            \'port\': port,\n            \'hostname\': hostname,\n            \'privileged\': privileged,\n            \'storage\': storage,\n            \'tags\': tags,\n        }\n\n        # validate input\n        self._create_chk.check(args)\n\n        response = self._client.raw(\'corex.create\', args)\n\n        return self.ContainerResponse(self._client, response.id)\n'
u'93,    def list(self):\n        """\n        List running containers\n        :return: a dict with {container_id: <container info object>}\n        """\n        return self._client.json(\'corex.list\', {})\n'
u'94,    def find(self, *tags):\n        """\n        Find containers that matches set of tags\n        :param tags:\n        :return:\n        """\n        tags = list(map(str, tags))\n        return self._client.json(\'corex.find\', {\'tags\': tags})\n'
u'95,    def terminate(self, container):\n        """\n        Terminate a container given it\'s id\n\n        :param container: container id\n        :return:\n        """\n        self._client_chk.check(container)\n        args = {\n            \'container\': int(container),\n        }\n        response = self._client.raw(\'corex.terminate\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to terminate container: %s\' % result.data)\n'
u'96,    def client(self, container):\n        """\n        Return a client instance that is bound to that container.\n\n        :param container: container id\n        :return: Client object bound to the specified container id\n        Return a ContainerResponse from container.create\n        """\n\n        self._client_chk.check(container)\n        return ContainerClient(self._client, int(container))\n'
u'97,    class IPBridgeManager:\n        def __init__(self, client):\n            self._client = client\n\n        def add(self, name, hwaddr=None):\n            """\n            Add bridge with given name and optional hardware address\n\n            For more advanced bridge options please check the `bridge` manager.\n            :param name: bridge name\n            :param hwaddr: mac address (str)\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'hwaddr\': hwaddr,\n            }\n\n            return self._client.json("ip.bridge.add", args)\n\n        def delete(self, name):\n            """\n            Delete bridge with given name\n            :param name: bridge name to delete\n            :return:\n            """\n            args = {\n                \'name\': name,\n            }\n\n            return self._client.json("ip.bridge.del", args)\n\n        def addif(self, name, inf):\n            """\n            Add interface to bridge\n            :param name: bridge name\n            :param inf: interface name to add\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'inf\': inf,\n            }\n\n            return self._client.json(\'ip.bridge.addif\', args)\n\n        def delif(self, name, inf):\n            """\n            Delete interface from bridge\n            :param name: bridge name\n            :param inf: interface to remove\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'inf\': inf,\n            }\n\n            return self._client.json(\'ip.bridge.delif\', args)\n'
u'98,    class IPLinkManager:\n        def __init__(self, client):\n            self._client = client\n\n        def up(self, link):\n            """\n            Set interface state to UP\n\n            :param link: link/interface name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.link.up\', args)\n\n        def down(self, link):\n            """\n            Set link/interface state to DOWN\n\n            :param link: link/interface name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.link.down\', args)\n\n        def name(self, link, name):\n            """\n            Rename link\n\n            :param link: link to rename\n            :param name: new name\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'new\': name,\n            }\n            return self._client.json(\'ip.link.name\', args)\n\n        def list(self):\n            return self._client.json(\'ip.link.list\', {})\n'
u'99,    class IPAddrManager:\n        def __init__(self, client):\n            self._client = client\n\n        def add(self, link, ip):\n            """\n            Add IP to link\n\n            :param link: link\n            :param ip: ip address to add\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'ip\': ip,\n            }\n            return self._client.json(\'ip.addr.add\', args)\n\n        def delete(self, link, ip):\n            """\n            Delete IP from link\n\n            :param link: link\n            :param ip: ip address to remove\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'ip\': ip,\n            }\n            return self._client.json(\'ip.addr.del\', args)\n\n        def list(self, link):\n            """\n            List IPs of a link\n\n            :param link: link name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.addr.list\', args)\n'
u'100,    class IPRouteManager:\n        def __init__(self, client):\n            self._client = client\n\n        def add(self, dev, dst, gw=None):\n            """\n            Add a route\n\n            :param dev: device name\n            :param dst: destination network\n            :param gw: optional gateway\n            :return:\n            """\n            args = {\n                \'dev\': dev,\n                \'dst\': dst,\n                \'gw\': gw,\n            }\n            return self._client.json(\'ip.route.add\', args)\n\n        def delete(self, dev, dst, gw=None):\n            """\n            Delete a route\n\n            :param dev: device name\n            :param dst: destination network\n            :param gw: optional gateway\n            :return:\n            """\n            args = {\n                \'dev\': dev,\n                \'dst\': dst,\n                \'gw\': gw,\n            }\n            return self._client.json(\'ip.route.del\', args)\n\n        def list(self):\n            return self._client.json(\'ip.route.list\', {})\n'
u'101,    def __init__(self, client):\n        self._client = client\n        self._bridge = IPManager.IPBridgeManager(client)\n        self._link = IPManager.IPLinkManager(client)\n        self._addr = IPManager.IPAddrManager(client)\n        self._route = IPManager.IPRouteManager(client)\n'
u'102,    @property\n    def bridge(self):\n        """\n        Bridge manager\n        :return:\n        """\n        return self._bridge\n'
u'103,    @property\n    def link(self):\n        """\n        Link manager\n        :return:\n        """\n        return self._link\n'
u'104,    @property\n    def addr(self):\n        """\n        Address manager\n        :return:\n        """\n        return self._addr\n'
u'105,    @property\n    def route(self):\n        """\n        Route manager\n        :return:\n        """\n        return self._route\n'
u'106,    def __init__(self, client):\n        self._client = client\n'
u'107,    def create(self, name, hwaddr=None, network=None, nat=False, settings={}):\n        """\n        Create a bridge with the given name, hwaddr and networking setup\n        :param name: name of the bridge (must be unique), 15 characters or less, and not equal to "default".\n        :param hwaddr: MAC address of the bridge. If none, a one will be created for u\n        :param network: Networking mode, options are none, static, and dnsmasq\n        :param nat: If true, SNAT will be enabled on this bridge. (IF and ONLY IF an IP is set on the bridge\n                    via the settings, otherwise flag will be ignored) (the cidr attribute of either static, or dnsmasq modes)\n        :param settings: Networking setting, depending on the selected mode.\n                        none:\n                            no settings, bridge won\'t get any ip settings\n                        static:\n                            settings={\'cidr\': \'ip/net\'}\n                            bridge will get assigned the given IP address\n                        dnsmasq:\n                            settings={\'cidr\': \'ip/net\', \'start\': \'ip\', \'end\': \'ip\'}\n                            bridge will get assigned the ip in cidr\n                            and each running container that is attached to this IP will get\n                            IP from the start/end range. Netmask of the range is the netmask\n                            part of the provided cidr.\n                            if nat is true, SNAT rules will be automatically added in the firewall.\n        """\n        args = {\n            \'name\': name,\n            \'hwaddr\': hwaddr,\n            \'network\': {\n                \'mode\': network,\n                \'nat\': nat,\n                \'settings\': settings,\n            }\n        }\n\n        self._bridge_create_chk.check(args)\n\n        response = self._client.raw(\'bridge.create\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to create bridge %s\' % result.data)\n\n        return json.loads(result.data)\n'
u'108,    def list(self):\n        """\n        List all available bridges\n        :return: list of bridge names\n        """\n        response = self._client.raw(\'bridge.list\', {})\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to list bridges: %s\' % result.data)\n\n        return json.loads(result.data)\n'
u'109,    def delete(self, bridge):\n        """\n        Delete a bridge by name\n\n        :param bridge: bridge name\n        :return:\n        """\n        args = {\n            \'name\': bridge,\n        }\n\n        self._bridge_delete_chk.check(args)\n\n        response = self._client.raw(\'bridge.delete\', args)\n\n        result = response.get()\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to list delete: %s\' % result.data)\n'
u'110,    def __init__(self, client):\n        self._client = client\n'
u'111,    def list(self):\n        """\n        List available block devices\n        """\n        response = self._client.raw(\'disk.list\', {})\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to list disks: %s\' % result.stderr)\n\n        if result.level != 20:  # 20 is JSON output.\n            raise RuntimeError(\'invalid response type from disk.list command\')\n\n        data = result.data.strip()\n        if data:\n            return json.loads(data)\n        else:\n            return {}\n'
u'112,    def mktable(self, disk, table_type=\'gpt\'):\n        """\n        Make partition table on block device.\n        :param disk: device name (sda, sdb, etc...)\n        :param table_type: Partition table type as accepted by parted\n        """\n        args = {\n            \'disk\': disk,\n            \'table_type\': table_type,\n        }\n\n        self._mktable_chk.check(args)\n\n        response = self._client.raw(\'disk.mktable\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to create table: %s\' % result.stderr)\n'
u'113,    def getinfo(self, disk, part=\'\'):\n        """\n        Get more info about a disk or a disk partition\n\n        :param disk: (sda, sdb, etc..)\n        :param part: (sda1, sdb2, etc...)\n        :return: a dict with {"blocksize", "start", "size", and "free" sections}\n        """\n        args = {\n            "disk": disk,\n            "part": part,\n        }\n\n        self._getpart_chk.check(args)\n\n        response = self._client.raw(\'disk.getinfo\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to get info: %s\' % result.data)\n\n        if result.level != 20:  # 20 is JSON output.\n            raise RuntimeError(\'invalid response type from disk.getinfo command\')\n\n        data = result.data.strip()\n        if data:\n            return json.loads(data)\n        else:\n            return {}\n'
u'114,    def mkpart(self, disk, start, end, part_type=\'primary\'):\n        """\n        Make partition on disk\n        :param disk: device name (sda, sdb, etc...)\n        :param start: partition start as accepted by parted mkpart\n        :param end: partition end as accepted by parted mkpart\n        :param part_type: partition type as accepted by parted mkpart\n        """\n        args = {\n            \'disk\': disk,\n            \'start\': start,\n            \'end\': end,\n            \'part_type\': part_type,\n        }\n\n        self._mkpart_chk.check(args)\n\n        response = self._client.raw(\'disk.mkpart\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to create partition: %s\' % result.stderr)\n'
u'115,    def rmpart(self, disk, number):\n        """\n        Remove partion from disk\n        :param disk: device name (sda, sdb, etc...)\n        :param number: Partition number (starting from 1)\n        """\n        args = {\n            \'disk\': disk,\n            \'number\': number,\n        }\n\n        self._rmpart_chk.check(args)\n\n        response = self._client.raw(\'disk.rmpart\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to remove partition: %s\' % result.stderr)\n'
u'116,    def mount(self, source, target, options=[]):\n        """\n        Mount partion on target\n        :param source: Full partition path like /dev/sda1\n        :param target: Mount point\n        :param options: Optional mount options\n        """\n\n        if len(options) == 0:\n            options = [\'\']\n\n        args = {\n            \'options\': \',\'.join(options),\n            \'source\': source,\n            \'target\': target,\n        }\n\n        self._mount_chk.check(args)\n        response = self._client.raw(\'disk.mount\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to mount partition: %s\' % result.stderr)\n'
u'117,    def umount(self, source):\n        """\n        Unmount partion\n        :param source: Full partition path like /dev/sda1\n        """\n\n        args = {\n            \'source\': source,\n        }\n        self._umount_chk.check(args)\n\n        response = self._client.raw(\'disk.umount\', args)\n\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to umount partition: %s\' % result.stderr)\n'
u'118,    def __init__(self, client):\n        self._client = client\n'
u'119,    def list(self):\n        """\n        List all btrfs filesystem\n        """\n        return self._client.json(\'btrfs.list\', {})\n'
u'120,    def info(self, mountpoint):\n        """\n        Get btrfs fs info\n        """\n        return self._client.json(\'btrfs.info\', {\'mountpoint\': mountpoint})\n'
u'121,    def create(self, label, devices, metadata_profile="", data_profile="", overwrite=False):\n        """\n        Create a btrfs filesystem with the given label, devices, and profiles\n        :param label: name/label\n        :param devices : array of devices (/dev/sda1, etc...)\n        :metadata_profile: raid0, raid1, raid5, raid6, raid10, dup or single\n        :data_profile: same as metadata profile\n        :overwrite: force creation of the filesystem. Overwrite any existing filesystem\n        """\n        args = {\n            \'label\': label,\n            \'metadata\': metadata_profile,\n            \'data\': data_profile,\n            \'devices\': devices,\n            \'overwrite\': overwrite\n        }\n\n        self._create_chk.check(args)\n\n        self._client.sync(\'btrfs.create\', args)\n'
u'122,    def device_add(self, mountpoint, *device):\n        """\n        Add one or more devices to btrfs filesystem mounted under `mountpoint`\n\n        :param mountpoint: mount point of the btrfs system\n        :param devices: one ore more devices to add\n        :return:\n        """\n        if len(device) == 0:\n            return\n\n        args = {\n            \'mountpoint\': mountpoint,\n            \'devices\': device,\n        }\n\n        self._device_chk.check(args)\n\n        self._client.sync(\'btrfs.device_add\', args)\n'
u'123,    def device_remove(self, mountpoint, *device):\n        """\n        Remove one or more devices from btrfs filesystem mounted under `mountpoint`\n\n        :param mountpoint: mount point of the btrfs system\n        :param devices: one ore more devices to remove\n        :return:\n        """\n        if len(device) == 0:\n            return\n\n        args = {\n            \'mountpoint\': mountpoint,\n            \'devices\': device,\n        }\n\n        self._device_chk.check(args)\n\n        self._client.sync(\'btrfs.device_remove\', args)\n'
u'124,    def subvol_create(self, path):\n        """\n        Create a btrfs subvolume in the specified path\n        :param path: path to create\n        """\n        args = {\n            \'path\': path\n        }\n        self._subvol_chk.check(args)\n        self._client.sync(\'btrfs.subvol_create\', args)\n'
u'125,    def subvol_list(self, path):\n        """\n        List a btrfs subvolume in the specified path\n        :param path: path to be listed\n        """\n        return self._client.json(\'btrfs.subvol_list\', {\n            \'path\': path\n        })\n'
u'126,    def subvol_delete(self, path):\n        """\n        Delete a btrfs subvolume in the specified path\n        :param path: path to delete\n        """\n        args = {\n            \'path\': path\n        }\n\n        self._subvol_chk.check(args)\n\n        self._client.sync(\'btrfs.subvol_delete\', args)\n'
u'127,    def subvol_quota(self, path, limit):\n        """\n        Apply a quota to a btrfs subvolume in the specified path\n        :param path:  path to apply the quota for (it has to be the path of the subvol)\n        :param limit: the limit to Apply\n        """\n        args = {\n            \'path\': path,\n            \'limit\': limit,\n        }\n\n        self._subvol_quota_chk.check(args)\n\n        self._client.sync(\'btrfs.subvol_quota\', args)\n'
u'128,    def subvol_snapshot(self, source, destination, read_only=False):\n        """\n        Take a snapshot\n\n        :param source: source path of subvol\n        :param destination: destination path of snapshot\n        :param read_only: Set read-only on the snapshot\n        :return:\n        """\n\n        args = {\n            "source": source,\n            "destination": destination,\n            "read_only": read_only,\n        }\n\n        self._subvol_snapshot_chk.check(args)\n        self._client.sync(\'btrfs.subvol_snapshot\', args)\n'
u'129,    def __init__(self, client):\n        self._client = client\n'
u'130,    def join(self, network):\n        """\n        Join a zerotier network\n\n        :param network: network id to join\n        :return:\n        """\n        args = {\'network\': network}\n        self._network_chk.check(args)\n        response = self._client.raw(\'zerotier.join\', args)\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to join zerotier network: %s\', result.stderr)\n'
u'131,    def leave(self, network):\n        """\n        Leave a zerotier network\n\n        :param network: network id to leave\n        :return:\n        """\n        args = {\'network\': network}\n        self._network_chk.check(args)\n        response = self._client.raw(\'zerotier.leave\', args)\n        result = response.get()\n\n        if result.state != \'SUCCESS\':\n            raise RuntimeError(\'failed to leave zerotier network: %s\', result.stderr)\n'
u'132,    def list(self):\n        """\n        List joined zerotier networks\n\n        :return: list of joined networks with their info\n        """\n        return self._client.json(\'zerotier.list\', {})\n'
u'133,    def info(self):\n        """\n        Display zerotier status info\n\n        :return: dict of zerotier statusinfo\n        """\n        return self._client.json(\'zerotier.info\', {})\n'
u'134,    def __init__(self, client):\n        self._client = client\n'
u'135,    def create(self, name, media, cpu=2, memory=512, nics=None, port=None):\n        """\n        :param name: Name of the kvm domain\n        :param media: array of media objects to attach to the machine, where the first object is the boot device\n                      each media object is a dict of {url, type} where type can be one of \'disk\', or \'cdrom\', or empty (default to disk)\n                      example: [{\'url\': \'nbd+unix:///test?socket=/tmp/ndb.socket\'}, {\'type\': \'cdrom\': \'/somefile.iso\'}\n        :param cpu: number of vcpu cores\n        :param memory: memory in MiB\n        :param port: A dict of host_port: container_port pairs\n                       Example:\n                        `port={8080: 80, 7000:7000}`\n                     Only supported if default network is used\n        :param nics: Configure the attached nics to the container\n                     each nic object is a dict of the format\n                     {\n                        \'type\': nic_type # default, bridge, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n                        \'id\': id # depends on the type, bridge name (bridge type) zerotier network id (zertier type), the vlan tag or the vxlan id\n                     }\n        :return: uuid of the virtual machine\n        """\n\n        if nics is None:\n            nics = []\n\n        args = {\n            \'name\': name,\n            \'media\': media,\n            \'cpu\': cpu,\n            \'memory\': memory,\n            \'nics\': nics,\n            \'port\': port,\n        }\n        self._create_chk.check(args)\n\n        return self._client.sync(\'kvm.create\', args)\n'
u'136,    def destroy(self, uuid):\n        """\n        Destroy a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.destroy\', args)\n'
u'137,    def shutdown(self, uuid):\n        """\n        Shutdown a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.shutdown\', args)\n'
u'138,    def reboot(self, uuid):\n        """\n        Reboot a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.reboot\', args)\n'
u'139,    def reset(self, uuid):\n        """\n        Reset (Force reboot) a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.reset\', args)\n'
u'140,    def pause(self, uuid):\n        """\n        Pause a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.pause\', args)\n'
u'141,    def resume(self, uuid):\n        """\n        Resume a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        self._client.sync(\'kvm.resume\', args)\n'
u'142,    def info(self, uuid):\n        """\n        Get info about a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        return self._client.json(\'kvm.info\', args)\n'
u'143,    def infops(self, uuid):\n        """\n        Get info per second about a kvm domain by uuid\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n        }\n        self._domain_action_chk.check(args)\n\n        return self._client.json(\'kvm.infops\', args)\n'
u'144,    def attach_disk(self, uuid, media):\n        """\n        Attach a disk to a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param media: the media object to attach to the machine\n                      media object is a dict of {url, and type} where type can be one of \'disk\', or \'cdrom\', or empty (default to disk)\n                      examples: {\'url\': \'nbd+unix:///test?socket=/tmp/ndb.socket\'}, {\'type\': \'cdrom\': \'/somefile.iso\'}\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'media\': media,\n        }\n        self._man_disk_action_chk.check(args)\n\n        self._client.sync(\'kvm.attach_disk\', args)\n'
u'145,    def detach_disk(self, uuid, media):\n        """\n        Detach a disk from a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param media: the media object to attach to the machine\n                      media object is a dict of {url, and type} where type can be one of \'disk\', or \'cdrom\', or empty (default to disk)\n                      examples: {\'url\': \'nbd+unix:///test?socket=/tmp/ndb.socket\'}, {\'type\': \'cdrom\': \'/somefile.iso\'}\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'media\': media,\n        }\n        self._man_disk_action_chk.check(args)\n\n        self._client.sync(\'kvm.detach_disk\', args)\n'
u'146,    def add_nic(self, uuid, type, id=None, hwaddr=None):\n        """\n        Add a nic to a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param type: nic_type # default, bridge, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n         param id: id # depends on the type, bridge name (bridge type) zerotier network id (zertier type), the vlan tag or the vxlan id\n         param hwaddr: the hardware address of the nic\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'type\': type,\n            \'id\': id,\n            \'hwaddr\': hwaddr,\n        }\n        self._man_nic_action_chk.check(args)\n\n        return self._client.json(\'kvm.add_nic\', args)\n'
u'147,    def remove_nic(self, uuid, type, id=None, hwaddr=None):\n        """\n        Remove a nic from a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param type: nic_type # default, bridge, vlan, or vxlan (note, vlan and vxlan only supported by ovs)\n         param id: id # depends on the type, bridge name (bridge type) zerotier network id (zertier type), the vlan tag or the vxlan id\n         param hwaddr: the hardware address of the nic\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'type\': type,\n            \'id\': id,\n            \'hwaddr\': hwaddr,\n        }\n        self._man_nic_action_chk.check(args)\n\n        return self._client.json(\'kvm.remove_nic\', args)\n'
u'148,    def limit_disk_io(self, uuid, media, totalbytessecset=False, totalbytessec=0, readbytessecset=False, readbytessec=0, writebytessecset=False,\n                      writebytessec=0, totaliopssecset=False, totaliopssec=0, readiopssecset=False, readiopssec=0, writeiopssecset=False, writeiopssec=0,\n                      totalbytessecmaxset=False, totalbytessecmax=0, readbytessecmaxset=False, readbytessecmax=0, writebytessecmaxset=False, writebytessecmax=0,\n                      totaliopssecmaxset=False, totaliopssecmax=0, readiopssecmaxset=False, readiopssecmax=0, writeiopssecmaxset=False, writeiopssecmax=0,\n                      totalbytessecmaxlengthset=False, totalbytessecmaxlength=0, readbytessecmaxlengthset=False, readbytessecmaxlength=0,\n                      writebytessecmaxlengthset=False, writebytessecmaxlength=0, totaliopssecmaxlengthset=False, totaliopssecmaxlength=0,\n                      readiopssecmaxlengthset=False, readiopssecmaxlength=0, writeiopssecmaxlengthset=False, writeiopssecmaxlength=0, sizeiopssecset=False,\n                      sizeiopssec=0, groupnameset=False, groupname=\'\'):\n        """\n        Remove a nic from a machine\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param media: the media to limit the diskio\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'media\': media,\n            \'totalbytessecset\': totalbytessecset,\n            \'totalbytessec\': totalbytessec,\n            \'readbytessecset\': readbytessecset,\n            \'readbytessec\': readbytessec,\n            \'writebytessecset\': writebytessecset,\n            \'writebytessec\': writebytessec,\n            \'totaliopssecset\': totaliopssecset,\n            \'totaliopssec\': totaliopssec,\n            \'readiopssecset\': readiopssecset,\n            \'readiopssec\': readiopssec,\n            \'writeiopssecset\': writeiopssecset,\n            \'writeiopssec\': writeiopssec,\n            \'totalbytessecmaxset\': totalbytessecmaxset,\n            \'totalbytessecmax\': totalbytessecmax,\n            \'readbytessecmaxset\': readbytessecmaxset,\n            \'readbytessecmax\': readbytessecmax,\n            \'writebytessecmaxset\': writebytessecmaxset,\n            \'writebytessecmax\': writebytessecmax,\n            \'totaliopssecmaxset\': totaliopssecmaxset,\n            \'totaliopssecmax\': totaliopssecmax,\n            \'readiopssecmaxset\': readiopssecmaxset,\n            \'readiopssecmax\': readiopssecmax,\n            \'writeiopssecmaxset\': writeiopssecmaxset,\n            \'writeiopssecmax\': writeiopssecmax,\n            \'totalbytessecmaxlengthset\': totalbytessecmaxlengthset,\n            \'totalbytessecmaxlength\': totalbytessecmaxlength,\n            \'readbytessecmaxlengthset\': readbytessecmaxlengthset,\n            \'readbytessecmaxlength\': readbytessecmaxlength,\n            \'writebytessecmaxlengthset\': writebytessecmaxlengthset,\n            \'writebytessecmaxlength\': writebytessecmaxlength,\n            \'totaliopssecmaxlengthset\': totaliopssecmaxlengthset,\n            \'totaliopssecmaxlength\': totaliopssecmaxlength,\n            \'readiopssecmaxlengthset\': readiopssecmaxlengthset,\n            \'readiopssecmaxlength\': readiopssecmaxlength,\n            \'writeiopssecmaxlengthset\': writeiopssecmaxlengthset,\n            \'writeiopssecmaxlength\': writeiopssecmaxlength,\n            \'sizeiopssecset\': sizeiopssecset,\n            \'sizeiopssec\': sizeiopssec,\n            \'groupnameset\': groupnameset,\n            \'groupname\': groupname,\n        }\n        self._limit_disk_io_action_chk.check(args)\n\n        self._client.sync(\'kvm.limit_disk_io\', args)\n'
u'149,    def migrate(self, uuid, desturi):\n        """\n        Migrate a vm to another node\n        :param uuid: uuid of the kvm container (same as the used in create)\n        :param desturi: the uri of the destination node\n        :return:\n        """\n        args = {\n            \'uuid\': uuid,\n            \'desturi\': desturi,\n        }\n        self._migrate_action_chk.check(args)\n\n        self._client.sync(\'kvm.migrate\', args)\n'
u'150,    def list(self):\n        """\n        List configured domains\n\n        :return:\n        """\n        return self._client.json(\'kvm.list\', {})\n'
u'151,    def __init__(self, client):\n        self._client = client\n'
u'152,    def set_level(self, level):\n        """\n        Set the log level of the g8os\n        :param level: the level to be set can be one of ("CRITICAL", "ERROR", "WARNING", "NOTICE", "INFO", "DEBUG")\n        """\n        args = {\n            \'level\': level,\n        }\n        self._level_chk.check(args)\n\n        return self._client.json(\'logger.set_level\', args)\n'
u'153,    def reopen(self):\n        """\n        Reopen log file (rotate)\n        """\n        return self._client.json(\'logger.reopen\', {})\n'
u'154,    def __init__(self, client):\n        self._client = client\n'
u'155,    def open_port(self, port, interface=None, subnet=None):\n        """\n        open port\n        :param port: then port number\n        :param interface: an optional interface to open the port for\n        :param subnet: an optional subnet to open the port for\n        """\n        args = {\n            \'port\': port,\n            \'interface\': interface,\n            \'subnet\': subnet,\n        }\n        self._port_chk.check(args)\n\n        return self._client.json(\'nft.open_port\', args)\n'
u'156,    def drop_port(self, port, interface=None, subnet=None):\n        """\n        close an opened port (takes the same parameters passed in open)\n        :param port: then port number\n        :param interface: an optional interface to close the port for\n        :param subnet: an optional subnet to close the port for\n        """\n        args = {\n            \'port\': port,\n            \'interface\': interface,\n            \'subnet\': subnet,\n        }\n        self._port_chk.check(args)\n\n        return self._client.json(\'nft.drop_port\', args)\n'
u'157,    def list(self):\n        """\n        List open ports\n        """\n        return self._client.json(\'nft.list\', {})\n'
u'158,    def rule_exists(self, port, interface=None, subnet=None):\n        """\n        Check if a rule exists (takes the same parameters passed in open)\n        :param port: then port number\n        :param interface: an optional interface\n        :param subnet: an optional subnet\n        """\n        args = {\n            \'port\': port,\n            \'interface\': interface,\n            \'subnet\': subnet,\n        }\n        self._port_chk.check(args)\n\n        return self._client.json(\'nft.rule_exists\', args)\n'
u'159,    def __init__(self, client):\n        self._client = client\n'
u'160,    def get(self):\n        """\n        Get the config of g8os\n        """\n        return self._client.json(\'config.get\', {})\n'
u'161,    def __init__(self, client):\n        self._client = client\n'
u'162,    def query(self, key=None, **tags):\n        """\n        Query zero-os aggregator for current state object of monitored metrics.\n        \n        Note: ID is returned as part of the key (if set) to avoid conflict with similar metrics that\n        has same key. For example, a cpu core nr can be the id associated with \'machine.CPU.percent\' \n        so we can return all values for all the core numbers in the same dict.\n        \n        U can filter on the ID as a tag\n        :example:\n            self.query(key=key, id=value)\n            \n        :param key: metric key (ex: machine.memory.ram.available) \n        :param tags: optional tags filter\n        :return: dict of {\n            \'key[/id]\': state object\n        }\n        """\n        args = {\n            \'key\': key,\n            \'tags\': tags,\n        }\n        self._query_chk.check(args)\n\n        return self._client.json(\'aggregator.query\', args)\n'
u'163,    def __init__(self, host, port=6379, password="", db=0, ssl=True, timeout=None, testConnectionAttempts=3):\n        super().__init__(timeout=timeout)\n\n        socket_timeout = (timeout + 5) if timeout else 15\n        socket_keepalive_options = dict()\n        if hasattr(socket, \'TCP_KEEPIDLE\'):\n            socket_keepalive_options[socket.TCP_KEEPIDLE] = 1\n        if hasattr(socket, \'TCP_KEEPINTVL\'):\n            socket_keepalive_options[socket.TCP_KEEPINTVL] = 1\n        if hasattr(socket, \'TCP_KEEPIDLE\'):\n            socket_keepalive_options[socket.TCP_KEEPIDLE] = 1\n        self._redis = redis.Redis(host=host, port=port, password=password, db=db, ssl=ssl,\n                                  socket_timeout=socket_timeout,\n                                  socket_keepalive=True, socket_keepalive_options=socket_keepalive_options)\n        self._container_manager = ContainerManager(self)\n        self._bridge_manager = BridgeManager(self)\n        self._disk_manager = DiskManager(self)\n        self._btrfs_manager = BtrfsManager(self)\n        self._zerotier = ZerotierManager(self)\n        self._kvm = KvmManager(self)\n        self._logger = Logger(self)\n        self._nft = Nft(self)\n        self._config = Config(self)\n        self._aggregator = AggregatorManager(self)\n\n        if testConnectionAttempts:\n            for _ in range(testConnectionAttempts):\n                try:\n                    self.ping()\n                except:\n                    pass\n                else:\n                    return\n            raise RuntimeError("Could not connect to remote host %s" % host)\n'
u'164,    @property\n    def container(self):\n        """\n        Container manager\n        :return:\n        """\n        return self._container_manager\n'
u'165,    @property\n    def bridge(self):\n        """\n        Bridge manager\n        :return:\n        """\n        return self._bridge_manager\n'
u'166,    @property\n    def disk(self):\n        """\n        Disk manager\n        :return:\n        """\n        return self._disk_manager\n'
u'167,    @property\n    def btrfs(self):\n        """\n        Btrfs manager\n        :return:\n        """\n        return self._btrfs_manager\n'
u'168,    @property\n    def zerotier(self):\n        """\n        Zerotier manager\n        :return:\n        """\n        return self._zerotier\n'
u'169,    @property\n    def kvm(self):\n        """\n        KVM manager\n        :return:\n        """\n        return self._kvm\n'
u'170,    @property\n    def logger(self):\n        """\n        Logger manager\n        :return:\n        """\n        return self._logger\n'
u'171,    @property\n    def nft(self):\n        """\n        NFT manager\n        :return:\n        """\n        return self._nft\n'
u'172,    @property\n    def config(self):\n        """\n        Config manager\n        :return:\n        """\n        return self._config\n'
u'173,    @property\n    def aggregator(self):\n        """\n        Aggregator manager\n        :return: \n        """\n        return self._aggregator\n'
u'174,    def raw(self, command, arguments, queue=None, max_time=None, stream=False):\n        """\n        Implements the low level command call, this needs to build the command structure\n        and push it on the correct queue.\n\n        :param command: Command name to execute supported by the node (ex: core.system, info.cpu, etc...)\n                        check documentation for list of built in commands\n        :param arguments: A dict of required command arguments depends on the command name.\n        :param queue: command queue (commands on the same queue are executed sequentially)\n        :param max_time: kill job server side if it exceeded this amount of seconds\n        :param stream: If True, process stdout and stderr are pushed to a special queue (stream:<id>) so\n            client can stream output\n        :return: Response object\n        """\n        id = str(uuid.uuid4())\n\n        payload = {\n            \'id\': id,\n            \'command\': command,\n            \'arguments\': arguments,\n            \'queue\': queue,\n            \'max_time\': max_time,\n            \'stream\': stream,\n        }\n\n        flag = \'result:{}:flag\'.format(id)\n        self._redis.rpush(\'core:default\', json.dumps(payload))\n        if self._redis.brpoplpush(flag, flag, DefaultTimeout) is None:\n            Timeout(\'failed to queue job {}\'.format(id))\n        logger.debug(\'%s >> g8core.%s(%s)\', id, command, \', \'.join(("%s=%s" % (k, v) for k, v in arguments.items())))\n\n        return Response(self, id)\n'
u'175,    def response_for(self, id):\n        return Response(self, id)\n'
u'176,        def __init__(self, client, container):\n            self._container = container\n            self._client = client\n'
u"177,        def info(self):\n            return self._client.json('corex.zerotier.info', {'container': self._container})\n"
u"178,        def list(self):\n            return self._client.json('corex.zerotier.list', {'container': self._container})\n"
u'179,        def get(self, timeout=None):\n            """\n            Get container ID\n            :param timeout: client side timeout in seconds (for the container ID to return)\n            :return: int\n            """\n            result = super().get(timeout)\n            if result.state != \'SUCCESS\':\n                raise Exception(\'failed to create container: %s\' % result.data)\n\n            return json.loads(result.data)\n'
u'180,        def __init__(self, client):\n            self._client = client\n'
u'181,        def add(self, name, hwaddr=None):\n            """\n            Add bridge with given name and optional hardware address\n\n            For more advanced bridge options please check the `bridge` manager.\n            :param name: bridge name\n            :param hwaddr: mac address (str)\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'hwaddr\': hwaddr,\n            }\n\n            return self._client.json("ip.bridge.add", args)\n'
u'182,        def delete(self, name):\n            """\n            Delete bridge with given name\n            :param name: bridge name to delete\n            :return:\n            """\n            args = {\n                \'name\': name,\n            }\n\n            return self._client.json("ip.bridge.del", args)\n'
u'183,        def addif(self, name, inf):\n            """\n            Add interface to bridge\n            :param name: bridge name\n            :param inf: interface name to add\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'inf\': inf,\n            }\n\n            return self._client.json(\'ip.bridge.addif\', args)\n'
u'184,        def delif(self, name, inf):\n            """\n            Delete interface from bridge\n            :param name: bridge name\n            :param inf: interface to remove\n            :return:\n            """\n            args = {\n                \'name\': name,\n                \'inf\': inf,\n            }\n\n            return self._client.json(\'ip.bridge.delif\', args)\n'
u'185,        def __init__(self, client):\n            self._client = client\n'
u'186,        def up(self, link):\n            """\n            Set interface state to UP\n\n            :param link: link/interface name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.link.up\', args)\n'
u'187,        def down(self, link):\n            """\n            Set link/interface state to DOWN\n\n            :param link: link/interface name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.link.down\', args)\n'
u'188,        def name(self, link, name):\n            """\n            Rename link\n\n            :param link: link to rename\n            :param name: new name\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'new\': name,\n            }\n            return self._client.json(\'ip.link.name\', args)\n'
u"189,        def list(self):\n            return self._client.json('ip.link.list', {})\n"
u'190,        def __init__(self, client):\n            self._client = client\n'
u'191,        def add(self, link, ip):\n            """\n            Add IP to link\n\n            :param link: link\n            :param ip: ip address to add\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'ip\': ip,\n            }\n            return self._client.json(\'ip.addr.add\', args)\n'
u'192,        def delete(self, link, ip):\n            """\n            Delete IP from link\n\n            :param link: link\n            :param ip: ip address to remove\n            :return:\n            """\n            args = {\n                \'name\': link,\n                \'ip\': ip,\n            }\n            return self._client.json(\'ip.addr.del\', args)\n'
u'193,        def list(self, link):\n            """\n            List IPs of a link\n\n            :param link: link name\n            :return:\n            """\n            args = {\n                \'name\': link,\n            }\n            return self._client.json(\'ip.addr.list\', args)\n'
u'194,        def __init__(self, client):\n            self._client = client\n'
u'195,        def add(self, dev, dst, gw=None):\n            """\n            Add a route\n\n            :param dev: device name\n            :param dst: destination network\n            :param gw: optional gateway\n            :return:\n            """\n            args = {\n                \'dev\': dev,\n                \'dst\': dst,\n                \'gw\': gw,\n            }\n            return self._client.json(\'ip.route.add\', args)\n'
u'196,        def delete(self, dev, dst, gw=None):\n            """\n            Delete a route\n\n            :param dev: device name\n            :param dst: destination network\n            :param gw: optional gateway\n            :return:\n            """\n            args = {\n                \'dev\': dev,\n                \'dst\': dst,\n                \'gw\': gw,\n            }\n            return self._client.json(\'ip.route.del\', args)\n'
u"197,        def list(self):\n            return self._client.json('ip.route.list', {})\n"
u'198,\nmissing = object()\n\n\ndef primitive(typ):\n    return typ in [str, int, float, bool]\n\n\nclass CheckerException(Exception):\n    pass\n\n\nclass Tracker(Exception):\n    def __init__(self, base):\n        self._base = base\n        self._reason = None\n        self._branches = []\n\n    @property\n    def branches(self):\n        return self._branches\n\n    def copy(self):\n        l = self._base.copy()\n        t = Tracker(l)\n        t._reason = self._reason\n        return t\n\n    def push(self, s):\n        t = self.copy()\n        t._base.append(str(s))\n        return t\n\n    def pop(self):\n        t = self.copy()\n        t._base.pop()\n        return t\n\n    def reason(self, reason):\n        self._reason = reason\n        return self\n\n    def branch(self, tracker):\n        t = tracker.copy()\n        self._branches.append(t)\n\n    def __str__(self):\n        u = "/".join(self._base)\n        if self._reason is not None:\n            u = \'[{}] at -> {}\'.format(self._reason, u)\n        for branch in self.branches:\n            u += \'\\n  -> {}\'.format(branch)\n\n        return u\n\n    def __repr__(self):\n        return str(self)\n\n\nclass Option:\n    def __init__(self):\n        raise NotImplementedError()\n\n    def check(self, object, t):\n        raise NotImplementedError()\n\n\nclass Or(Option):\n    def __init__(self, *types):\n        self._checkers = []\n        for typ in types:\n            self._checkers.append(Checker(typ))\n\n    def check(self, object, t):\n        bt = t.copy()\n        for chk in self._checkers:\n            try:\n                chk.check(object, bt)\n                return\n            except Tracker as tx:\n                t.branch(tx)\n        raise t.reason(\'all branches failed\')\n\n\nclass IsNone(Option):\n    def __init__(self):\n        pass\n\n    def check(self, object, t):\n        if object is not None:\n            raise t.reason(\'is not none\')\n\n\nclass Missing(Option):\n    def __init__(self):\n        pass\n\n    def check(self, object, t):\n        if object != missing:\n            raise t.reason(\'is not missing\')\n\n\nclass Any(Option):\n    def __init__(self):\n        pass\n\n    def check(self, object, t):\n        return\n\n\nclass Length(Option):\n    def __init__(self, typ, min=None, max=None):\n        self._checker = Checker(typ)\n        if min is None and max is None:\n            raise ValueError("you have to pass wither min or max to the length type checker")\n        self._min = min\n        self._max = max\n\n    def check(self, object, t):\n        self._checker.check(object, t)\n        if self._min is not None and len(object) < self._min:\n            raise t.reason(\'invalid length, expecting more than or equal {} got {}\'.format(self._min, len(object)))\n        if self._max is not None and len(object) > self._max:\n            raise t.reason(\'invalid length, expecting less than or equal {} got {}\'.format(self._max, len(object)))\n\n\nclass Map(Option):\n    def __init__(self, key_type, value_type):\n        self._key = Checker(key_type)\n        self._value = Checker(value_type)\n\n    def check(self, object, t):\n        if not isinstance(object, dict):\n            raise t.reason(\'expecting a dict, got {}\'.format(type(object)))\n        for k, v in object.items():\n            tx = t.push(k)\n            self._key.check(k, tx)\n            tv = t.push(\'{}[value]\'.format(k))\n            self._value.check(v, tv)\n\n\nclass Enum(Option):\n    def __init__(self, *valid):\n        self._valid = valid\n\n    def check(self, object, t):\n        if not isinstance(object, str):\n            raise t.reason(\'expecting string, got {}\'.format(type(object)))\n        if object not in self._valid:\n            raise t.reason(\'value "{}" not in enum\'.format(object))\n\n\nclass Checker:\n    """\n    Build a type checker to check method inputs\n\n    A Checker takes a type definition as following\n\n    c = Checker(<type-def>)\n    then use c to check inputs as\n\n    valid = c.check(value)\n\n    type-def:\n    - primitive types (str, bool, int, float)\n    - composite types ([str], [int], etc...)\n    - dicts types ({\'name\': str, \'age\': float, etc...})\n\n    To build a more complex type-def u can use the available Options in typechk module\n\n    - Or(type-def, type-def, ...)\n    - Missing() (Only make sense in dict types)\n    - IsNone() (accept None value)\n\n    Example of type definition\n    A dict object, with the following attributes\n    - `name` of type string\n    - optional `age` which can be int, or float\n    - A list of children each has\n        - string name\n        - float age\n\n\n    c = Checker({\n        \'name\': str,\n        \'age\': Or(int, float, Missing()),\n        \'children\': [{\'name\': str, \'age\': float}]\n    })\n\n    c.check({\'name\': \'azmy\', \'age\': 34, children:[]}) # passes\n    c.check({\'name\': \'azmy\', children:[]}) # passes\n    c.check({\'age\': 34, children:[]}) # does not pass\n    c.check({\'name\': \'azmy\', children:[{\'name\': \'yahia\', \'age\': 4.0}]}) # passes\n    c.check({\'name\': \'azmy\', children:[{\'name\': \'yahia\', \'age\': 4.0}, {\'name\': \'yassine\'}]}) # does not pass\n    """\n    def __init__(self, tyepdef):\n        self._typ = tyepdef\n\n    def check(self, object, tracker=None):\n        if tracker is None:\n            tracker = Tracker([]).push(\'/\')\n        return self._check(self._typ, object, tracker)\n\n    def _check_list(self, typ, obj_list, t):\n        for i, elem in enumerate(obj_list):\n            tx = t.push(\'[{}]\'.format(i))\n            self._check(typ, elem, tx)\n\n    def _check_dict(self, typ, obj_dict, t):\n        given = []\n        for name, value in obj_dict.items():\n            tx = t.push(name)\n            if name not in typ:\n                raise tx.reason(\'unknown key "{}"\'.format(name))\n            given.append(name)\n            attr_type = typ[name]\n            self._check(attr_type, value, tx)\n\n        if len(given) == len(typ):\n            return\n\n        type_keys = list(typ.keys())\n        for key in given:\n            type_keys.remove(key)\n\n        for required in type_keys:\n            tx = t.push(required)\n            self._check(typ[required], missing, tx)\n\n    def _check(self, typ, object, t):\n        if isinstance(typ, Option):\n            return typ.check(object, t)\n\n        atyp = type(object)\n        if isinstance(typ, list):\n            if atyp != list:\n                raise t.reason(\'expecting a list\')\n            self._check_list(typ[0], object, t)\n        elif isinstance(typ, tuple):\n            if atyp != tuple:\n                raise t.reason(\'expecting a tuple\')\n            self._check_list(typ[0], object, t)\n        elif isinstance(typ, dict):\n            if atyp != dict:\n                raise t.reason(\'expecting a dict\')\n            self._check_dict(typ, object, t)\n        elif atyp != typ:\n            raise t.reason(\'invalid type, expecting {}\'.format(typ))\n'
u'199,def primitive(typ):\n    return typ in [str, int, float, bool]\n'
u'200,class CheckerException(Exception):\n    pass\n'
u'201,class Tracker(Exception):\n    def __init__(self, base):\n        self._base = base\n        self._reason = None\n        self._branches = []\n\n    @property\n    def branches(self):\n        return self._branches\n\n    def copy(self):\n        l = self._base.copy()\n        t = Tracker(l)\n        t._reason = self._reason\n        return t\n\n    def push(self, s):\n        t = self.copy()\n        t._base.append(str(s))\n        return t\n\n    def pop(self):\n        t = self.copy()\n        t._base.pop()\n        return t\n\n    def reason(self, reason):\n        self._reason = reason\n        return self\n\n    def branch(self, tracker):\n        t = tracker.copy()\n        self._branches.append(t)\n\n    def __str__(self):\n        u = "/".join(self._base)\n        if self._reason is not None:\n            u = \'[{}] at -> {}\'.format(self._reason, u)\n        for branch in self.branches:\n            u += \'\\n  -> {}\'.format(branch)\n\n        return u\n\n    def __repr__(self):\n        return str(self)\n'
u'202,class Option:\n    def __init__(self):\n        raise NotImplementedError()\n\n    def check(self, object, t):\n        raise NotImplementedError()\n'
u"203,class Or(Option):\n    def __init__(self, *types):\n        self._checkers = []\n        for typ in types:\n            self._checkers.append(Checker(typ))\n\n    def check(self, object, t):\n        bt = t.copy()\n        for chk in self._checkers:\n            try:\n                chk.check(object, bt)\n                return\n            except Tracker as tx:\n                t.branch(tx)\n        raise t.reason('all branches failed')\n"
u"204,class IsNone(Option):\n    def __init__(self):\n        pass\n\n    def check(self, object, t):\n        if object is not None:\n            raise t.reason('is not none')\n"
u"205,class Missing(Option):\n    def __init__(self):\n        pass\n\n    def check(self, object, t):\n        if object != missing:\n            raise t.reason('is not missing')\n"
u'206,class Any(Option):\n    def __init__(self):\n        pass\n\n    def check(self, object, t):\n        return\n'
u'207,class Length(Option):\n    def __init__(self, typ, min=None, max=None):\n        self._checker = Checker(typ)\n        if min is None and max is None:\n            raise ValueError("you have to pass wither min or max to the length type checker")\n        self._min = min\n        self._max = max\n\n    def check(self, object, t):\n        self._checker.check(object, t)\n        if self._min is not None and len(object) < self._min:\n            raise t.reason(\'invalid length, expecting more than or equal {} got {}\'.format(self._min, len(object)))\n        if self._max is not None and len(object) > self._max:\n            raise t.reason(\'invalid length, expecting less than or equal {} got {}\'.format(self._max, len(object)))\n'
u"208,class Map(Option):\n    def __init__(self, key_type, value_type):\n        self._key = Checker(key_type)\n        self._value = Checker(value_type)\n\n    def check(self, object, t):\n        if not isinstance(object, dict):\n            raise t.reason('expecting a dict, got {}'.format(type(object)))\n        for k, v in object.items():\n            tx = t.push(k)\n            self._key.check(k, tx)\n            tv = t.push('{}[value]'.format(k))\n            self._value.check(v, tv)\n"
u'209,class Enum(Option):\n    def __init__(self, *valid):\n        self._valid = valid\n\n    def check(self, object, t):\n        if not isinstance(object, str):\n            raise t.reason(\'expecting string, got {}\'.format(type(object)))\n        if object not in self._valid:\n            raise t.reason(\'value "{}" not in enum\'.format(object))\n'
u'210,class Checker:\n    """\n    Build a type checker to check method inputs\n\n    A Checker takes a type definition as following\n\n    c = Checker(<type-def>)\n    then use c to check inputs as\n\n    valid = c.check(value)\n\n    type-def:\n    - primitive types (str, bool, int, float)\n    - composite types ([str], [int], etc...)\n    - dicts types ({\'name\': str, \'age\': float, etc...})\n\n    To build a more complex type-def u can use the available Options in typechk module\n\n    - Or(type-def, type-def, ...)\n    - Missing() (Only make sense in dict types)\n    - IsNone() (accept None value)\n\n    Example of type definition\n    A dict object, with the following attributes\n    - `name` of type string\n    - optional `age` which can be int, or float\n    - A list of children each has\n        - string name\n        - float age\n\n\n    c = Checker({\n        \'name\': str,\n        \'age\': Or(int, float, Missing()),\n        \'children\': [{\'name\': str, \'age\': float}]\n    })\n\n    c.check({\'name\': \'azmy\', \'age\': 34, children:[]}) # passes\n    c.check({\'name\': \'azmy\', children:[]}) # passes\n    c.check({\'age\': 34, children:[]}) # does not pass\n    c.check({\'name\': \'azmy\', children:[{\'name\': \'yahia\', \'age\': 4.0}]}) # passes\n    c.check({\'name\': \'azmy\', children:[{\'name\': \'yahia\', \'age\': 4.0}, {\'name\': \'yassine\'}]}) # does not pass\n    """\n    def __init__(self, tyepdef):\n        self._typ = tyepdef\n\n    def check(self, object, tracker=None):\n        if tracker is None:\n            tracker = Tracker([]).push(\'/\')\n        return self._check(self._typ, object, tracker)\n\n    def _check_list(self, typ, obj_list, t):\n        for i, elem in enumerate(obj_list):\n            tx = t.push(\'[{}]\'.format(i))\n            self._check(typ, elem, tx)\n\n    def _check_dict(self, typ, obj_dict, t):\n        given = []\n        for name, value in obj_dict.items():\n            tx = t.push(name)\n            if name not in typ:\n                raise tx.reason(\'unknown key "{}"\'.format(name))\n            given.append(name)\n            attr_type = typ[name]\n            self._check(attr_type, value, tx)\n\n        if len(given) == len(typ):\n            return\n\n        type_keys = list(typ.keys())\n        for key in given:\n            type_keys.remove(key)\n\n        for required in type_keys:\n            tx = t.push(required)\n            self._check(typ[required], missing, tx)\n\n    def _check(self, typ, object, t):\n        if isinstance(typ, Option):\n            return typ.check(object, t)\n\n        atyp = type(object)\n        if isinstance(typ, list):\n            if atyp != list:\n                raise t.reason(\'expecting a list\')\n            self._check_list(typ[0], object, t)\n        elif isinstance(typ, tuple):\n            if atyp != tuple:\n                raise t.reason(\'expecting a tuple\')\n            self._check_list(typ[0], object, t)\n        elif isinstance(typ, dict):\n            if atyp != dict:\n                raise t.reason(\'expecting a dict\')\n            self._check_dict(typ, object, t)\n        elif atyp != typ:\n            raise t.reason(\'invalid type, expecting {}\'.format(typ))\n'
u'211,    def __init__(self, base):\n        self._base = base\n        self._reason = None\n        self._branches = []\n'
u'212,    @property\n    def branches(self):\n        return self._branches\n'
u'213,    def copy(self):\n        l = self._base.copy()\n        t = Tracker(l)\n        t._reason = self._reason\n        return t\n'
u'214,    def push(self, s):\n        t = self.copy()\n        t._base.append(str(s))\n        return t\n'
u'215,    def pop(self):\n        t = self.copy()\n        t._base.pop()\n        return t\n'
u'216,    def reason(self, reason):\n        self._reason = reason\n        return self\n'
u'217,    def branch(self, tracker):\n        t = tracker.copy()\n        self._branches.append(t)\n'
u'218,    def __str__(self):\n        u = "/".join(self._base)\n        if self._reason is not None:\n            u = \'[{}] at -> {}\'.format(self._reason, u)\n        for branch in self.branches:\n            u += \'\\n  -> {}\'.format(branch)\n\n        return u\n'
u'219,    def __repr__(self):\n        return str(self)\n'
u'220,    def __init__(self):\n        raise NotImplementedError()\n'
u'221,    def check(self, object, t):\n        raise NotImplementedError()\n'
u'222,    def __init__(self, *types):\n        self._checkers = []\n        for typ in types:\n            self._checkers.append(Checker(typ))\n'
u"223,    def check(self, object, t):\n        bt = t.copy()\n        for chk in self._checkers:\n            try:\n                chk.check(object, bt)\n                return\n            except Tracker as tx:\n                t.branch(tx)\n        raise t.reason('all branches failed')\n"
u'224,    def __init__(self):\n        pass\n'
u"225,    def check(self, object, t):\n        if object is not None:\n            raise t.reason('is not none')\n"
u'226,    def __init__(self):\n        pass\n'
u"227,    def check(self, object, t):\n        if object != missing:\n            raise t.reason('is not missing')\n"
u'228,    def __init__(self):\n        pass\n'
u'229,    def check(self, object, t):\n        return\n'
u'230,    def __init__(self, typ, min=None, max=None):\n        self._checker = Checker(typ)\n        if min is None and max is None:\n            raise ValueError("you have to pass wither min or max to the length type checker")\n        self._min = min\n        self._max = max\n'
u"231,    def check(self, object, t):\n        self._checker.check(object, t)\n        if self._min is not None and len(object) < self._min:\n            raise t.reason('invalid length, expecting more than or equal {} got {}'.format(self._min, len(object)))\n        if self._max is not None and len(object) > self._max:\n            raise t.reason('invalid length, expecting less than or equal {} got {}'.format(self._max, len(object)))\n"
u'232,    def __init__(self, key_type, value_type):\n        self._key = Checker(key_type)\n        self._value = Checker(value_type)\n'
u"233,    def check(self, object, t):\n        if not isinstance(object, dict):\n            raise t.reason('expecting a dict, got {}'.format(type(object)))\n        for k, v in object.items():\n            tx = t.push(k)\n            self._key.check(k, tx)\n            tv = t.push('{}[value]'.format(k))\n            self._value.check(v, tv)\n"
u'234,    def __init__(self, *valid):\n        self._valid = valid\n'
u'235,    def check(self, object, t):\n        if not isinstance(object, str):\n            raise t.reason(\'expecting string, got {}\'.format(type(object)))\n        if object not in self._valid:\n            raise t.reason(\'value "{}" not in enum\'.format(object))\n'
u'236,    def __init__(self, tyepdef):\n        self._typ = tyepdef\n'
u"237,    def check(self, object, tracker=None):\n        if tracker is None:\n            tracker = Tracker([]).push('/')\n        return self._check(self._typ, object, tracker)\n"
u"238,    def _check_list(self, typ, obj_list, t):\n        for i, elem in enumerate(obj_list):\n            tx = t.push('[{}]'.format(i))\n            self._check(typ, elem, tx)\n"
u'239,    def _check_dict(self, typ, obj_dict, t):\n        given = []\n        for name, value in obj_dict.items():\n            tx = t.push(name)\n            if name not in typ:\n                raise tx.reason(\'unknown key "{}"\'.format(name))\n            given.append(name)\n            attr_type = typ[name]\n            self._check(attr_type, value, tx)\n\n        if len(given) == len(typ):\n            return\n\n        type_keys = list(typ.keys())\n        for key in given:\n            type_keys.remove(key)\n\n        for required in type_keys:\n            tx = t.push(required)\n            self._check(typ[required], missing, tx)\n'
u"240,    def _check(self, typ, object, t):\n        if isinstance(typ, Option):\n            return typ.check(object, t)\n\n        atyp = type(object)\n        if isinstance(typ, list):\n            if atyp != list:\n                raise t.reason('expecting a list')\n            self._check_list(typ[0], object, t)\n        elif isinstance(typ, tuple):\n            if atyp != tuple:\n                raise t.reason('expecting a tuple')\n            self._check_list(typ[0], object, t)\n        elif isinstance(typ, dict):\n            if atyp != dict:\n                raise t.reason('expecting a dict')\n            self._check_dict(typ, object, t)\n        elif atyp != typ:\n            raise t.reason('invalid type, expecting {}'.format(typ))\n"
u"241,__import__('pkg_resources').declare_namespace(__name__)\n"
u"242,from setuptools import setup, find_packages\n# To use a consistent encoding\nfrom codecs import open\nfrom os import path\n\nhere = path.abspath(path.dirname(__file__))\n\n# Get the long description from the README file\nwith open(path.join(here, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nsetup (\n    name='0-core-client',\n    version='1.1.0-alpha-5',\n    description='Zero-OS 0-core client',\n    long_description=long_description,\n    url='https://github.com/zero-os/0-core',\n    author='Muhamad Azmy',\n    author_email='muhamada@greenitglobe.com',\n    license='Apache 2.0',\n    namespaces=['zeroos'],\n    packages=find_packages(),\n    install_requires=['redis>=2.10.5'],\n)\n"
u'243,"""\nAuto-generated class for Bridge\n"""\nfrom .BridgeCreateSetting import BridgeCreateSetting\nfrom .EnumBridgeStatus import EnumBridgeStatus\n\nfrom . import client_support\n\n\nclass Bridge(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, setting, status):\n        """\n        :type name: str\n        :type setting: BridgeCreateSetting\n        :type status: EnumBridgeStatus\n        :rtype: Bridge\n        """\n\n        return Bridge(\n            name=name,\n            setting=setting,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Bridge\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'setting\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [BridgeCreateSetting]\n            try:\n                self.setting = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumBridgeStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'244,class Bridge(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, setting, status):\n        """\n        :type name: str\n        :type setting: BridgeCreateSetting\n        :type status: EnumBridgeStatus\n        :rtype: Bridge\n        """\n\n        return Bridge(\n            name=name,\n            setting=setting,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Bridge\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'setting\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [BridgeCreateSetting]\n            try:\n                self.setting = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumBridgeStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'245,    @staticmethod\n    def create(name, setting, status):\n        """\n        :type name: str\n        :type setting: BridgeCreateSetting\n        :type status: EnumBridgeStatus\n        :rtype: Bridge\n        """\n\n        return Bridge(\n            name=name,\n            setting=setting,\n            status=status,\n        )\n'
u"246,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Bridge'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'setting'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [BridgeCreateSetting]\n            try:\n                self.setting = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumBridgeStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'247,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'248,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'249,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'250,"""\nAuto-generated class for BridgeCreate\n"""\nfrom .BridgeCreateSetting import BridgeCreateSetting\nfrom .EnumBridgeCreateNetworkMode import EnumBridgeCreateNetworkMode\n\nfrom . import client_support\n\n\nclass BridgeCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, nat, networkMode, setting, hwaddr=None):\n        """\n        :type hwaddr: str\n        :type name: str\n        :type nat: bool\n        :type networkMode: EnumBridgeCreateNetworkMode\n        :type setting: BridgeCreateSetting\n        :rtype: BridgeCreate\n        """\n\n        return BridgeCreate(\n            hwaddr=hwaddr,\n            name=name,\n            nat=nat,\n            networkMode=networkMode,\n            setting=setting,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'BridgeCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'hwaddr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hwaddr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nat\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.nat = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'networkMode\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumBridgeCreateNetworkMode]\n            try:\n                self.networkMode = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'setting\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [BridgeCreateSetting]\n            try:\n                self.setting = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'251,class BridgeCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, nat, networkMode, setting, hwaddr=None):\n        """\n        :type hwaddr: str\n        :type name: str\n        :type nat: bool\n        :type networkMode: EnumBridgeCreateNetworkMode\n        :type setting: BridgeCreateSetting\n        :rtype: BridgeCreate\n        """\n\n        return BridgeCreate(\n            hwaddr=hwaddr,\n            name=name,\n            nat=nat,\n            networkMode=networkMode,\n            setting=setting,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'BridgeCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'hwaddr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hwaddr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nat\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.nat = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'networkMode\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumBridgeCreateNetworkMode]\n            try:\n                self.networkMode = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'setting\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [BridgeCreateSetting]\n            try:\n                self.setting = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'252,    @staticmethod\n    def create(name, nat, networkMode, setting, hwaddr=None):\n        """\n        :type hwaddr: str\n        :type name: str\n        :type nat: bool\n        :type networkMode: EnumBridgeCreateNetworkMode\n        :type setting: BridgeCreateSetting\n        :rtype: BridgeCreate\n        """\n\n        return BridgeCreate(\n            hwaddr=hwaddr,\n            name=name,\n            nat=nat,\n            networkMode=networkMode,\n            setting=setting,\n        )\n'
u"253,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'BridgeCreate'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'hwaddr'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hwaddr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nat'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.nat = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'networkMode'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumBridgeCreateNetworkMode]\n            try:\n                self.networkMode = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'setting'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [BridgeCreateSetting]\n            try:\n                self.setting = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'254,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'255,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'256,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'257,"""\nAuto-generated class for BridgeCreateSetting\n"""\n\nfrom . import client_support\n\n\nclass BridgeCreateSetting(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cidr, end, start):\n        """\n        :type cidr: str\n        :type end: str\n        :type start: str\n        :rtype: BridgeCreateSetting\n        """\n\n        return BridgeCreateSetting(\n            cidr=cidr,\n            end=end,\n            start=start,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'BridgeCreateSetting\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cidr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cidr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'end\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.end = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'start\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.start = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'258,class BridgeCreateSetting(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cidr, end, start):\n        """\n        :type cidr: str\n        :type end: str\n        :type start: str\n        :rtype: BridgeCreateSetting\n        """\n\n        return BridgeCreateSetting(\n            cidr=cidr,\n            end=end,\n            start=start,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'BridgeCreateSetting\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cidr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cidr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'end\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.end = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'start\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.start = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'259,    @staticmethod\n    def create(cidr, end, start):\n        """\n        :type cidr: str\n        :type end: str\n        :type start: str\n        :rtype: BridgeCreateSetting\n        """\n\n        return BridgeCreateSetting(\n            cidr=cidr,\n            end=end,\n            start=start,\n        )\n'
u"260,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'BridgeCreateSetting'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cidr'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cidr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'end'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.end = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'start'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.start = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'261,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'262,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'263,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'264,"""\nAuto-generated class for CPUInfo\n"""\n\nfrom . import client_support\n\n\nclass CPUInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cacheSize, cores, family, flags, mhz):\n        """\n        :type cacheSize: int\n        :type cores: int\n        :type family: str\n        :type flags: list[str]\n        :type mhz: float\n        :rtype: CPUInfo\n        """\n\n        return CPUInfo(\n            cacheSize=cacheSize,\n            cores=cores,\n            family=family,\n            flags=flags,\n            mhz=mhz,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CPUInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cacheSize\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cacheSize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'cores\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cores = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'family\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.family = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'flags\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flags = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mhz\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.mhz = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'265,class CPUInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cacheSize, cores, family, flags, mhz):\n        """\n        :type cacheSize: int\n        :type cores: int\n        :type family: str\n        :type flags: list[str]\n        :type mhz: float\n        :rtype: CPUInfo\n        """\n\n        return CPUInfo(\n            cacheSize=cacheSize,\n            cores=cores,\n            family=family,\n            flags=flags,\n            mhz=mhz,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CPUInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cacheSize\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cacheSize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'cores\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cores = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'family\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.family = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'flags\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flags = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mhz\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.mhz = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'266,    @staticmethod\n    def create(cacheSize, cores, family, flags, mhz):\n        """\n        :type cacheSize: int\n        :type cores: int\n        :type family: str\n        :type flags: list[str]\n        :type mhz: float\n        :rtype: CPUInfo\n        """\n\n        return CPUInfo(\n            cacheSize=cacheSize,\n            cores=cores,\n            family=family,\n            flags=flags,\n            mhz=mhz,\n        )\n'
u"267,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'CPUInfo'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cacheSize'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cacheSize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'cores'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cores = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'family'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.family = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'flags'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flags = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'mhz'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.mhz = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'268,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'269,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'270,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'271,"""\nAuto-generated class for CPUStats\n"""\n\nfrom . import client_support\n\n\nclass CPUStats(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(guestNice, idle, ioWait, irq, nice, softIrq, steal, stolen, system, user):\n        """\n        :type guestNice: float\n        :type idle: float\n        :type ioWait: float\n        :type irq: float\n        :type nice: float\n        :type softIrq: float\n        :type steal: float\n        :type stolen: float\n        :type system: float\n        :type user: float\n        :rtype: CPUStats\n        """\n\n        return CPUStats(\n            guestNice=guestNice,\n            idle=idle,\n            ioWait=ioWait,\n            irq=irq,\n            nice=nice,\n            softIrq=softIrq,\n            steal=steal,\n            stolen=stolen,\n            system=system,\n            user=user,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CPUStats\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'guestNice\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.guestNice = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'idle\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.idle = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ioWait\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.ioWait = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'irq\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.irq = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nice\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.nice = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'softIrq\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.softIrq = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'steal\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.steal = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'stolen\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.stolen = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'system\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.system = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'user\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.user = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'272,class CPUStats(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(guestNice, idle, ioWait, irq, nice, softIrq, steal, stolen, system, user):\n        """\n        :type guestNice: float\n        :type idle: float\n        :type ioWait: float\n        :type irq: float\n        :type nice: float\n        :type softIrq: float\n        :type steal: float\n        :type stolen: float\n        :type system: float\n        :type user: float\n        :rtype: CPUStats\n        """\n\n        return CPUStats(\n            guestNice=guestNice,\n            idle=idle,\n            ioWait=ioWait,\n            irq=irq,\n            nice=nice,\n            softIrq=softIrq,\n            steal=steal,\n            stolen=stolen,\n            system=system,\n            user=user,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CPUStats\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'guestNice\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.guestNice = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'idle\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.idle = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ioWait\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.ioWait = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'irq\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.irq = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nice\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.nice = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'softIrq\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.softIrq = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'steal\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.steal = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'stolen\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.stolen = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'system\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.system = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'user\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.user = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'273,    @staticmethod\n    def create(guestNice, idle, ioWait, irq, nice, softIrq, steal, stolen, system, user):\n        """\n        :type guestNice: float\n        :type idle: float\n        :type ioWait: float\n        :type irq: float\n        :type nice: float\n        :type softIrq: float\n        :type steal: float\n        :type stolen: float\n        :type system: float\n        :type user: float\n        :rtype: CPUStats\n        """\n\n        return CPUStats(\n            guestNice=guestNice,\n            idle=idle,\n            ioWait=ioWait,\n            irq=irq,\n            nice=nice,\n            softIrq=softIrq,\n            steal=steal,\n            stolen=stolen,\n            system=system,\n            user=user,\n        )\n'
u"274,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'CPUStats'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'guestNice'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.guestNice = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'idle'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.idle = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'ioWait'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.ioWait = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'irq'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.irq = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nice'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.nice = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'softIrq'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.softIrq = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'steal'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.steal = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'stolen'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.stolen = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'system'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.system = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'user'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.user = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'275,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'276,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'277,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'278,"""\nAuto-generated class for CloudInit\n"""\n\nfrom . import client_support\n\n\nclass CloudInit(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(metadata, userdata):\n        """\n        :type metadata: str\n        :type userdata: str\n        :rtype: CloudInit\n        """\n\n        return CloudInit(\n            metadata=metadata,\n            userdata=userdata,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CloudInit\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'metadata\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.metadata = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'userdata\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.userdata = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'279,class CloudInit(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(metadata, userdata):\n        """\n        :type metadata: str\n        :type userdata: str\n        :rtype: CloudInit\n        """\n\n        return CloudInit(\n            metadata=metadata,\n            userdata=userdata,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CloudInit\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'metadata\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.metadata = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'userdata\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.userdata = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'280,    @staticmethod\n    def create(metadata, userdata):\n        """\n        :type metadata: str\n        :type userdata: str\n        :rtype: CloudInit\n        """\n\n        return CloudInit(\n            metadata=metadata,\n            userdata=userdata,\n        )\n'
u"281,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'CloudInit'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'metadata'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.metadata = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'userdata'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.userdata = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'282,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'283,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'284,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'285,"""\nAuto-generated class for Cluster\n"""\nfrom .EnumClusterDriveType import EnumClusterDriveType\nfrom .EnumClusterStatus import EnumClusterStatus\nfrom .StorageServer import StorageServer\n\nfrom . import client_support\n\n\nclass Cluster(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(dataStorage, driveType, label, metadataStorage, nodes, status):\n        """\n        :type dataStorage: list[StorageServer]\n        :type driveType: EnumClusterDriveType\n        :type label: str\n        :type metadataStorage: list[StorageServer]\n        :type nodes: list[str]\n        :type status: EnumClusterStatus\n        :rtype: Cluster\n        """\n\n        return Cluster(\n            dataStorage=dataStorage,\n            driveType=driveType,\n            label=label,\n            metadataStorage=metadataStorage,\n            nodes=nodes,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Cluster\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'dataStorage\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [StorageServer]\n            try:\n                self.dataStorage = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'driveType\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterDriveType]\n            try:\n                self.driveType = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'label\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.label = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'metadataStorage\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [StorageServer]\n            try:\n                self.metadataStorage = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nodes\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nodes = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'286,class Cluster(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(dataStorage, driveType, label, metadataStorage, nodes, status):\n        """\n        :type dataStorage: list[StorageServer]\n        :type driveType: EnumClusterDriveType\n        :type label: str\n        :type metadataStorage: list[StorageServer]\n        :type nodes: list[str]\n        :type status: EnumClusterStatus\n        :rtype: Cluster\n        """\n\n        return Cluster(\n            dataStorage=dataStorage,\n            driveType=driveType,\n            label=label,\n            metadataStorage=metadataStorage,\n            nodes=nodes,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Cluster\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'dataStorage\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [StorageServer]\n            try:\n                self.dataStorage = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'driveType\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterDriveType]\n            try:\n                self.driveType = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'label\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.label = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'metadataStorage\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [StorageServer]\n            try:\n                self.metadataStorage = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nodes\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nodes = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'287,    @staticmethod\n    def create(dataStorage, driveType, label, metadataStorage, nodes, status):\n        """\n        :type dataStorage: list[StorageServer]\n        :type driveType: EnumClusterDriveType\n        :type label: str\n        :type metadataStorage: list[StorageServer]\n        :type nodes: list[str]\n        :type status: EnumClusterStatus\n        :rtype: Cluster\n        """\n\n        return Cluster(\n            dataStorage=dataStorage,\n            driveType=driveType,\n            label=label,\n            metadataStorage=metadataStorage,\n            nodes=nodes,\n            status=status,\n        )\n'
u"288,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Cluster'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'dataStorage'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [StorageServer]\n            try:\n                self.dataStorage = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'driveType'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterDriveType]\n            try:\n                self.driveType = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'label'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.label = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'metadataStorage'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [StorageServer]\n            try:\n                self.metadataStorage = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nodes'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nodes = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'289,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'290,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'291,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'292,"""\nAuto-generated class for ClusterCreate\n"""\nfrom .EnumClusterCreateClusterType import EnumClusterCreateClusterType\nfrom .EnumClusterCreateDriveType import EnumClusterCreateDriveType\n\nfrom . import client_support\n\n\nclass ClusterCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(clusterType, driveType, label, nodes, servers, k=None, m=None):\n        """\n        :type clusterType: EnumClusterCreateClusterType\n        :type driveType: EnumClusterCreateDriveType\n        :type k: int\n        :type label: str\n        :type m: int\n        :type nodes: list[str]\n        :type servers: int\n        :rtype: ClusterCreate\n        """\n\n        return ClusterCreate(\n            clusterType=clusterType,\n            driveType=driveType,\n            k=k,\n            label=label,\n            m=m,\n            nodes=nodes,\n            servers=servers,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ClusterCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'clusterType\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterCreateClusterType]\n            try:\n                self.clusterType = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'driveType\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterCreateDriveType]\n            try:\n                self.driveType = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'k\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.k = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'label\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.label = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'m\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.m = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'nodes\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nodes = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'servers\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.servers = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'293,class ClusterCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(clusterType, driveType, label, nodes, servers, k=None, m=None):\n        """\n        :type clusterType: EnumClusterCreateClusterType\n        :type driveType: EnumClusterCreateDriveType\n        :type k: int\n        :type label: str\n        :type m: int\n        :type nodes: list[str]\n        :type servers: int\n        :rtype: ClusterCreate\n        """\n\n        return ClusterCreate(\n            clusterType=clusterType,\n            driveType=driveType,\n            k=k,\n            label=label,\n            m=m,\n            nodes=nodes,\n            servers=servers,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ClusterCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'clusterType\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterCreateClusterType]\n            try:\n                self.clusterType = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'driveType\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterCreateDriveType]\n            try:\n                self.driveType = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'k\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.k = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'label\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.label = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'m\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.m = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'nodes\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nodes = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'servers\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.servers = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'294,    @staticmethod\n    def create(clusterType, driveType, label, nodes, servers, k=None, m=None):\n        """\n        :type clusterType: EnumClusterCreateClusterType\n        :type driveType: EnumClusterCreateDriveType\n        :type k: int\n        :type label: str\n        :type m: int\n        :type nodes: list[str]\n        :type servers: int\n        :rtype: ClusterCreate\n        """\n\n        return ClusterCreate(\n            clusterType=clusterType,\n            driveType=driveType,\n            k=k,\n            label=label,\n            m=m,\n            nodes=nodes,\n            servers=servers,\n        )\n'
u"295,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ClusterCreate'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'clusterType'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterCreateClusterType]\n            try:\n                self.clusterType = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'driveType'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumClusterCreateDriveType]\n            try:\n                self.driveType = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'k'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.k = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'label'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.label = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'm'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.m = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'nodes'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nodes = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'servers'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.servers = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'296,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'297,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'298,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'299,"""\nAuto-generated class for Container\n"""\nfrom .ContainerNIC import ContainerNIC\nfrom .CoreSystem import CoreSystem\nfrom .EnumContainerStatus import EnumContainerStatus\n\nfrom . import client_support\n\n\nclass Container(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(filesystems, flist, hostNetworking, hostname, initprocesses, nics, ports, status, storage, zerotiernodeid=None):\n        """\n        :type filesystems: list[str]\n        :type flist: str\n        :type hostNetworking: bool\n        :type hostname: str\n        :type initprocesses: list[CoreSystem]\n        :type nics: list[ContainerNIC]\n        :type ports: list[str]\n        :type status: EnumContainerStatus\n        :type storage: str\n        :type zerotiernodeid: str\n        :rtype: Container\n        """\n\n        return Container(\n            filesystems=filesystems,\n            flist=flist,\n            hostNetworking=hostNetworking,\n            hostname=hostname,\n            initprocesses=initprocesses,\n            nics=nics,\n            ports=ports,\n            status=status,\n            storage=storage,\n            zerotiernodeid=zerotiernodeid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Container\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'filesystems\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.filesystems = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'flist\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flist = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostNetworking\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.hostNetworking = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'initprocesses\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CoreSystem]\n            try:\n                self.initprocesses = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ContainerNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ports\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ports = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'storage\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storage = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'zerotiernodeid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.zerotiernodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'300,class Container(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(filesystems, flist, hostNetworking, hostname, initprocesses, nics, ports, status, storage, zerotiernodeid=None):\n        """\n        :type filesystems: list[str]\n        :type flist: str\n        :type hostNetworking: bool\n        :type hostname: str\n        :type initprocesses: list[CoreSystem]\n        :type nics: list[ContainerNIC]\n        :type ports: list[str]\n        :type status: EnumContainerStatus\n        :type storage: str\n        :type zerotiernodeid: str\n        :rtype: Container\n        """\n\n        return Container(\n            filesystems=filesystems,\n            flist=flist,\n            hostNetworking=hostNetworking,\n            hostname=hostname,\n            initprocesses=initprocesses,\n            nics=nics,\n            ports=ports,\n            status=status,\n            storage=storage,\n            zerotiernodeid=zerotiernodeid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Container\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'filesystems\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.filesystems = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'flist\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flist = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostNetworking\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.hostNetworking = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'initprocesses\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CoreSystem]\n            try:\n                self.initprocesses = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ContainerNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ports\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ports = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'storage\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storage = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'zerotiernodeid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.zerotiernodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'301,    @staticmethod\n    def create(filesystems, flist, hostNetworking, hostname, initprocesses, nics, ports, status, storage, zerotiernodeid=None):\n        """\n        :type filesystems: list[str]\n        :type flist: str\n        :type hostNetworking: bool\n        :type hostname: str\n        :type initprocesses: list[CoreSystem]\n        :type nics: list[ContainerNIC]\n        :type ports: list[str]\n        :type status: EnumContainerStatus\n        :type storage: str\n        :type zerotiernodeid: str\n        :rtype: Container\n        """\n\n        return Container(\n            filesystems=filesystems,\n            flist=flist,\n            hostNetworking=hostNetworking,\n            hostname=hostname,\n            initprocesses=initprocesses,\n            nics=nics,\n            ports=ports,\n            status=status,\n            storage=storage,\n            zerotiernodeid=zerotiernodeid,\n        )\n'
u"302,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Container'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'filesystems'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.filesystems = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'flist'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flist = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'hostNetworking'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.hostNetworking = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'hostname'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'initprocesses'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CoreSystem]\n            try:\n                self.initprocesses = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ContainerNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'ports'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ports = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'storage'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storage = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'zerotiernodeid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.zerotiernodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'303,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'304,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'305,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'306,"""\nAuto-generated class for ContainerListItem\n"""\nfrom .EnumContainerListItemStatus import EnumContainerListItemStatus\n\nfrom . import client_support\n\n\nclass ContainerListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(flist, hostname, name, status):\n        """\n        :type flist: str\n        :type hostname: str\n        :type name: str\n        :type status: EnumContainerListItemStatus\n        :rtype: ContainerListItem\n        """\n\n        return ContainerListItem(\n            flist=flist,\n            hostname=hostname,\n            name=name,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ContainerListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'flist\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flist = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'307,class ContainerListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(flist, hostname, name, status):\n        """\n        :type flist: str\n        :type hostname: str\n        :type name: str\n        :type status: EnumContainerListItemStatus\n        :rtype: ContainerListItem\n        """\n\n        return ContainerListItem(\n            flist=flist,\n            hostname=hostname,\n            name=name,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ContainerListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'flist\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flist = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'308,    @staticmethod\n    def create(flist, hostname, name, status):\n        """\n        :type flist: str\n        :type hostname: str\n        :type name: str\n        :type status: EnumContainerListItemStatus\n        :rtype: ContainerListItem\n        """\n\n        return ContainerListItem(\n            flist=flist,\n            hostname=hostname,\n            name=name,\n            status=status,\n        )\n'
u"309,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ContainerListItem'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'flist'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flist = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'hostname'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'310,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'311,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'312,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'313,"""\nAuto-generated class for ContainerNIC\n"""\nfrom .ContainerNICconfig import ContainerNICconfig\nfrom .EnumContainerNICStatus import EnumContainerNICStatus\nfrom .EnumContainerNICType import EnumContainerNICType\n\nfrom . import client_support\n\n\nclass ContainerNIC(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, status, type, config=None, hwaddr=None, name=None, token=None):\n        """\n        :type config: ContainerNICconfig\n        :type hwaddr: str\n        :type id: str\n        :type name: str\n        :type status: EnumContainerNICStatus\n        :type token: str\n        :type type: EnumContainerNICType\n        :rtype: ContainerNIC\n        """\n\n        return ContainerNIC(\n            config=config,\n            hwaddr=hwaddr,\n            id=id,\n            name=name,\n            status=status,\n            token=token,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ContainerNIC\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'config\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ContainerNICconfig]\n            try:\n                self.config = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'hwaddr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hwaddr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerNICStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'token\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.token = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerNICType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'314,class ContainerNIC(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, status, type, config=None, hwaddr=None, name=None, token=None):\n        """\n        :type config: ContainerNICconfig\n        :type hwaddr: str\n        :type id: str\n        :type name: str\n        :type status: EnumContainerNICStatus\n        :type token: str\n        :type type: EnumContainerNICType\n        :rtype: ContainerNIC\n        """\n\n        return ContainerNIC(\n            config=config,\n            hwaddr=hwaddr,\n            id=id,\n            name=name,\n            status=status,\n            token=token,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ContainerNIC\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'config\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ContainerNICconfig]\n            try:\n                self.config = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'hwaddr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hwaddr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerNICStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'token\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.token = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerNICType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'315,    @staticmethod\n    def create(id, status, type, config=None, hwaddr=None, name=None, token=None):\n        """\n        :type config: ContainerNICconfig\n        :type hwaddr: str\n        :type id: str\n        :type name: str\n        :type status: EnumContainerNICStatus\n        :type token: str\n        :type type: EnumContainerNICType\n        :rtype: ContainerNIC\n        """\n\n        return ContainerNIC(\n            config=config,\n            hwaddr=hwaddr,\n            id=id,\n            name=name,\n            status=status,\n            token=token,\n            type=type,\n        )\n'
u"316,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ContainerNIC'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'config'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ContainerNICconfig]\n            try:\n                self.config = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'hwaddr'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hwaddr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerNICStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'token'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.token = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'type'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumContainerNICType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'317,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'318,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'319,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'320,"""\nAuto-generated class for ContainerNICconfig\n"""\n\nfrom . import client_support\n\n\nclass ContainerNICconfig(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cidr, dhcp, dns=None, gateway=None):\n        """\n        :type cidr: str\n        :type dhcp: bool\n        :type dns: list[str]\n        :type gateway: str\n        :rtype: ContainerNICconfig\n        """\n\n        return ContainerNICconfig(\n            cidr=cidr,\n            dhcp=dhcp,\n            dns=dns,\n            gateway=gateway,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ContainerNICconfig\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cidr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cidr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dhcp\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.dhcp = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dns\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.dns = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'gateway\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.gateway = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'321,class ContainerNICconfig(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cidr, dhcp, dns=None, gateway=None):\n        """\n        :type cidr: str\n        :type dhcp: bool\n        :type dns: list[str]\n        :type gateway: str\n        :rtype: ContainerNICconfig\n        """\n\n        return ContainerNICconfig(\n            cidr=cidr,\n            dhcp=dhcp,\n            dns=dns,\n            gateway=gateway,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ContainerNICconfig\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cidr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cidr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dhcp\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.dhcp = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dns\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.dns = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'gateway\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.gateway = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'322,    @staticmethod\n    def create(cidr, dhcp, dns=None, gateway=None):\n        """\n        :type cidr: str\n        :type dhcp: bool\n        :type dns: list[str]\n        :type gateway: str\n        :rtype: ContainerNICconfig\n        """\n\n        return ContainerNICconfig(\n            cidr=cidr,\n            dhcp=dhcp,\n            dns=dns,\n            gateway=gateway,\n        )\n'
u"323,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ContainerNICconfig'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cidr'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cidr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'dhcp'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.dhcp = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'dns'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.dns = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'gateway'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.gateway = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'324,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'325,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'326,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'327,"""\nAuto-generated class for CoreStateResult\n"""\n\nfrom . import client_support\n\n\nclass CoreStateResult(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, rss, swap, vms):\n        """\n        :type cpu: float\n        :type rss: int\n        :type swap: int\n        :type vms: int\n        :rtype: CoreStateResult\n        """\n\n        return CoreStateResult(\n            cpu=cpu,\n            rss=rss,\n            swap=swap,\n            vms=vms,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CoreStateResult\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'rss\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.rss = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'swap\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.swap = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'vms\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.vms = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'328,class CoreStateResult(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, rss, swap, vms):\n        """\n        :type cpu: float\n        :type rss: int\n        :type swap: int\n        :type vms: int\n        :rtype: CoreStateResult\n        """\n\n        return CoreStateResult(\n            cpu=cpu,\n            rss=rss,\n            swap=swap,\n            vms=vms,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CoreStateResult\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'rss\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.rss = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'swap\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.swap = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'vms\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.vms = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'329,    @staticmethod\n    def create(cpu, rss, swap, vms):\n        """\n        :type cpu: float\n        :type rss: int\n        :type swap: int\n        :type vms: int\n        :rtype: CoreStateResult\n        """\n\n        return CoreStateResult(\n            cpu=cpu,\n            rss=rss,\n            swap=swap,\n            vms=vms,\n        )\n'
u"330,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'CoreStateResult'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cpu'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'rss'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.rss = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'swap'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.swap = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'vms'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.vms = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'331,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'332,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'333,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'334,"""\nAuto-generated class for CoreSystem\n"""\n\nfrom . import client_support\n\n\nclass CoreSystem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, args=None, environment=None, pwd=None, stdin=None):\n        """\n        :type args: list[str]\n        :type environment: list[str]\n        :type name: str\n        :type pwd: str\n        :type stdin: str\n        :rtype: CoreSystem\n        """\n\n        return CoreSystem(\n            args=args,\n            environment=environment,\n            name=name,\n            pwd=pwd,\n            stdin=stdin,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CoreSystem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'args\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.args = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'environment\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.environment = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'pwd\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.pwd = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'stdin\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.stdin = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'335,class CoreSystem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, args=None, environment=None, pwd=None, stdin=None):\n        """\n        :type args: list[str]\n        :type environment: list[str]\n        :type name: str\n        :type pwd: str\n        :type stdin: str\n        :rtype: CoreSystem\n        """\n\n        return CoreSystem(\n            args=args,\n            environment=environment,\n            name=name,\n            pwd=pwd,\n            stdin=stdin,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CoreSystem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'args\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.args = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'environment\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.environment = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'pwd\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.pwd = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'stdin\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.stdin = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'336,    @staticmethod\n    def create(name, args=None, environment=None, pwd=None, stdin=None):\n        """\n        :type args: list[str]\n        :type environment: list[str]\n        :type name: str\n        :type pwd: str\n        :type stdin: str\n        :rtype: CoreSystem\n        """\n\n        return CoreSystem(\n            args=args,\n            environment=environment,\n            name=name,\n            pwd=pwd,\n            stdin=stdin,\n        )\n'
u"337,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'CoreSystem'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'args'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.args = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'environment'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.environment = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'pwd'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.pwd = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'stdin'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.stdin = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'338,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'339,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'340,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'341,"""\nAuto-generated class for CreateContainer\n"""\nfrom .ContainerNIC import ContainerNIC\nfrom .CoreSystem import CoreSystem\n\nfrom . import client_support\n\n\nclass CreateContainer(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(flist, hostNetworking, hostname, name, filesystems=None, initProcesses=None, nics=None, ports=None, storage=None):\n        """\n        :type filesystems: list[str]\n        :type flist: str\n        :type hostNetworking: bool\n        :type hostname: str\n        :type initProcesses: list[CoreSystem]\n        :type name: str\n        :type nics: list[ContainerNIC]\n        :type ports: list[str]\n        :type storage: str\n        :rtype: CreateContainer\n        """\n\n        return CreateContainer(\n            filesystems=filesystems,\n            flist=flist,\n            hostNetworking=hostNetworking,\n            hostname=hostname,\n            initProcesses=initProcesses,\n            name=name,\n            nics=nics,\n            ports=ports,\n            storage=storage,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CreateContainer\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'filesystems\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.filesystems = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'flist\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flist = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostNetworking\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.hostNetworking = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'initProcesses\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CoreSystem]\n            try:\n                self.initProcesses = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ContainerNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'ports\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ports = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'storage\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storage = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'342,class CreateContainer(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(flist, hostNetworking, hostname, name, filesystems=None, initProcesses=None, nics=None, ports=None, storage=None):\n        """\n        :type filesystems: list[str]\n        :type flist: str\n        :type hostNetworking: bool\n        :type hostname: str\n        :type initProcesses: list[CoreSystem]\n        :type name: str\n        :type nics: list[ContainerNIC]\n        :type ports: list[str]\n        :type storage: str\n        :rtype: CreateContainer\n        """\n\n        return CreateContainer(\n            filesystems=filesystems,\n            flist=flist,\n            hostNetworking=hostNetworking,\n            hostname=hostname,\n            initProcesses=initProcesses,\n            name=name,\n            nics=nics,\n            ports=ports,\n            storage=storage,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CreateContainer\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'filesystems\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.filesystems = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'flist\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flist = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostNetworking\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.hostNetworking = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'initProcesses\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CoreSystem]\n            try:\n                self.initProcesses = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ContainerNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'ports\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ports = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'storage\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storage = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'343,    @staticmethod\n    def create(flist, hostNetworking, hostname, name, filesystems=None, initProcesses=None, nics=None, ports=None, storage=None):\n        """\n        :type filesystems: list[str]\n        :type flist: str\n        :type hostNetworking: bool\n        :type hostname: str\n        :type initProcesses: list[CoreSystem]\n        :type name: str\n        :type nics: list[ContainerNIC]\n        :type ports: list[str]\n        :type storage: str\n        :rtype: CreateContainer\n        """\n\n        return CreateContainer(\n            filesystems=filesystems,\n            flist=flist,\n            hostNetworking=hostNetworking,\n            hostname=hostname,\n            initProcesses=initProcesses,\n            name=name,\n            nics=nics,\n            ports=ports,\n            storage=storage,\n        )\n'
u"344,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'CreateContainer'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'filesystems'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.filesystems = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'flist'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flist = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'hostNetworking'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.hostNetworking = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'hostname'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'initProcesses'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CoreSystem]\n            try:\n                self.initProcesses = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ContainerNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'ports'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ports = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'storage'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storage = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'345,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'346,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'347,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'348,"""\nAuto-generated class for CreateSnapshotReqBody\n"""\n\nfrom . import client_support\n\n\nclass CreateSnapshotReqBody(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name):\n        """\n        :type name: str\n        :rtype: CreateSnapshotReqBody\n        """\n\n        return CreateSnapshotReqBody(\n            name=name,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CreateSnapshotReqBody\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'349,class CreateSnapshotReqBody(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name):\n        """\n        :type name: str\n        :rtype: CreateSnapshotReqBody\n        """\n\n        return CreateSnapshotReqBody(\n            name=name,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'CreateSnapshotReqBody\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'350,    @staticmethod\n    def create(name):\n        """\n        :type name: str\n        :rtype: CreateSnapshotReqBody\n        """\n\n        return CreateSnapshotReqBody(\n            name=name,\n        )\n'
u"351,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'CreateSnapshotReqBody'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'352,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'353,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'354,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'355,"""\nAuto-generated class for DHCP\n"""\nfrom .GWHost import GWHost\n\nfrom . import client_support\n\n\nclass DHCP(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(hosts, nameservers=None):\n        """\n        :type hosts: list[GWHost]\n        :type nameservers: list[str]\n        :rtype: DHCP\n        """\n\n        return DHCP(\n            hosts=hosts,\n            nameservers=nameservers,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'DHCP\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'hosts\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWHost]\n            try:\n                self.hosts = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nameservers\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nameservers = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'356,class DHCP(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(hosts, nameservers=None):\n        """\n        :type hosts: list[GWHost]\n        :type nameservers: list[str]\n        :rtype: DHCP\n        """\n\n        return DHCP(\n            hosts=hosts,\n            nameservers=nameservers,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'DHCP\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'hosts\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWHost]\n            try:\n                self.hosts = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nameservers\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nameservers = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'357,    @staticmethod\n    def create(hosts, nameservers=None):\n        """\n        :type hosts: list[GWHost]\n        :type nameservers: list[str]\n        :rtype: DHCP\n        """\n\n        return DHCP(\n            hosts=hosts,\n            nameservers=nameservers,\n        )\n'
u"358,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'DHCP'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'hosts'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWHost]\n            try:\n                self.hosts = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nameservers'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nameservers = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'359,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'360,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'361,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'362,"""\nAuto-generated class for DeleteFile\n"""\n\nfrom . import client_support\n\n\nclass DeleteFile(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(path):\n        """\n        :type path: str\n        :rtype: DeleteFile\n        """\n\n        return DeleteFile(\n            path=path,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'DeleteFile\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'path\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.path = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'363,class DeleteFile(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(path):\n        """\n        :type path: str\n        :rtype: DeleteFile\n        """\n\n        return DeleteFile(\n            path=path,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'DeleteFile\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'path\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.path = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'364,    @staticmethod\n    def create(path):\n        """\n        :type path: str\n        :rtype: DeleteFile\n        """\n\n        return DeleteFile(\n            path=path,\n        )\n'
u"365,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'DeleteFile'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'path'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.path = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'366,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'367,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'368,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'369,"""\nAuto-generated class for DiskInfo\n"""\nfrom .DiskPartition import DiskPartition\nfrom .EnumDiskInfoType import EnumDiskInfoType\n\nfrom . import client_support\n\n\nclass DiskInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(device, partitions, size, type):\n        """\n        :type device: str\n        :type partitions: list[DiskPartition]\n        :type size: int\n        :type type: EnumDiskInfoType\n        :rtype: DiskInfo\n        """\n\n        return DiskInfo(\n            device=device,\n            partitions=partitions,\n            size=size,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'DiskInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'device\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.device = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'partitions\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [DiskPartition]\n            try:\n                self.partitions = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'size\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumDiskInfoType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'370,class DiskInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(device, partitions, size, type):\n        """\n        :type device: str\n        :type partitions: list[DiskPartition]\n        :type size: int\n        :type type: EnumDiskInfoType\n        :rtype: DiskInfo\n        """\n\n        return DiskInfo(\n            device=device,\n            partitions=partitions,\n            size=size,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'DiskInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'device\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.device = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'partitions\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [DiskPartition]\n            try:\n                self.partitions = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'size\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumDiskInfoType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'371,    @staticmethod\n    def create(device, partitions, size, type):\n        """\n        :type device: str\n        :type partitions: list[DiskPartition]\n        :type size: int\n        :type type: EnumDiskInfoType\n        :rtype: DiskInfo\n        """\n\n        return DiskInfo(\n            device=device,\n            partitions=partitions,\n            size=size,\n            type=type,\n        )\n'
u"372,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'DiskInfo'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'device'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.device = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'partitions'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [DiskPartition]\n            try:\n                self.partitions = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'size'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'type'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumDiskInfoType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'373,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'374,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'375,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'376,"""\nAuto-generated class for DiskPartition\n"""\n\nfrom . import client_support\n\n\nclass DiskPartition(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(fstype, label, name, partuuid, size):\n        """\n        :type fstype: str\n        :type label: str\n        :type name: str\n        :type partuuid: str\n        :type size: int\n        :rtype: DiskPartition\n        """\n\n        return DiskPartition(\n            fstype=fstype,\n            label=label,\n            name=name,\n            partuuid=partuuid,\n            size=size,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'DiskPartition\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'fstype\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.fstype = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'label\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.label = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'partuuid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.partuuid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'size\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'377,class DiskPartition(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(fstype, label, name, partuuid, size):\n        """\n        :type fstype: str\n        :type label: str\n        :type name: str\n        :type partuuid: str\n        :type size: int\n        :rtype: DiskPartition\n        """\n\n        return DiskPartition(\n            fstype=fstype,\n            label=label,\n            name=name,\n            partuuid=partuuid,\n            size=size,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'DiskPartition\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'fstype\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.fstype = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'label\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.label = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'partuuid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.partuuid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'size\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'378,    @staticmethod\n    def create(fstype, label, name, partuuid, size):\n        """\n        :type fstype: str\n        :type label: str\n        :type name: str\n        :type partuuid: str\n        :type size: int\n        :rtype: DiskPartition\n        """\n\n        return DiskPartition(\n            fstype=fstype,\n            label=label,\n            name=name,\n            partuuid=partuuid,\n            size=size,\n        )\n'
u"379,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'DiskPartition'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'fstype'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.fstype = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'label'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.label = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'partuuid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.partuuid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'size'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'380,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'381,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'382,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'383,from enum import Enum\n\n\nclass EnumBridgeCreateNetworkMode(Enum):\n    none = "none"\n    static = "static"\n    dnsmasq = "dnsmasq"\n'
u'384,class EnumBridgeCreateNetworkMode(Enum):\n    none = "none"\n    static = "static"\n    dnsmasq = "dnsmasq"\n'
u'385,from enum import Enum\n\n\nclass EnumBridgeStatus(Enum):\n    up = "up"\n    down = "down"\n'
u'386,class EnumBridgeStatus(Enum):\n    up = "up"\n    down = "down"\n'
u'387,from enum import Enum\n\n\nclass EnumClusterCreateClusterType(Enum):\n    storage = "storage"\n    tlog = "tlog"\n'
u'388,class EnumClusterCreateClusterType(Enum):\n    storage = "storage"\n    tlog = "tlog"\n'
u'389,from enum import Enum\n\n\nclass EnumClusterCreateDriveType(Enum):\n    nvme = "nvme"\n    ssd = "ssd"\n    hdd = "hdd"\n    archive = "archive"\n'
u'390,class EnumClusterCreateDriveType(Enum):\n    nvme = "nvme"\n    ssd = "ssd"\n    hdd = "hdd"\n    archive = "archive"\n'
u'391,from enum import Enum\n\n\nclass EnumClusterDriveType(Enum):\n    nvme = "nvme"\n    ssd = "ssd"\n    hdd = "hdd"\n    archive = "archive"\n'
u'392,class EnumClusterDriveType(Enum):\n    nvme = "nvme"\n    ssd = "ssd"\n    hdd = "hdd"\n    archive = "archive"\n'
u'393,from enum import Enum\n\n\nclass EnumClusterStatus(Enum):\n    empty = "empty"\n    deploying = "deploying"\n    ready = "ready"\n    error = "error"\n'
u'394,class EnumClusterStatus(Enum):\n    empty = "empty"\n    deploying = "deploying"\n    ready = "ready"\n    error = "error"\n'
u'395,from enum import Enum\n\n\nclass EnumContainerListItemStatus(Enum):\n    running = "running"\n    halted = "halted"\n'
u'396,class EnumContainerListItemStatus(Enum):\n    running = "running"\n    halted = "halted"\n'
u'397,from enum import Enum\n\n\nclass EnumContainerNICStatus(Enum):\n    up = "up"\n    down = "down"\n'
u'398,class EnumContainerNICStatus(Enum):\n    up = "up"\n    down = "down"\n'
u'399,from enum import Enum\n\n\nclass EnumContainerNICType(Enum):\n    zerotier = "zerotier"\n    vxlan = "vxlan"\n    vlan = "vlan"\n    default = "default"\n    bridge = "bridge"\n'
u'400,class EnumContainerNICType(Enum):\n    zerotier = "zerotier"\n    vxlan = "vxlan"\n    vlan = "vlan"\n    default = "default"\n    bridge = "bridge"\n'
u'401,from enum import Enum\n\n\nclass EnumContainerStatus(Enum):\n    running = "running"\n    halted = "halted"\n'
u'402,class EnumContainerStatus(Enum):\n    running = "running"\n    halted = "halted"\n'
u'403,from enum import Enum\n\n\nclass EnumDiskInfoType(Enum):\n    ssd = "ssd"\n    nvme = "nvme"\n    hdd = "hdd"\n    archive = "archive"\n'
u'404,class EnumDiskInfoType(Enum):\n    ssd = "ssd"\n    nvme = "nvme"\n    hdd = "hdd"\n    archive = "archive"\n'
u'405,from enum import Enum\n\n\nclass EnumGWNICType(Enum):\n    zerotier = "zerotier"\n    vxlan = "vxlan"\n    vlan = "vlan"\n    default = "default"\n    bridge = "bridge"\n'
u'406,class EnumGWNICType(Enum):\n    zerotier = "zerotier"\n    vxlan = "vxlan"\n    vlan = "vlan"\n    default = "default"\n    bridge = "bridge"\n'
u'407,from enum import Enum\n\n\nclass EnumJobResultName(Enum):\n    core_ping = "core.ping"\n    core_system = "core.system"\n    core_kill = "core.kill"\n    core_killall = "core.killall"\n    core_state = "core.state"\n    core_reboot = "core.reboot"\n    info_cpu = "info.cpu"\n    info_disk = "info.disk"\n    info_mem = "info.mem"\n    info_nic = "info.nic"\n    info_os = "info.os"\n    container_create = "container.create"\n    container_list = "container.list"\n    container_dispatch = "container.dispatch"\n    container_terminate = "container.terminate"\n    bridge_create = "bridge.create"\n    bridge_list = "bridge.list"\n    bridge_delete = "bridge.delete"\n    disk_list = "disk.list"\n    disk_mktable = "disk.mktable"\n    disk_mkpart = "disk.mkpart"\n    disk_rmpart = "disk.rmpart"\n    disk_mount = "disk.mount"\n    disk_umount = "disk.umount"\n    btrfs_create = "btrfs.create"\n    btrfs_list = "btrfs.list"\n    btrfs_subvol_create = "btrfs.subvol_create"\n    btrfs_subvol_list = "btrfs.subvol_list"\n    btrfs_subvol_delete = "btrfs.subvol_delete"\n'
u'408,class EnumJobResultName(Enum):\n    core_ping = "core.ping"\n    core_system = "core.system"\n    core_kill = "core.kill"\n    core_killall = "core.killall"\n    core_state = "core.state"\n    core_reboot = "core.reboot"\n    info_cpu = "info.cpu"\n    info_disk = "info.disk"\n    info_mem = "info.mem"\n    info_nic = "info.nic"\n    info_os = "info.os"\n    container_create = "container.create"\n    container_list = "container.list"\n    container_dispatch = "container.dispatch"\n    container_terminate = "container.terminate"\n    bridge_create = "bridge.create"\n    bridge_list = "bridge.list"\n    bridge_delete = "bridge.delete"\n    disk_list = "disk.list"\n    disk_mktable = "disk.mktable"\n    disk_mkpart = "disk.mkpart"\n    disk_rmpart = "disk.rmpart"\n    disk_mount = "disk.mount"\n    disk_umount = "disk.umount"\n    btrfs_create = "btrfs.create"\n    btrfs_list = "btrfs.list"\n    btrfs_subvol_create = "btrfs.subvol_create"\n    btrfs_subvol_list = "btrfs.subvol_list"\n    btrfs_subvol_delete = "btrfs.subvol_delete"\n'
u'409,from enum import Enum\n\n\nclass EnumJobResultState(Enum):\n    unknown_cmd = "unknown_cmd"\n    error = "error"\n    success = "success"\n    killed = "killed"\n    timeout = "timeout"\n    duplicate_id = "duplicate_id"\n    running = "running"\n'
u'410,class EnumJobResultState(Enum):\n    unknown_cmd = "unknown_cmd"\n    error = "error"\n    success = "success"\n    killed = "killed"\n    timeout = "timeout"\n    duplicate_id = "duplicate_id"\n    running = "running"\n'
u'411,from enum import Enum\n\n\nclass EnumNicLinkType(Enum):\n    vlan = "vlan"\n    vxlan = "vxlan"\n    default = "default"\n    bridge = "bridge"\n'
u'412,class EnumNicLinkType(Enum):\n    vlan = "vlan"\n    vxlan = "vxlan"\n    default = "default"\n    bridge = "bridge"\n'
u'413,from enum import Enum\n\n\nclass EnumNodeStatus(Enum):\n    running = "running"\n    halted = "halted"\n'
u'414,class EnumNodeStatus(Enum):\n    running = "running"\n    halted = "halted"\n'
u'415,from enum import Enum\n\n\nclass EnumStoragePoolCreateDataProfile(Enum):\n    raid0 = "raid0"\n    raid1 = "raid1"\n    raid5 = "raid5"\n    raid6 = "raid6"\n    raid10 = "raid10"\n    dup = "dup"\n    single = "single"\n'
u'416,class EnumStoragePoolCreateDataProfile(Enum):\n    raid0 = "raid0"\n    raid1 = "raid1"\n    raid5 = "raid5"\n    raid6 = "raid6"\n    raid10 = "raid10"\n    dup = "dup"\n    single = "single"\n'
u'417,from enum import Enum\n\n\nclass EnumStoragePoolCreateMetadataProfile(Enum):\n    raid0 = "raid0"\n    raid1 = "raid1"\n    raid5 = "raid5"\n    raid6 = "raid6"\n    raid10 = "raid10"\n    dup = "dup"\n    single = "single"\n'
u'418,class EnumStoragePoolCreateMetadataProfile(Enum):\n    raid0 = "raid0"\n    raid1 = "raid1"\n    raid5 = "raid5"\n    raid6 = "raid6"\n    raid10 = "raid10"\n    dup = "dup"\n    single = "single"\n'
u'419,from enum import Enum\n\n\nclass EnumStoragePoolDataProfile(Enum):\n    raid0 = "raid0"\n    raid1 = "raid1"\n    raid5 = "raid5"\n    raid6 = "raid6"\n    raid10 = "raid10"\n    dup = "dup"\n    single = "single"\n'
u'420,class EnumStoragePoolDataProfile(Enum):\n    raid0 = "raid0"\n    raid1 = "raid1"\n    raid5 = "raid5"\n    raid6 = "raid6"\n    raid10 = "raid10"\n    dup = "dup"\n    single = "single"\n'
u'421,from enum import Enum\n\n\nclass EnumStoragePoolDeviceStatus(Enum):\n    healthy = "healthy"\n    removing = "removing"\n'
u'422,class EnumStoragePoolDeviceStatus(Enum):\n    healthy = "healthy"\n    removing = "removing"\n'
u'423,from enum import Enum\n\n\nclass EnumStoragePoolListItemStatus(Enum):\n    healthy = "healthy"\n    degraded = "degraded"\n    error = "error"\n    unknown = "unknown"\n'
u'424,class EnumStoragePoolListItemStatus(Enum):\n    healthy = "healthy"\n    degraded = "degraded"\n    error = "error"\n    unknown = "unknown"\n'
u'425,from enum import Enum\n\n\nclass EnumStoragePoolMetadataProfile(Enum):\n    raid0 = "raid0"\n    raid1 = "raid1"\n    raid5 = "raid5"\n    raid6 = "raid6"\n    raid10 = "raid10"\n    dup = "dup"\n    single = "single"\n'
u'426,class EnumStoragePoolMetadataProfile(Enum):\n    raid0 = "raid0"\n    raid1 = "raid1"\n    raid5 = "raid5"\n    raid6 = "raid6"\n    raid10 = "raid10"\n    dup = "dup"\n    single = "single"\n'
u'427,from enum import Enum\n\n\nclass EnumStoragePoolStatus(Enum):\n    healthy = "healthy"\n    degraded = "degraded"\n    error = "error"\n    unknown = "unknown"\n'
u'428,class EnumStoragePoolStatus(Enum):\n    healthy = "healthy"\n    degraded = "degraded"\n    error = "error"\n    unknown = "unknown"\n'
u'429,from enum import Enum\n\n\nclass EnumStorageServerStatus(Enum):\n    ready = "ready"\n    error = "error"\n'
u'430,class EnumStorageServerStatus(Enum):\n    ready = "ready"\n    error = "error"\n'
u'431,from enum import Enum\n\n\nclass EnumVMListItemStatus(Enum):\n    deploying = "deploying"\n    running = "running"\n    halted = "halted"\n    paused = "paused"\n    halting = "halting"\n    migrating = "migrating"\n    starting = "starting"\n    error = "error"\n'
u'432,class EnumVMListItemStatus(Enum):\n    deploying = "deploying"\n    running = "running"\n    halted = "halted"\n    paused = "paused"\n    halting = "halting"\n    migrating = "migrating"\n    starting = "starting"\n    error = "error"\n'
u'433,from enum import Enum\n\n\nclass EnumVMStatus(Enum):\n    deploying = "deploying"\n    running = "running"\n    halted = "halted"\n    paused = "paused"\n    halting = "halting"\n    migrating = "migrating"\n    starting = "starting"\n    error = "error"\n'
u'434,class EnumVMStatus(Enum):\n    deploying = "deploying"\n    running = "running"\n    halted = "halted"\n    paused = "paused"\n    halting = "halting"\n    migrating = "migrating"\n    starting = "starting"\n    error = "error"\n'
u'435,from enum import Enum\n\n\nclass EnumVdiskCreateType(Enum):\n    boot = "boot"\n    db = "db"\n    cache = "cache"\n    tmp = "tmp"\n'
u'436,class EnumVdiskCreateType(Enum):\n    boot = "boot"\n    db = "db"\n    cache = "cache"\n    tmp = "tmp"\n'
u'437,from enum import Enum\n\n\nclass EnumVdiskListItemStatus(Enum):\n    running = "running"\n    halted = "halted"\n    rollingback = "rollingback"\n'
u'438,class EnumVdiskListItemStatus(Enum):\n    running = "running"\n    halted = "halted"\n    rollingback = "rollingback"\n'
u'439,from enum import Enum\n\n\nclass EnumVdiskListItemType(Enum):\n    boot = "boot"\n    db = "db"\n    cache = "cache"\n    tmp = "tmp"\n'
u'440,class EnumVdiskListItemType(Enum):\n    boot = "boot"\n    db = "db"\n    cache = "cache"\n    tmp = "tmp"\n'
u'441,from enum import Enum\n\n\nclass EnumVdiskStatus(Enum):\n    running = "running"\n    halted = "halted"\n    rollingback = "rollingback"\n'
u'442,class EnumVdiskStatus(Enum):\n    running = "running"\n    halted = "halted"\n    rollingback = "rollingback"\n'
u'443,from enum import Enum\n\n\nclass EnumVdiskType(Enum):\n    boot = "boot"\n    db = "db"\n    cache = "cache"\n    tmp = "tmp"\n'
u'444,class EnumVdiskType(Enum):\n    boot = "boot"\n    db = "db"\n    cache = "cache"\n    tmp = "tmp"\n'
u'445,from enum import Enum\n\n\nclass EnumZerotierListItemType(Enum):\n    public = "public"\n    private = "private"\n'
u'446,class EnumZerotierListItemType(Enum):\n    public = "public"\n    private = "private"\n'
u'447,from enum import Enum\n\n\nclass EnumZerotierType(Enum):\n    public = "public"\n    private = "private"\n'
u'448,class EnumZerotierType(Enum):\n    public = "public"\n    private = "private"\n'
u'449,"""\nAuto-generated class for Filesystem\n"""\n\nfrom . import client_support\n\n\nclass Filesystem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(mountpoint, name, parent, quota, readOnly, sizeOnDisk):\n        """\n        :type mountpoint: str\n        :type name: str\n        :type parent: str\n        :type quota: int\n        :type readOnly: bool\n        :type sizeOnDisk: int\n        :rtype: Filesystem\n        """\n\n        return Filesystem(\n            mountpoint=mountpoint,\n            name=name,\n            parent=parent,\n            quota=quota,\n            readOnly=readOnly,\n            sizeOnDisk=sizeOnDisk,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Filesystem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'mountpoint\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mountpoint = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'parent\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.parent = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'quota\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.quota = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readOnly\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'sizeOnDisk\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.sizeOnDisk = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'450,class Filesystem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(mountpoint, name, parent, quota, readOnly, sizeOnDisk):\n        """\n        :type mountpoint: str\n        :type name: str\n        :type parent: str\n        :type quota: int\n        :type readOnly: bool\n        :type sizeOnDisk: int\n        :rtype: Filesystem\n        """\n\n        return Filesystem(\n            mountpoint=mountpoint,\n            name=name,\n            parent=parent,\n            quota=quota,\n            readOnly=readOnly,\n            sizeOnDisk=sizeOnDisk,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Filesystem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'mountpoint\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mountpoint = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'parent\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.parent = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'quota\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.quota = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readOnly\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'sizeOnDisk\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.sizeOnDisk = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'451,    @staticmethod\n    def create(mountpoint, name, parent, quota, readOnly, sizeOnDisk):\n        """\n        :type mountpoint: str\n        :type name: str\n        :type parent: str\n        :type quota: int\n        :type readOnly: bool\n        :type sizeOnDisk: int\n        :rtype: Filesystem\n        """\n\n        return Filesystem(\n            mountpoint=mountpoint,\n            name=name,\n            parent=parent,\n            quota=quota,\n            readOnly=readOnly,\n            sizeOnDisk=sizeOnDisk,\n        )\n'
u"452,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Filesystem'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'mountpoint'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mountpoint = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'parent'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.parent = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'quota'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.quota = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'readOnly'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'sizeOnDisk'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.sizeOnDisk = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'453,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'454,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'455,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'456,"""\nAuto-generated class for FilesystemCreate\n"""\n\nfrom . import client_support\n\n\nclass FilesystemCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, quota, readOnly):\n        """\n        :type name: str\n        :type quota: int\n        :type readOnly: bool\n        :rtype: FilesystemCreate\n        """\n\n        return FilesystemCreate(\n            name=name,\n            quota=quota,\n            readOnly=readOnly,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'FilesystemCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'quota\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.quota = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readOnly\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'457,class FilesystemCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, quota, readOnly):\n        """\n        :type name: str\n        :type quota: int\n        :type readOnly: bool\n        :rtype: FilesystemCreate\n        """\n\n        return FilesystemCreate(\n            name=name,\n            quota=quota,\n            readOnly=readOnly,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'FilesystemCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'quota\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.quota = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readOnly\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'458,    @staticmethod\n    def create(name, quota, readOnly):\n        """\n        :type name: str\n        :type quota: int\n        :type readOnly: bool\n        :rtype: FilesystemCreate\n        """\n\n        return FilesystemCreate(\n            name=name,\n            quota=quota,\n            readOnly=readOnly,\n        )\n'
u"459,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'FilesystemCreate'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'quota'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.quota = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'readOnly'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'460,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'461,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'462,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'463,"""\nAuto-generated class for GW\n"""\nfrom .GWNIC import GWNIC\nfrom .HTTPProxy import HTTPProxy\nfrom .PortForward import PortForward\n\nfrom . import client_support\n\n\nclass GW(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(domain, nics, httpproxies=None, portforwards=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :rtype: GW\n        """\n\n        return GW(\n            domain=domain,\n            httpproxies=httpproxies,\n            nics=nics,\n            portforwards=portforwards,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GW\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'domain\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'httpproxies\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portforwards\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'464,class GW(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(domain, nics, httpproxies=None, portforwards=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :rtype: GW\n        """\n\n        return GW(\n            domain=domain,\n            httpproxies=httpproxies,\n            nics=nics,\n            portforwards=portforwards,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GW\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'domain\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'httpproxies\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portforwards\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'465,    @staticmethod\n    def create(domain, nics, httpproxies=None, portforwards=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :rtype: GW\n        """\n\n        return GW(\n            domain=domain,\n            httpproxies=httpproxies,\n            nics=nics,\n            portforwards=portforwards,\n        )\n'
u"466,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'GW'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'domain'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'httpproxies'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'portforwards'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'467,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'468,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'469,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'470,"""\nAuto-generated class for GWCreate\n"""\nfrom .GWNIC import GWNIC\nfrom .HTTPProxy import HTTPProxy\nfrom .PortForward import PortForward\n\nfrom . import client_support\n\n\nclass GWCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(domain, name, nics, httpproxies=None, portforwards=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type name: str\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :rtype: GWCreate\n        """\n\n        return GWCreate(\n            domain=domain,\n            httpproxies=httpproxies,\n            name=name,\n            nics=nics,\n            portforwards=portforwards,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GWCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'domain\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'httpproxies\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portforwards\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'471,class GWCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(domain, name, nics, httpproxies=None, portforwards=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type name: str\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :rtype: GWCreate\n        """\n\n        return GWCreate(\n            domain=domain,\n            httpproxies=httpproxies,\n            name=name,\n            nics=nics,\n            portforwards=portforwards,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GWCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'domain\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'httpproxies\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portforwards\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'472,    @staticmethod\n    def create(domain, name, nics, httpproxies=None, portforwards=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type name: str\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :rtype: GWCreate\n        """\n\n        return GWCreate(\n            domain=domain,\n            httpproxies=httpproxies,\n            name=name,\n            nics=nics,\n            portforwards=portforwards,\n        )\n'
u"473,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'GWCreate'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'domain'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'httpproxies'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'portforwards'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'474,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'475,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'476,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'477,"""\nAuto-generated class for GWHost\n"""\nfrom .CloudInit import CloudInit\n\nfrom . import client_support\n\n\nclass GWHost(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(hostname, ipaddress, macaddress, cloudinit=None, ip6address=None):\n        """\n        :type cloudinit: CloudInit\n        :type hostname: str\n        :type ip6address: str\n        :type ipaddress: str\n        :type macaddress: str\n        :rtype: GWHost\n        """\n\n        return GWHost(\n            cloudinit=cloudinit,\n            hostname=hostname,\n            ip6address=ip6address,\n            ipaddress=ipaddress,\n            macaddress=macaddress,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GWHost\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cloudinit\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CloudInit]\n            try:\n                self.cloudinit = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ip6address\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ip6address = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'ipaddress\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ipaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'macaddress\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.macaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'478,class GWHost(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(hostname, ipaddress, macaddress, cloudinit=None, ip6address=None):\n        """\n        :type cloudinit: CloudInit\n        :type hostname: str\n        :type ip6address: str\n        :type ipaddress: str\n        :type macaddress: str\n        :rtype: GWHost\n        """\n\n        return GWHost(\n            cloudinit=cloudinit,\n            hostname=hostname,\n            ip6address=ip6address,\n            ipaddress=ipaddress,\n            macaddress=macaddress,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GWHost\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cloudinit\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CloudInit]\n            try:\n                self.cloudinit = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ip6address\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ip6address = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'ipaddress\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ipaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'macaddress\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.macaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'479,    @staticmethod\n    def create(hostname, ipaddress, macaddress, cloudinit=None, ip6address=None):\n        """\n        :type cloudinit: CloudInit\n        :type hostname: str\n        :type ip6address: str\n        :type ipaddress: str\n        :type macaddress: str\n        :rtype: GWHost\n        """\n\n        return GWHost(\n            cloudinit=cloudinit,\n            hostname=hostname,\n            ip6address=ip6address,\n            ipaddress=ipaddress,\n            macaddress=macaddress,\n        )\n'
u"480,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'GWHost'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cloudinit'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CloudInit]\n            try:\n                self.cloudinit = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'hostname'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'ip6address'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ip6address = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'ipaddress'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ipaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'macaddress'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.macaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'481,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'482,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'483,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'484,"""\nAuto-generated class for GWNIC\n"""\nfrom .DHCP import DHCP\nfrom .EnumGWNICType import EnumGWNICType\nfrom .GWNICconfig import GWNICconfig\nfrom .ZerotierBridge import ZerotierBridge\n\nfrom . import client_support\n\n\nclass GWNIC(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, name, type, config=None, dhcpserver=None, zerotierbridge=None):\n        """\n        :type config: GWNICconfig\n        :type dhcpserver: DHCP\n        :type id: str\n        :type name: str\n        :type type: EnumGWNICType\n        :type zerotierbridge: ZerotierBridge\n        :rtype: GWNIC\n        """\n\n        return GWNIC(\n            config=config,\n            dhcpserver=dhcpserver,\n            id=id,\n            name=name,\n            type=type,\n            zerotierbridge=zerotierbridge,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GWNIC\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'config\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNICconfig]\n            try:\n                self.config = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'dhcpserver\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [DHCP]\n            try:\n                self.dhcpserver = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumGWNICType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'zerotierbridge\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ZerotierBridge]\n            try:\n                self.zerotierbridge = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'485,class GWNIC(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, name, type, config=None, dhcpserver=None, zerotierbridge=None):\n        """\n        :type config: GWNICconfig\n        :type dhcpserver: DHCP\n        :type id: str\n        :type name: str\n        :type type: EnumGWNICType\n        :type zerotierbridge: ZerotierBridge\n        :rtype: GWNIC\n        """\n\n        return GWNIC(\n            config=config,\n            dhcpserver=dhcpserver,\n            id=id,\n            name=name,\n            type=type,\n            zerotierbridge=zerotierbridge,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GWNIC\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'config\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNICconfig]\n            try:\n                self.config = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'dhcpserver\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [DHCP]\n            try:\n                self.dhcpserver = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumGWNICType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'zerotierbridge\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ZerotierBridge]\n            try:\n                self.zerotierbridge = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'486,    @staticmethod\n    def create(id, name, type, config=None, dhcpserver=None, zerotierbridge=None):\n        """\n        :type config: GWNICconfig\n        :type dhcpserver: DHCP\n        :type id: str\n        :type name: str\n        :type type: EnumGWNICType\n        :type zerotierbridge: ZerotierBridge\n        :rtype: GWNIC\n        """\n\n        return GWNIC(\n            config=config,\n            dhcpserver=dhcpserver,\n            id=id,\n            name=name,\n            type=type,\n            zerotierbridge=zerotierbridge,\n        )\n'
u"487,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'GWNIC'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'config'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNICconfig]\n            try:\n                self.config = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'dhcpserver'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [DHCP]\n            try:\n                self.dhcpserver = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'type'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumGWNICType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'zerotierbridge'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ZerotierBridge]\n            try:\n                self.zerotierbridge = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'488,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'489,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'490,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'491,"""\nAuto-generated class for GWNICconfig\n"""\n\nfrom . import client_support\n\n\nclass GWNICconfig(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cidr, gateway=None):\n        """\n        :type cidr: str\n        :type gateway: str\n        :rtype: GWNICconfig\n        """\n\n        return GWNICconfig(\n            cidr=cidr,\n            gateway=gateway,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GWNICconfig\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cidr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cidr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'gateway\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.gateway = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'492,class GWNICconfig(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cidr, gateway=None):\n        """\n        :type cidr: str\n        :type gateway: str\n        :rtype: GWNICconfig\n        """\n\n        return GWNICconfig(\n            cidr=cidr,\n            gateway=gateway,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GWNICconfig\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cidr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cidr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'gateway\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.gateway = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'493,    @staticmethod\n    def create(cidr, gateway=None):\n        """\n        :type cidr: str\n        :type gateway: str\n        :rtype: GWNICconfig\n        """\n\n        return GWNICconfig(\n            cidr=cidr,\n            gateway=gateway,\n        )\n'
u"494,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'GWNICconfig'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cidr'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cidr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'gateway'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.gateway = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'495,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'496,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'497,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'498,"""\nAuto-generated class for GetGW\n"""\nfrom .GWNIC import GWNIC\nfrom .HTTPProxy import HTTPProxy\nfrom .PortForward import PortForward\n\nfrom . import client_support\n\n\nclass GetGW(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(domain, nics, httpproxies=None, portforwards=None, zerotiernodeid=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :type zerotiernodeid: str\n        :rtype: GetGW\n        """\n\n        return GetGW(\n            domain=domain,\n            httpproxies=httpproxies,\n            nics=nics,\n            portforwards=portforwards,\n            zerotiernodeid=zerotiernodeid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GetGW\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'domain\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'httpproxies\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portforwards\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'zerotiernodeid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.zerotiernodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'499,class GetGW(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(domain, nics, httpproxies=None, portforwards=None, zerotiernodeid=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :type zerotiernodeid: str\n        :rtype: GetGW\n        """\n\n        return GetGW(\n            domain=domain,\n            httpproxies=httpproxies,\n            nics=nics,\n            portforwards=portforwards,\n            zerotiernodeid=zerotiernodeid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'GetGW\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'domain\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'httpproxies\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portforwards\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'zerotiernodeid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.zerotiernodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'500,    @staticmethod\n    def create(domain, nics, httpproxies=None, portforwards=None, zerotiernodeid=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :type zerotiernodeid: str\n        :rtype: GetGW\n        """\n\n        return GetGW(\n            domain=domain,\n            httpproxies=httpproxies,\n            nics=nics,\n            portforwards=portforwards,\n            zerotiernodeid=zerotiernodeid,\n        )\n'
u"501,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'GetGW'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'domain'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'httpproxies'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'portforwards'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'zerotiernodeid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.zerotiernodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'502,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'503,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'504,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'505,"""\nAuto-generated class for HTTPProxy\n"""\nfrom .HTTPType import HTTPType\n\nfrom . import client_support\n\n\nclass HTTPProxy(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(destinations, host, types):\n        """\n        :type destinations: list[str]\n        :type host: str\n        :type types: list[HTTPType]\n        :rtype: HTTPProxy\n        """\n\n        return HTTPProxy(\n            destinations=destinations,\n            host=host,\n            types=types,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'HTTPProxy\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'destinations\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.destinations = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'host\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.host = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'types\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPType]\n            try:\n                self.types = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'506,class HTTPProxy(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(destinations, host, types):\n        """\n        :type destinations: list[str]\n        :type host: str\n        :type types: list[HTTPType]\n        :rtype: HTTPProxy\n        """\n\n        return HTTPProxy(\n            destinations=destinations,\n            host=host,\n            types=types,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'HTTPProxy\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'destinations\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.destinations = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'host\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.host = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'types\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPType]\n            try:\n                self.types = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'507,    @staticmethod\n    def create(destinations, host, types):\n        """\n        :type destinations: list[str]\n        :type host: str\n        :type types: list[HTTPType]\n        :rtype: HTTPProxy\n        """\n\n        return HTTPProxy(\n            destinations=destinations,\n            host=host,\n            types=types,\n        )\n'
u"508,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'HTTPProxy'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'destinations'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.destinations = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'host'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.host = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'types'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPType]\n            try:\n                self.types = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'509,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'510,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'511,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'512,from enum import Enum\n\n\nclass HTTPType(Enum):\n    http = "http"\n    https = "https"\n'
u'513,class HTTPType(Enum):\n    http = "http"\n    https = "https"\n'
u'514,from enum import Enum\n\n\nclass IPProtocol(Enum):\n    tcp = "tcp"\n    udp = "udp"\n'
u'515,class IPProtocol(Enum):\n    tcp = "tcp"\n    udp = "udp"\n'
u'516,"""\nAuto-generated class for Job\n"""\n\nfrom . import client_support\n\n\nclass Job(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, logLevels, maxRestart, maxTime, queue, recurringPeriod, statsInterval, tags):\n        """\n        :type id: str\n        :type logLevels: list[int]\n        :type maxRestart: int\n        :type maxTime: int\n        :type queue: str\n        :type recurringPeriod: int\n        :type statsInterval: int\n        :type tags: str\n        :rtype: Job\n        """\n\n        return Job(\n            id=id,\n            logLevels=logLevels,\n            maxRestart=maxRestart,\n            maxTime=maxTime,\n            queue=queue,\n            recurringPeriod=recurringPeriod,\n            statsInterval=statsInterval,\n            tags=tags,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Job\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'logLevels\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.logLevels = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'maxRestart\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.maxRestart = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'maxTime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.maxTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'queue\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.queue = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'recurringPeriod\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.recurringPeriod = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'statsInterval\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.statsInterval = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'tags\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.tags = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'517,class Job(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, logLevels, maxRestart, maxTime, queue, recurringPeriod, statsInterval, tags):\n        """\n        :type id: str\n        :type logLevels: list[int]\n        :type maxRestart: int\n        :type maxTime: int\n        :type queue: str\n        :type recurringPeriod: int\n        :type statsInterval: int\n        :type tags: str\n        :rtype: Job\n        """\n\n        return Job(\n            id=id,\n            logLevels=logLevels,\n            maxRestart=maxRestart,\n            maxTime=maxTime,\n            queue=queue,\n            recurringPeriod=recurringPeriod,\n            statsInterval=statsInterval,\n            tags=tags,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Job\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'logLevels\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.logLevels = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'maxRestart\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.maxRestart = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'maxTime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.maxTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'queue\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.queue = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'recurringPeriod\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.recurringPeriod = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'statsInterval\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.statsInterval = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'tags\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.tags = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'518,    @staticmethod\n    def create(id, logLevels, maxRestart, maxTime, queue, recurringPeriod, statsInterval, tags):\n        """\n        :type id: str\n        :type logLevels: list[int]\n        :type maxRestart: int\n        :type maxTime: int\n        :type queue: str\n        :type recurringPeriod: int\n        :type statsInterval: int\n        :type tags: str\n        :rtype: Job\n        """\n\n        return Job(\n            id=id,\n            logLevels=logLevels,\n            maxRestart=maxRestart,\n            maxTime=maxTime,\n            queue=queue,\n            recurringPeriod=recurringPeriod,\n            statsInterval=statsInterval,\n            tags=tags,\n        )\n'
u"519,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Job'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'logLevels'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.logLevels = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'maxRestart'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.maxRestart = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'maxTime'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.maxTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'queue'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.queue = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'recurringPeriod'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.recurringPeriod = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'statsInterval'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.statsInterval = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'tags'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.tags = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'520,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'521,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'522,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'523,"""\nAuto-generated class for JobListItem\n"""\n\nfrom . import client_support\n\n\nclass JobListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, startTime):\n        """\n        :type id: str\n        :type startTime: int\n        :rtype: JobListItem\n        """\n\n        return JobListItem(\n            id=id,\n            startTime=startTime,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'JobListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'startTime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.startTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'524,class JobListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, startTime):\n        """\n        :type id: str\n        :type startTime: int\n        :rtype: JobListItem\n        """\n\n        return JobListItem(\n            id=id,\n            startTime=startTime,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'JobListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'startTime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.startTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'525,    @staticmethod\n    def create(id, startTime):\n        """\n        :type id: str\n        :type startTime: int\n        :rtype: JobListItem\n        """\n\n        return JobListItem(\n            id=id,\n            startTime=startTime,\n        )\n'
u"526,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'JobListItem'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'startTime'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.startTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'527,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'528,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'529,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'530,"""\nAuto-generated class for JobResult\n"""\nfrom .EnumJobResultName import EnumJobResultName\nfrom .EnumJobResultState import EnumJobResultState\n\nfrom . import client_support\n\n\nclass JobResult(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(data, id, level, name, startTime, state, stderr, stdout):\n        """\n        :type data: str\n        :type id: str\n        :type level: int\n        :type name: EnumJobResultName\n        :type startTime: int\n        :type state: EnumJobResultState\n        :type stderr: str\n        :type stdout: str\n        :rtype: JobResult\n        """\n\n        return JobResult(\n            data=data,\n            id=id,\n            level=level,\n            name=name,\n            startTime=startTime,\n            state=state,\n            stderr=stderr,\n            stdout=stdout,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'JobResult\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'data\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.data = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'level\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.level = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumJobResultName]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'startTime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.startTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'state\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumJobResultState]\n            try:\n                self.state = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'stderr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.stderr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'stdout\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.stdout = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'531,class JobResult(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(data, id, level, name, startTime, state, stderr, stdout):\n        """\n        :type data: str\n        :type id: str\n        :type level: int\n        :type name: EnumJobResultName\n        :type startTime: int\n        :type state: EnumJobResultState\n        :type stderr: str\n        :type stdout: str\n        :rtype: JobResult\n        """\n\n        return JobResult(\n            data=data,\n            id=id,\n            level=level,\n            name=name,\n            startTime=startTime,\n            state=state,\n            stderr=stderr,\n            stdout=stdout,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'JobResult\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'data\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.data = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'level\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.level = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumJobResultName]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'startTime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.startTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'state\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumJobResultState]\n            try:\n                self.state = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'stderr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.stderr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'stdout\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.stdout = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'532,    @staticmethod\n    def create(data, id, level, name, startTime, state, stderr, stdout):\n        """\n        :type data: str\n        :type id: str\n        :type level: int\n        :type name: EnumJobResultName\n        :type startTime: int\n        :type state: EnumJobResultState\n        :type stderr: str\n        :type stdout: str\n        :rtype: JobResult\n        """\n\n        return JobResult(\n            data=data,\n            id=id,\n            level=level,\n            name=name,\n            startTime=startTime,\n            state=state,\n            stderr=stderr,\n            stdout=stdout,\n        )\n'
u"533,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'JobResult'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'data'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.data = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'level'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.level = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumJobResultName]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'startTime'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.startTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'state'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumJobResultState]\n            try:\n                self.state = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'stderr'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.stderr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'stdout'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.stdout = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'534,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'535,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'536,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'537,"""\nAuto-generated class for ListGW\n"""\nfrom .GWNIC import GWNIC\nfrom .HTTPProxy import HTTPProxy\nfrom .PortForward import PortForward\n\nfrom . import client_support\n\n\nclass ListGW(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(domain, name, nics, httpproxies=None, portforwards=None, zerotiernodeid=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type name: str\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :type zerotiernodeid: str\n        :rtype: ListGW\n        """\n\n        return ListGW(\n            domain=domain,\n            httpproxies=httpproxies,\n            name=name,\n            nics=nics,\n            portforwards=portforwards,\n            zerotiernodeid=zerotiernodeid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ListGW\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'domain\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'httpproxies\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portforwards\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'zerotiernodeid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.zerotiernodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'538,class ListGW(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(domain, name, nics, httpproxies=None, portforwards=None, zerotiernodeid=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type name: str\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :type zerotiernodeid: str\n        :rtype: ListGW\n        """\n\n        return ListGW(\n            domain=domain,\n            httpproxies=httpproxies,\n            name=name,\n            nics=nics,\n            portforwards=portforwards,\n            zerotiernodeid=zerotiernodeid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ListGW\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'domain\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'httpproxies\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portforwards\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'zerotiernodeid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.zerotiernodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'539,    @staticmethod\n    def create(domain, name, nics, httpproxies=None, portforwards=None, zerotiernodeid=None):\n        """\n        :type domain: str\n        :type httpproxies: list[HTTPProxy]\n        :type name: str\n        :type nics: list[GWNIC]\n        :type portforwards: list[PortForward]\n        :type zerotiernodeid: str\n        :rtype: ListGW\n        """\n\n        return ListGW(\n            domain=domain,\n            httpproxies=httpproxies,\n            name=name,\n            nics=nics,\n            portforwards=portforwards,\n            zerotiernodeid=zerotiernodeid,\n        )\n'
u"540,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ListGW'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'domain'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.domain = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'httpproxies'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [HTTPProxy]\n            try:\n                self.httpproxies = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [GWNIC]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'portforwards'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [PortForward]\n            try:\n                self.portforwards = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'zerotiernodeid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.zerotiernodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'541,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'542,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'543,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'544,"""\nAuto-generated class for MemInfo\n"""\n\nfrom . import client_support\n\n\nclass MemInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(active, available, buffers, cached, free, inactive, total, used, usedPercent, wired):\n        """\n        :type active: int\n        :type available: int\n        :type buffers: int\n        :type cached: int\n        :type free: int\n        :type inactive: int\n        :type total: int\n        :type used: int\n        :type usedPercent: float\n        :type wired: int\n        :rtype: MemInfo\n        """\n\n        return MemInfo(\n            active=active,\n            available=available,\n            buffers=buffers,\n            cached=cached,\n            free=free,\n            inactive=inactive,\n            total=total,\n            used=used,\n            usedPercent=usedPercent,\n            wired=wired,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'MemInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'active\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.active = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'available\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.available = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'buffers\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.buffers = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'cached\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cached = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'free\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.free = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'inactive\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.inactive = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'total\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.total = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'used\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.used = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'usedPercent\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.usedPercent = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'wired\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.wired = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'545,class MemInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(active, available, buffers, cached, free, inactive, total, used, usedPercent, wired):\n        """\n        :type active: int\n        :type available: int\n        :type buffers: int\n        :type cached: int\n        :type free: int\n        :type inactive: int\n        :type total: int\n        :type used: int\n        :type usedPercent: float\n        :type wired: int\n        :rtype: MemInfo\n        """\n\n        return MemInfo(\n            active=active,\n            available=available,\n            buffers=buffers,\n            cached=cached,\n            free=free,\n            inactive=inactive,\n            total=total,\n            used=used,\n            usedPercent=usedPercent,\n            wired=wired,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'MemInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'active\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.active = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'available\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.available = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'buffers\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.buffers = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'cached\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cached = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'free\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.free = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'inactive\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.inactive = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'total\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.total = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'used\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.used = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'usedPercent\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.usedPercent = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'wired\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.wired = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'546,    @staticmethod\n    def create(active, available, buffers, cached, free, inactive, total, used, usedPercent, wired):\n        """\n        :type active: int\n        :type available: int\n        :type buffers: int\n        :type cached: int\n        :type free: int\n        :type inactive: int\n        :type total: int\n        :type used: int\n        :type usedPercent: float\n        :type wired: int\n        :rtype: MemInfo\n        """\n\n        return MemInfo(\n            active=active,\n            available=available,\n            buffers=buffers,\n            cached=cached,\n            free=free,\n            inactive=inactive,\n            total=total,\n            used=used,\n            usedPercent=usedPercent,\n            wired=wired,\n        )\n'
u"547,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'MemInfo'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'active'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.active = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'available'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.available = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'buffers'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.buffers = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'cached'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cached = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'free'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.free = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'inactive'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.inactive = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'total'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.total = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'used'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.used = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'usedPercent'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.usedPercent = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'wired'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.wired = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'548,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'549,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'550,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'551,"""\nAuto-generated class for NicInfo\n"""\n\nfrom . import client_support\n\n\nclass NicInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(addrs, flags, hardwareaddr, mtu, name):\n        """\n        :type addrs: list[str]\n        :type flags: list[str]\n        :type hardwareaddr: str\n        :type mtu: int\n        :type name: str\n        :rtype: NicInfo\n        """\n\n        return NicInfo(\n            addrs=addrs,\n            flags=flags,\n            hardwareaddr=hardwareaddr,\n            mtu=mtu,\n            name=name,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'NicInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'addrs\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.addrs = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'flags\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flags = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hardwareaddr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hardwareaddr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mtu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.mtu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'552,class NicInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(addrs, flags, hardwareaddr, mtu, name):\n        """\n        :type addrs: list[str]\n        :type flags: list[str]\n        :type hardwareaddr: str\n        :type mtu: int\n        :type name: str\n        :rtype: NicInfo\n        """\n\n        return NicInfo(\n            addrs=addrs,\n            flags=flags,\n            hardwareaddr=hardwareaddr,\n            mtu=mtu,\n            name=name,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'NicInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'addrs\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.addrs = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'flags\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flags = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hardwareaddr\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hardwareaddr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mtu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.mtu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'553,    @staticmethod\n    def create(addrs, flags, hardwareaddr, mtu, name):\n        """\n        :type addrs: list[str]\n        :type flags: list[str]\n        :type hardwareaddr: str\n        :type mtu: int\n        :type name: str\n        :rtype: NicInfo\n        """\n\n        return NicInfo(\n            addrs=addrs,\n            flags=flags,\n            hardwareaddr=hardwareaddr,\n            mtu=mtu,\n            name=name,\n        )\n'
u"554,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'NicInfo'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'addrs'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.addrs = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'flags'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.flags = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'hardwareaddr'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hardwareaddr = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'mtu'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.mtu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'555,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'556,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'557,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'558,"""\nAuto-generated class for NicLink\n"""\nfrom .EnumNicLinkType import EnumNicLinkType\n\nfrom . import client_support\n\n\nclass NicLink(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(type, id=None, macaddress=None):\n        """\n        :type id: str\n        :type macaddress: str\n        :type type: EnumNicLinkType\n        :rtype: NicLink\n        """\n\n        return NicLink(\n            id=id,\n            macaddress=macaddress,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'NicLink\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'macaddress\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.macaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumNicLinkType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'559,class NicLink(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(type, id=None, macaddress=None):\n        """\n        :type id: str\n        :type macaddress: str\n        :type type: EnumNicLinkType\n        :rtype: NicLink\n        """\n\n        return NicLink(\n            id=id,\n            macaddress=macaddress,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'NicLink\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'macaddress\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.macaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumNicLinkType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'560,    @staticmethod\n    def create(type, id=None, macaddress=None):\n        """\n        :type id: str\n        :type macaddress: str\n        :type type: EnumNicLinkType\n        :rtype: NicLink\n        """\n\n        return NicLink(\n            id=id,\n            macaddress=macaddress,\n            type=type,\n        )\n'
u"561,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'NicLink'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'macaddress'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.macaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'type'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumNicLinkType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'562,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'563,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'564,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'565,"""\nAuto-generated class for Node\n"""\nfrom .EnumNodeStatus import EnumNodeStatus\n\nfrom . import client_support\n\n\nclass Node(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(hostname, id, ipaddress, status):\n        """\n        :type hostname: str\n        :type id: str\n        :type ipaddress: str\n        :type status: EnumNodeStatus\n        :rtype: Node\n        """\n\n        return Node(\n            hostname=hostname,\n            id=id,\n            ipaddress=ipaddress,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Node\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ipaddress\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ipaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumNodeStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'566,class Node(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(hostname, id, ipaddress, status):\n        """\n        :type hostname: str\n        :type id: str\n        :type ipaddress: str\n        :type status: EnumNodeStatus\n        :rtype: Node\n        """\n\n        return Node(\n            hostname=hostname,\n            id=id,\n            ipaddress=ipaddress,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Node\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ipaddress\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ipaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumNodeStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'567,    @staticmethod\n    def create(hostname, id, ipaddress, status):\n        """\n        :type hostname: str\n        :type id: str\n        :type ipaddress: str\n        :type status: EnumNodeStatus\n        :rtype: Node\n        """\n\n        return Node(\n            hostname=hostname,\n            id=id,\n            ipaddress=ipaddress,\n            status=status,\n        )\n'
u"568,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Node'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'hostname'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'ipaddress'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ipaddress = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumNodeStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'569,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'570,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'571,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'572,"""\nAuto-generated class for NodeMount\n"""\n\nfrom . import client_support\n\n\nclass NodeMount(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(device, fstype, mountpoint, opts):\n        """\n        :type device: str\n        :type fstype: str\n        :type mountpoint: str\n        :type opts: str\n        :rtype: NodeMount\n        """\n\n        return NodeMount(\n            device=device,\n            fstype=fstype,\n            mountpoint=mountpoint,\n            opts=opts,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'NodeMount\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'device\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.device = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'fstype\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.fstype = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mountpoint\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mountpoint = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'opts\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.opts = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'573,class NodeMount(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(device, fstype, mountpoint, opts):\n        """\n        :type device: str\n        :type fstype: str\n        :type mountpoint: str\n        :type opts: str\n        :rtype: NodeMount\n        """\n\n        return NodeMount(\n            device=device,\n            fstype=fstype,\n            mountpoint=mountpoint,\n            opts=opts,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'NodeMount\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'device\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.device = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'fstype\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.fstype = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mountpoint\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mountpoint = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'opts\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.opts = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'574,    @staticmethod\n    def create(device, fstype, mountpoint, opts):\n        """\n        :type device: str\n        :type fstype: str\n        :type mountpoint: str\n        :type opts: str\n        :rtype: NodeMount\n        """\n\n        return NodeMount(\n            device=device,\n            fstype=fstype,\n            mountpoint=mountpoint,\n            opts=opts,\n        )\n'
u"575,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'NodeMount'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'device'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.device = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'fstype'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.fstype = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'mountpoint'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mountpoint = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'opts'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.opts = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'576,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'577,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'578,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'579,"""\nAuto-generated class for OSInfo\n"""\n\nfrom . import client_support\n\n\nclass OSInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(bootTime, hostname, os, platform, platformFamily, platformVersion, procs, uptime, virtualizationRole, virtualizationSystem):\n        """\n        :type bootTime: int\n        :type hostname: str\n        :type os: str\n        :type platform: str\n        :type platformFamily: str\n        :type platformVersion: str\n        :type procs: int\n        :type uptime: int\n        :type virtualizationRole: str\n        :type virtualizationSystem: str\n        :rtype: OSInfo\n        """\n\n        return OSInfo(\n            bootTime=bootTime,\n            hostname=hostname,\n            os=os,\n            platform=platform,\n            platformFamily=platformFamily,\n            platformVersion=platformVersion,\n            procs=procs,\n            uptime=uptime,\n            virtualizationRole=virtualizationRole,\n            virtualizationSystem=virtualizationSystem,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'OSInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'bootTime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.bootTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'os\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.os = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'platform\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.platform = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'platformFamily\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.platformFamily = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'platformVersion\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.platformVersion = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'procs\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.procs = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'uptime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.uptime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'virtualizationRole\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.virtualizationRole = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'virtualizationSystem\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.virtualizationSystem = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'580,class OSInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(bootTime, hostname, os, platform, platformFamily, platformVersion, procs, uptime, virtualizationRole, virtualizationSystem):\n        """\n        :type bootTime: int\n        :type hostname: str\n        :type os: str\n        :type platform: str\n        :type platformFamily: str\n        :type platformVersion: str\n        :type procs: int\n        :type uptime: int\n        :type virtualizationRole: str\n        :type virtualizationSystem: str\n        :rtype: OSInfo\n        """\n\n        return OSInfo(\n            bootTime=bootTime,\n            hostname=hostname,\n            os=os,\n            platform=platform,\n            platformFamily=platformFamily,\n            platformVersion=platformVersion,\n            procs=procs,\n            uptime=uptime,\n            virtualizationRole=virtualizationRole,\n            virtualizationSystem=virtualizationSystem,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'OSInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'bootTime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.bootTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'hostname\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'os\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.os = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'platform\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.platform = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'platformFamily\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.platformFamily = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'platformVersion\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.platformVersion = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'procs\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.procs = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'uptime\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.uptime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'virtualizationRole\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.virtualizationRole = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'virtualizationSystem\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.virtualizationSystem = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'581,    @staticmethod\n    def create(bootTime, hostname, os, platform, platformFamily, platformVersion, procs, uptime, virtualizationRole, virtualizationSystem):\n        """\n        :type bootTime: int\n        :type hostname: str\n        :type os: str\n        :type platform: str\n        :type platformFamily: str\n        :type platformVersion: str\n        :type procs: int\n        :type uptime: int\n        :type virtualizationRole: str\n        :type virtualizationSystem: str\n        :rtype: OSInfo\n        """\n\n        return OSInfo(\n            bootTime=bootTime,\n            hostname=hostname,\n            os=os,\n            platform=platform,\n            platformFamily=platformFamily,\n            platformVersion=platformVersion,\n            procs=procs,\n            uptime=uptime,\n            virtualizationRole=virtualizationRole,\n            virtualizationSystem=virtualizationSystem,\n        )\n'
u"582,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'OSInfo'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'bootTime'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.bootTime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'hostname'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.hostname = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'os'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.os = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'platform'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.platform = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'platformFamily'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.platformFamily = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'platformVersion'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.platformVersion = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'procs'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.procs = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'uptime'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.uptime = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'virtualizationRole'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.virtualizationRole = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'virtualizationSystem'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.virtualizationSystem = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'583,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'584,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'585,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'586,"""\nAuto-generated class for PortForward\n"""\nfrom .IPProtocol import IPProtocol\n\nfrom . import client_support\n\n\nclass PortForward(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(dstip, dstport, protocols, srcip, srcport):\n        """\n        :type dstip: str\n        :type dstport: int\n        :type protocols: list[IPProtocol]\n        :type srcip: str\n        :type srcport: int\n        :rtype: PortForward\n        """\n\n        return PortForward(\n            dstip=dstip,\n            dstport=dstport,\n            protocols=protocols,\n            srcip=srcip,\n            srcport=srcport,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'PortForward\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'dstip\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.dstip = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dstport\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.dstport = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'protocols\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [IPProtocol]\n            try:\n                self.protocols = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'srcip\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.srcip = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'srcport\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.srcport = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'587,class PortForward(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(dstip, dstport, protocols, srcip, srcport):\n        """\n        :type dstip: str\n        :type dstport: int\n        :type protocols: list[IPProtocol]\n        :type srcip: str\n        :type srcport: int\n        :rtype: PortForward\n        """\n\n        return PortForward(\n            dstip=dstip,\n            dstport=dstport,\n            protocols=protocols,\n            srcip=srcip,\n            srcport=srcport,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'PortForward\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'dstip\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.dstip = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dstport\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.dstport = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'protocols\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [IPProtocol]\n            try:\n                self.protocols = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'srcip\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.srcip = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'srcport\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.srcport = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'588,    @staticmethod\n    def create(dstip, dstport, protocols, srcip, srcport):\n        """\n        :type dstip: str\n        :type dstport: int\n        :type protocols: list[IPProtocol]\n        :type srcip: str\n        :type srcport: int\n        :rtype: PortForward\n        """\n\n        return PortForward(\n            dstip=dstip,\n            dstport=dstport,\n            protocols=protocols,\n            srcip=srcip,\n            srcport=srcport,\n        )\n'
u"589,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'PortForward'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'dstip'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.dstip = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'dstport'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.dstport = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'protocols'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [IPProtocol]\n            try:\n                self.protocols = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'srcip'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.srcip = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'srcport'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.srcport = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'590,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'591,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'592,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'593,"""\nAuto-generated class for Process\n"""\nfrom .CPUStats import CPUStats\n\nfrom . import client_support\n\n\nclass Process(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cmdline, cpu, pid, rss, swap, vms):\n        """\n        :type cmdline: str\n        :type cpu: CPUStats\n        :type pid: int\n        :type rss: int\n        :type swap: int\n        :type vms: int\n        :rtype: Process\n        """\n\n        return Process(\n            cmdline=cmdline,\n            cpu=cpu,\n            pid=pid,\n            rss=rss,\n            swap=swap,\n            vms=vms,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Process\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cmdline\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cmdline = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CPUStats]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'pid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.pid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'rss\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.rss = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'swap\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.swap = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'vms\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.vms = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'594,class Process(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cmdline, cpu, pid, rss, swap, vms):\n        """\n        :type cmdline: str\n        :type cpu: CPUStats\n        :type pid: int\n        :type rss: int\n        :type swap: int\n        :type vms: int\n        :rtype: Process\n        """\n\n        return Process(\n            cmdline=cmdline,\n            cpu=cpu,\n            pid=pid,\n            rss=rss,\n            swap=swap,\n            vms=vms,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Process\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cmdline\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cmdline = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CPUStats]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'pid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.pid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'rss\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.rss = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'swap\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.swap = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'vms\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.vms = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'595,    @staticmethod\n    def create(cmdline, cpu, pid, rss, swap, vms):\n        """\n        :type cmdline: str\n        :type cpu: CPUStats\n        :type pid: int\n        :type rss: int\n        :type swap: int\n        :type vms: int\n        :rtype: Process\n        """\n\n        return Process(\n            cmdline=cmdline,\n            cpu=cpu,\n            pid=pid,\n            rss=rss,\n            swap=swap,\n            vms=vms,\n        )\n'
u"596,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Process'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cmdline'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.cmdline = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'cpu'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [CPUStats]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'pid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.pid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'rss'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.rss = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'swap'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.swap = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'vms'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.vms = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'597,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'598,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'599,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'600,"""\nAuto-generated class for ProcessSignal\n"""\n\nfrom . import client_support\n\n\nclass ProcessSignal(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(signal):\n        """\n        :type signal: int\n        :rtype: ProcessSignal\n        """\n\n        return ProcessSignal(\n            signal=signal,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ProcessSignal\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'signal\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.signal = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'601,class ProcessSignal(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(signal):\n        """\n        :type signal: int\n        :rtype: ProcessSignal\n        """\n\n        return ProcessSignal(\n            signal=signal,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ProcessSignal\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'signal\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.signal = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'602,    @staticmethod\n    def create(signal):\n        """\n        :type signal: int\n        :rtype: ProcessSignal\n        """\n\n        return ProcessSignal(\n            signal=signal,\n        )\n'
u"603,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ProcessSignal'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'signal'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.signal = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'604,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'605,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'606,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'607,"""\nAuto-generated class for Run\n"""\nfrom .RunState import RunState\n\nfrom . import client_support\n\n\nclass Run(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(runid, state):\n        """\n        :type runid: str\n        :type state: RunState\n        :rtype: Run\n        """\n\n        return Run(\n            runid=runid,\n            state=state,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Run\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'runid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.runid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'state\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [RunState]\n            try:\n                self.state = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'608,class Run(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(runid, state):\n        """\n        :type runid: str\n        :type state: RunState\n        :rtype: Run\n        """\n\n        return Run(\n            runid=runid,\n            state=state,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Run\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'runid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.runid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'state\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [RunState]\n            try:\n                self.state = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'609,    @staticmethod\n    def create(runid, state):\n        """\n        :type runid: str\n        :type state: RunState\n        :rtype: Run\n        """\n\n        return Run(\n            runid=runid,\n            state=state,\n        )\n'
u"610,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Run'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'runid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.runid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'state'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [RunState]\n            try:\n                self.state = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'611,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'612,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'613,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'614,from enum import Enum\n\n\nclass RunState(Enum):\n    ok = "ok"\n    running = "running"\n    scheduled = "scheduled"\n    error = "error"\n    new = "new"\n    disabled = "disabled"\n    changed = "changed"\n'
u'615,class RunState(Enum):\n    ok = "ok"\n    running = "running"\n    scheduled = "scheduled"\n    error = "error"\n    new = "new"\n    disabled = "disabled"\n    changed = "changed"\n'
u'616,"""\nAuto-generated class for Snapshot\n"""\n\nfrom . import client_support\n\n\nclass Snapshot(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, sizeOnDisk, timestamp):\n        """\n        :type name: str\n        :type sizeOnDisk: int\n        :type timestamp: int\n        :rtype: Snapshot\n        """\n\n        return Snapshot(\n            name=name,\n            sizeOnDisk=sizeOnDisk,\n            timestamp=timestamp,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Snapshot\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'sizeOnDisk\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.sizeOnDisk = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'timestamp\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.timestamp = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'617,class Snapshot(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, sizeOnDisk, timestamp):\n        """\n        :type name: str\n        :type sizeOnDisk: int\n        :type timestamp: int\n        :rtype: Snapshot\n        """\n\n        return Snapshot(\n            name=name,\n            sizeOnDisk=sizeOnDisk,\n            timestamp=timestamp,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Snapshot\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'sizeOnDisk\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.sizeOnDisk = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'timestamp\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.timestamp = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'618,    @staticmethod\n    def create(name, sizeOnDisk, timestamp):\n        """\n        :type name: str\n        :type sizeOnDisk: int\n        :type timestamp: int\n        :rtype: Snapshot\n        """\n\n        return Snapshot(\n            name=name,\n            sizeOnDisk=sizeOnDisk,\n            timestamp=timestamp,\n        )\n'
u"619,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Snapshot'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'sizeOnDisk'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.sizeOnDisk = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'timestamp'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.timestamp = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'620,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'621,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'622,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'623,"""\nAuto-generated class for StoragePool\n"""\nfrom .EnumStoragePoolDataProfile import EnumStoragePoolDataProfile\nfrom .EnumStoragePoolMetadataProfile import EnumStoragePoolMetadataProfile\nfrom .EnumStoragePoolStatus import EnumStoragePoolStatus\n\nfrom . import client_support\n\n\nclass StoragePool(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(capacity, dataProfile, metadataProfile, mountpoint, name, status, totalCapacity):\n        """\n        :type capacity: int\n        :type dataProfile: EnumStoragePoolDataProfile\n        :type metadataProfile: EnumStoragePoolMetadataProfile\n        :type mountpoint: str\n        :type name: str\n        :type status: EnumStoragePoolStatus\n        :type totalCapacity: int\n        :rtype: StoragePool\n        """\n\n        return StoragePool(\n            capacity=capacity,\n            dataProfile=dataProfile,\n            metadataProfile=metadataProfile,\n            mountpoint=mountpoint,\n            name=name,\n            status=status,\n            totalCapacity=totalCapacity,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StoragePool\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'capacity\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.capacity = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dataProfile\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolDataProfile]\n            try:\n                self.dataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'metadataProfile\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolMetadataProfile]\n            try:\n                self.metadataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mountpoint\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mountpoint = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'totalCapacity\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.totalCapacity = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'624,class StoragePool(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(capacity, dataProfile, metadataProfile, mountpoint, name, status, totalCapacity):\n        """\n        :type capacity: int\n        :type dataProfile: EnumStoragePoolDataProfile\n        :type metadataProfile: EnumStoragePoolMetadataProfile\n        :type mountpoint: str\n        :type name: str\n        :type status: EnumStoragePoolStatus\n        :type totalCapacity: int\n        :rtype: StoragePool\n        """\n\n        return StoragePool(\n            capacity=capacity,\n            dataProfile=dataProfile,\n            metadataProfile=metadataProfile,\n            mountpoint=mountpoint,\n            name=name,\n            status=status,\n            totalCapacity=totalCapacity,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StoragePool\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'capacity\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.capacity = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dataProfile\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolDataProfile]\n            try:\n                self.dataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'metadataProfile\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolMetadataProfile]\n            try:\n                self.metadataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mountpoint\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mountpoint = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'totalCapacity\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.totalCapacity = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'625,    @staticmethod\n    def create(capacity, dataProfile, metadataProfile, mountpoint, name, status, totalCapacity):\n        """\n        :type capacity: int\n        :type dataProfile: EnumStoragePoolDataProfile\n        :type metadataProfile: EnumStoragePoolMetadataProfile\n        :type mountpoint: str\n        :type name: str\n        :type status: EnumStoragePoolStatus\n        :type totalCapacity: int\n        :rtype: StoragePool\n        """\n\n        return StoragePool(\n            capacity=capacity,\n            dataProfile=dataProfile,\n            metadataProfile=metadataProfile,\n            mountpoint=mountpoint,\n            name=name,\n            status=status,\n            totalCapacity=totalCapacity,\n        )\n'
u"626,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'StoragePool'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'capacity'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.capacity = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'dataProfile'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolDataProfile]\n            try:\n                self.dataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'metadataProfile'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolMetadataProfile]\n            try:\n                self.metadataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'mountpoint'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mountpoint = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'totalCapacity'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.totalCapacity = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'627,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'628,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'629,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'630,"""\nAuto-generated class for StoragePoolCreate\n"""\nfrom .EnumStoragePoolCreateDataProfile import EnumStoragePoolCreateDataProfile\nfrom .EnumStoragePoolCreateMetadataProfile import EnumStoragePoolCreateMetadataProfile\n\nfrom . import client_support\n\n\nclass StoragePoolCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(dataProfile, devices, metadataProfile, name):\n        """\n        :type dataProfile: EnumStoragePoolCreateDataProfile\n        :type devices: list[str]\n        :type metadataProfile: EnumStoragePoolCreateMetadataProfile\n        :type name: str\n        :rtype: StoragePoolCreate\n        """\n\n        return StoragePoolCreate(\n            dataProfile=dataProfile,\n            devices=devices,\n            metadataProfile=metadataProfile,\n            name=name,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StoragePoolCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'dataProfile\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolCreateDataProfile]\n            try:\n                self.dataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'devices\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.devices = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'metadataProfile\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolCreateMetadataProfile]\n            try:\n                self.metadataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'631,class StoragePoolCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(dataProfile, devices, metadataProfile, name):\n        """\n        :type dataProfile: EnumStoragePoolCreateDataProfile\n        :type devices: list[str]\n        :type metadataProfile: EnumStoragePoolCreateMetadataProfile\n        :type name: str\n        :rtype: StoragePoolCreate\n        """\n\n        return StoragePoolCreate(\n            dataProfile=dataProfile,\n            devices=devices,\n            metadataProfile=metadataProfile,\n            name=name,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StoragePoolCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'dataProfile\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolCreateDataProfile]\n            try:\n                self.dataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'devices\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.devices = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'metadataProfile\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolCreateMetadataProfile]\n            try:\n                self.metadataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'632,    @staticmethod\n    def create(dataProfile, devices, metadataProfile, name):\n        """\n        :type dataProfile: EnumStoragePoolCreateDataProfile\n        :type devices: list[str]\n        :type metadataProfile: EnumStoragePoolCreateMetadataProfile\n        :type name: str\n        :rtype: StoragePoolCreate\n        """\n\n        return StoragePoolCreate(\n            dataProfile=dataProfile,\n            devices=devices,\n            metadataProfile=metadataProfile,\n            name=name,\n        )\n'
u"633,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'StoragePoolCreate'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'dataProfile'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolCreateDataProfile]\n            try:\n                self.dataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'devices'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.devices = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'metadataProfile'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolCreateMetadataProfile]\n            try:\n                self.metadataProfile = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'634,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'635,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'636,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'637,"""\nAuto-generated class for StoragePoolDevice\n"""\nfrom .EnumStoragePoolDeviceStatus import EnumStoragePoolDeviceStatus\n\nfrom . import client_support\n\n\nclass StoragePoolDevice(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(deviceName, status, uuid):\n        """\n        :type deviceName: str\n        :type status: EnumStoragePoolDeviceStatus\n        :type uuid: str\n        :rtype: StoragePoolDevice\n        """\n\n        return StoragePoolDevice(\n            deviceName=deviceName,\n            status=status,\n            uuid=uuid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StoragePoolDevice\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'deviceName\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.deviceName = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolDeviceStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'uuid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.uuid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'638,class StoragePoolDevice(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(deviceName, status, uuid):\n        """\n        :type deviceName: str\n        :type status: EnumStoragePoolDeviceStatus\n        :type uuid: str\n        :rtype: StoragePoolDevice\n        """\n\n        return StoragePoolDevice(\n            deviceName=deviceName,\n            status=status,\n            uuid=uuid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StoragePoolDevice\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'deviceName\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.deviceName = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolDeviceStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'uuid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.uuid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'639,    @staticmethod\n    def create(deviceName, status, uuid):\n        """\n        :type deviceName: str\n        :type status: EnumStoragePoolDeviceStatus\n        :type uuid: str\n        :rtype: StoragePoolDevice\n        """\n\n        return StoragePoolDevice(\n            deviceName=deviceName,\n            status=status,\n            uuid=uuid,\n        )\n'
u"640,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'StoragePoolDevice'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'deviceName'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.deviceName = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolDeviceStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'uuid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.uuid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'641,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'642,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'643,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'644,"""\nAuto-generated class for StoragePoolListItem\n"""\nfrom .EnumStoragePoolListItemStatus import EnumStoragePoolListItemStatus\n\nfrom . import client_support\n\n\nclass StoragePoolListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(capacity, name, status):\n        """\n        :type capacity: str\n        :type name: str\n        :type status: EnumStoragePoolListItemStatus\n        :rtype: StoragePoolListItem\n        """\n\n        return StoragePoolListItem(\n            capacity=capacity,\n            name=name,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StoragePoolListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'capacity\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.capacity = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'645,class StoragePoolListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(capacity, name, status):\n        """\n        :type capacity: str\n        :type name: str\n        :type status: EnumStoragePoolListItemStatus\n        :rtype: StoragePoolListItem\n        """\n\n        return StoragePoolListItem(\n            capacity=capacity,\n            name=name,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StoragePoolListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'capacity\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.capacity = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'646,    @staticmethod\n    def create(capacity, name, status):\n        """\n        :type capacity: str\n        :type name: str\n        :type status: EnumStoragePoolListItemStatus\n        :rtype: StoragePoolListItem\n        """\n\n        return StoragePoolListItem(\n            capacity=capacity,\n            name=name,\n            status=status,\n        )\n'
u"647,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'StoragePoolListItem'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'capacity'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.capacity = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStoragePoolListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'648,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'649,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'650,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'651,"""\nAuto-generated class for StorageServer\n"""\nfrom .EnumStorageServerStatus import EnumStorageServerStatus\n\nfrom . import client_support\n\n\nclass StorageServer(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(container, id, ip, port, status):\n        """\n        :type container: str\n        :type id: int\n        :type ip: str\n        :type port: int\n        :type status: EnumStorageServerStatus\n        :rtype: StorageServer\n        """\n\n        return StorageServer(\n            container=container,\n            id=id,\n            ip=ip,\n            port=port,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StorageServer\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'container\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.container = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ip\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ip = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'port\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.port = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStorageServerStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'652,class StorageServer(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(container, id, ip, port, status):\n        """\n        :type container: str\n        :type id: int\n        :type ip: str\n        :type port: int\n        :type status: EnumStorageServerStatus\n        :rtype: StorageServer\n        """\n\n        return StorageServer(\n            container=container,\n            id=id,\n            ip=ip,\n            port=port,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'StorageServer\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'container\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.container = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'ip\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ip = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'port\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.port = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStorageServerStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'653,    @staticmethod\n    def create(container, id, ip, port, status):\n        """\n        :type container: str\n        :type id: int\n        :type ip: str\n        :type port: int\n        :type status: EnumStorageServerStatus\n        :rtype: StorageServer\n        """\n\n        return StorageServer(\n            container=container,\n            id=id,\n            ip=ip,\n            port=port,\n            status=status,\n        )\n'
u"654,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'StorageServer'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'container'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.container = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'ip'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.ip = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'port'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.port = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumStorageServerStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'655,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'656,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'657,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'658,"""\nAuto-generated class for VDiskLink\n"""\n\nfrom . import client_support\n\n\nclass VDiskLink(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(maxIOps, vdiskid):\n        """\n        :type maxIOps: int\n        :type vdiskid: str\n        :rtype: VDiskLink\n        """\n\n        return VDiskLink(\n            maxIOps=maxIOps,\n            vdiskid=vdiskid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VDiskLink\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'maxIOps\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.maxIOps = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'vdiskid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.vdiskid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'659,class VDiskLink(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(maxIOps, vdiskid):\n        """\n        :type maxIOps: int\n        :type vdiskid: str\n        :rtype: VDiskLink\n        """\n\n        return VDiskLink(\n            maxIOps=maxIOps,\n            vdiskid=vdiskid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VDiskLink\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'maxIOps\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.maxIOps = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'vdiskid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.vdiskid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'660,    @staticmethod\n    def create(maxIOps, vdiskid):\n        """\n        :type maxIOps: int\n        :type vdiskid: str\n        :rtype: VDiskLink\n        """\n\n        return VDiskLink(\n            maxIOps=maxIOps,\n            vdiskid=vdiskid,\n        )\n'
u"661,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VDiskLink'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'maxIOps'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.maxIOps = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'vdiskid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.vdiskid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'662,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'663,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'664,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'665,"""\nAuto-generated class for VM\n"""\nfrom .EnumVMStatus import EnumVMStatus\nfrom .NicLink import NicLink\nfrom .VDiskLink import VDiskLink\n\nfrom . import client_support\n\n\nclass VM(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, disks, id, memory, nics, status, vnc):\n        """\n        :type cpu: int\n        :type disks: list[VDiskLink]\n        :type id: str\n        :type memory: int\n        :type nics: list[NicLink]\n        :type status: EnumVMStatus\n        :type vnc: int\n        :rtype: VM\n        """\n\n        return VM(\n            cpu=cpu,\n            disks=disks,\n            id=id,\n            memory=memory,\n            nics=nics,\n            status=status,\n            vnc=vnc,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VM\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'disks\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VDiskLink]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'memory\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.memory = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [NicLink]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVMStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'vnc\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.vnc = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'666,class VM(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, disks, id, memory, nics, status, vnc):\n        """\n        :type cpu: int\n        :type disks: list[VDiskLink]\n        :type id: str\n        :type memory: int\n        :type nics: list[NicLink]\n        :type status: EnumVMStatus\n        :type vnc: int\n        :rtype: VM\n        """\n\n        return VM(\n            cpu=cpu,\n            disks=disks,\n            id=id,\n            memory=memory,\n            nics=nics,\n            status=status,\n            vnc=vnc,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VM\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'disks\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VDiskLink]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'memory\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.memory = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [NicLink]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVMStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'vnc\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.vnc = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'667,    @staticmethod\n    def create(cpu, disks, id, memory, nics, status, vnc):\n        """\n        :type cpu: int\n        :type disks: list[VDiskLink]\n        :type id: str\n        :type memory: int\n        :type nics: list[NicLink]\n        :type status: EnumVMStatus\n        :type vnc: int\n        :rtype: VM\n        """\n\n        return VM(\n            cpu=cpu,\n            disks=disks,\n            id=id,\n            memory=memory,\n            nics=nics,\n            status=status,\n            vnc=vnc,\n        )\n'
u"668,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VM'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cpu'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'disks'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VDiskLink]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'memory'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.memory = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [NicLink]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVMStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'vnc'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.vnc = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'669,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'670,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'671,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'672,"""\nAuto-generated class for VMCreate\n"""\nfrom .NicLink import NicLink\nfrom .VDiskLink import VDiskLink\n\nfrom . import client_support\n\n\nclass VMCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, disks, id, memory, nics):\n        """\n        :type cpu: int\n        :type disks: list[VDiskLink]\n        :type id: str\n        :type memory: int\n        :type nics: list[NicLink]\n        :rtype: VMCreate\n        """\n\n        return VMCreate(\n            cpu=cpu,\n            disks=disks,\n            id=id,\n            memory=memory,\n            nics=nics,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'disks\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VDiskLink]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'memory\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.memory = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [NicLink]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'673,class VMCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, disks, id, memory, nics):\n        """\n        :type cpu: int\n        :type disks: list[VDiskLink]\n        :type id: str\n        :type memory: int\n        :type nics: list[NicLink]\n        :rtype: VMCreate\n        """\n\n        return VMCreate(\n            cpu=cpu,\n            disks=disks,\n            id=id,\n            memory=memory,\n            nics=nics,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'disks\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VDiskLink]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'memory\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.memory = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [NicLink]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'674,    @staticmethod\n    def create(cpu, disks, id, memory, nics):\n        """\n        :type cpu: int\n        :type disks: list[VDiskLink]\n        :type id: str\n        :type memory: int\n        :type nics: list[NicLink]\n        :rtype: VMCreate\n        """\n\n        return VMCreate(\n            cpu=cpu,\n            disks=disks,\n            id=id,\n            memory=memory,\n            nics=nics,\n        )\n'
u"675,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VMCreate'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cpu'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'disks'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VDiskLink]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'memory'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.memory = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [NicLink]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'676,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'677,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'678,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'679,"""\nAuto-generated class for VMDiskInfo\n"""\n\nfrom . import client_support\n\n\nclass VMDiskInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(readIops, readThroughput, writeIops, writeThroughput):\n        """\n        :type readIops: int\n        :type readThroughput: int\n        :type writeIops: int\n        :type writeThroughput: int\n        :rtype: VMDiskInfo\n        """\n\n        return VMDiskInfo(\n            readIops=readIops,\n            readThroughput=readThroughput,\n            writeIops=writeIops,\n            writeThroughput=writeThroughput,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMDiskInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'readIops\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.readIops = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readThroughput\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.readThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'writeIops\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.writeIops = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'writeThroughput\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.writeThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'680,class VMDiskInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(readIops, readThroughput, writeIops, writeThroughput):\n        """\n        :type readIops: int\n        :type readThroughput: int\n        :type writeIops: int\n        :type writeThroughput: int\n        :rtype: VMDiskInfo\n        """\n\n        return VMDiskInfo(\n            readIops=readIops,\n            readThroughput=readThroughput,\n            writeIops=writeIops,\n            writeThroughput=writeThroughput,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMDiskInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'readIops\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.readIops = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readThroughput\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.readThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'writeIops\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.writeIops = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'writeThroughput\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.writeThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'681,    @staticmethod\n    def create(readIops, readThroughput, writeIops, writeThroughput):\n        """\n        :type readIops: int\n        :type readThroughput: int\n        :type writeIops: int\n        :type writeThroughput: int\n        :rtype: VMDiskInfo\n        """\n\n        return VMDiskInfo(\n            readIops=readIops,\n            readThroughput=readThroughput,\n            writeIops=writeIops,\n            writeThroughput=writeThroughput,\n        )\n'
u"682,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VMDiskInfo'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'readIops'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.readIops = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'readThroughput'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.readThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'writeIops'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.writeIops = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'writeThroughput'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.writeThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'683,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'684,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'685,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'686,"""\nAuto-generated class for VMInfo\n"""\nfrom .VMDiskInfo import VMDiskInfo\nfrom .VMNicInfo import VMNicInfo\n\nfrom . import client_support\n\n\nclass VMInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, disks, nics):\n        """\n        :type cpu: list[float]\n        :type disks: list[VMDiskInfo]\n        :type nics: list[VMNicInfo]\n        :rtype: VMInfo\n        """\n\n        return VMInfo(\n            cpu=cpu,\n            disks=disks,\n            nics=nics,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.cpu = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'disks\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VMDiskInfo]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VMNicInfo]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'687,class VMInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, disks, nics):\n        """\n        :type cpu: list[float]\n        :type disks: list[VMDiskInfo]\n        :type nics: list[VMNicInfo]\n        :rtype: VMInfo\n        """\n\n        return VMInfo(\n            cpu=cpu,\n            disks=disks,\n            nics=nics,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.cpu = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'disks\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VMDiskInfo]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VMNicInfo]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'688,    @staticmethod\n    def create(cpu, disks, nics):\n        """\n        :type cpu: list[float]\n        :type disks: list[VMDiskInfo]\n        :type nics: list[VMNicInfo]\n        :rtype: VMInfo\n        """\n\n        return VMInfo(\n            cpu=cpu,\n            disks=disks,\n            nics=nics,\n        )\n'
u"689,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VMInfo'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cpu'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [float]\n            try:\n                self.cpu = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'disks'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VMDiskInfo]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VMNicInfo]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'690,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'691,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'692,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'693,"""\nAuto-generated class for VMListItem\n"""\nfrom .EnumVMListItemStatus import EnumVMListItemStatus\n\nfrom . import client_support\n\n\nclass VMListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, status):\n        """\n        :type id: str\n        :type status: EnumVMListItemStatus\n        :rtype: VMListItem\n        """\n\n        return VMListItem(\n            id=id,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVMListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'694,class VMListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, status):\n        """\n        :type id: str\n        :type status: EnumVMListItemStatus\n        :rtype: VMListItem\n        """\n\n        return VMListItem(\n            id=id,\n            status=status,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVMListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'695,    @staticmethod\n    def create(id, status):\n        """\n        :type id: str\n        :type status: EnumVMListItemStatus\n        :rtype: VMListItem\n        """\n\n        return VMListItem(\n            id=id,\n            status=status,\n        )\n'
u"696,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VMListItem'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVMListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'697,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'698,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'699,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'700,"""\nAuto-generated class for VMMigrate\n"""\n\nfrom . import client_support\n\n\nclass VMMigrate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(nodeid):\n        """\n        :type nodeid: str\n        :rtype: VMMigrate\n        """\n\n        return VMMigrate(\n            nodeid=nodeid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMMigrate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'nodeid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'701,class VMMigrate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(nodeid):\n        """\n        :type nodeid: str\n        :rtype: VMMigrate\n        """\n\n        return VMMigrate(\n            nodeid=nodeid,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMMigrate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'nodeid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'702,    @staticmethod\n    def create(nodeid):\n        """\n        :type nodeid: str\n        :rtype: VMMigrate\n        """\n\n        return VMMigrate(\n            nodeid=nodeid,\n        )\n'
u"703,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VMMigrate'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'nodeid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nodeid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'704,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'705,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'706,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'707,"""\nAuto-generated class for VMNicInfo\n"""\n\nfrom . import client_support\n\n\nclass VMNicInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(receivedPackets, receivedThroughput, transmittedPackets, transmittedThroughput):\n        """\n        :type receivedPackets: int\n        :type receivedThroughput: int\n        :type transmittedPackets: int\n        :type transmittedThroughput: int\n        :rtype: VMNicInfo\n        """\n\n        return VMNicInfo(\n            receivedPackets=receivedPackets,\n            receivedThroughput=receivedThroughput,\n            transmittedPackets=transmittedPackets,\n            transmittedThroughput=transmittedThroughput,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMNicInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'receivedPackets\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.receivedPackets = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'receivedThroughput\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.receivedThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'transmittedPackets\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.transmittedPackets = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'transmittedThroughput\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.transmittedThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'708,class VMNicInfo(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(receivedPackets, receivedThroughput, transmittedPackets, transmittedThroughput):\n        """\n        :type receivedPackets: int\n        :type receivedThroughput: int\n        :type transmittedPackets: int\n        :type transmittedThroughput: int\n        :rtype: VMNicInfo\n        """\n\n        return VMNicInfo(\n            receivedPackets=receivedPackets,\n            receivedThroughput=receivedThroughput,\n            transmittedPackets=transmittedPackets,\n            transmittedThroughput=transmittedThroughput,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMNicInfo\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'receivedPackets\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.receivedPackets = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'receivedThroughput\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.receivedThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'transmittedPackets\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.transmittedPackets = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'transmittedThroughput\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.transmittedThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'709,    @staticmethod\n    def create(receivedPackets, receivedThroughput, transmittedPackets, transmittedThroughput):\n        """\n        :type receivedPackets: int\n        :type receivedThroughput: int\n        :type transmittedPackets: int\n        :type transmittedThroughput: int\n        :rtype: VMNicInfo\n        """\n\n        return VMNicInfo(\n            receivedPackets=receivedPackets,\n            receivedThroughput=receivedThroughput,\n            transmittedPackets=transmittedPackets,\n            transmittedThroughput=transmittedThroughput,\n        )\n'
u"710,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VMNicInfo'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'receivedPackets'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.receivedPackets = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'receivedThroughput'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.receivedThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'transmittedPackets'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.transmittedPackets = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'transmittedThroughput'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.transmittedThroughput = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'711,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'712,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'713,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'714,"""\nAuto-generated class for VMUpdate\n"""\nfrom .NicLink import NicLink\nfrom .VDiskLink import VDiskLink\n\nfrom . import client_support\n\n\nclass VMUpdate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, disks, memory, nics):\n        """\n        :type cpu: int\n        :type disks: list[VDiskLink]\n        :type memory: int\n        :type nics: list[NicLink]\n        :rtype: VMUpdate\n        """\n\n        return VMUpdate(\n            cpu=cpu,\n            disks=disks,\n            memory=memory,\n            nics=nics,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMUpdate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'disks\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VDiskLink]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'memory\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.memory = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [NicLink]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'715,class VMUpdate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(cpu, disks, memory, nics):\n        """\n        :type cpu: int\n        :type disks: list[VDiskLink]\n        :type memory: int\n        :type nics: list[NicLink]\n        :rtype: VMUpdate\n        """\n\n        return VMUpdate(\n            cpu=cpu,\n            disks=disks,\n            memory=memory,\n            nics=nics,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VMUpdate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'cpu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'disks\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VDiskLink]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'memory\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.memory = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nics\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [NicLink]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'716,    @staticmethod\n    def create(cpu, disks, memory, nics):\n        """\n        :type cpu: int\n        :type disks: list[VDiskLink]\n        :type memory: int\n        :type nics: list[NicLink]\n        :rtype: VMUpdate\n        """\n\n        return VMUpdate(\n            cpu=cpu,\n            disks=disks,\n            memory=memory,\n            nics=nics,\n        )\n'
u"717,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VMUpdate'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'cpu'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.cpu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'disks'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [VDiskLink]\n            try:\n                self.disks = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'memory'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.memory = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nics'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [NicLink]\n            try:\n                self.nics = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'718,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'719,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'720,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'721,"""\nAuto-generated class for Vdisk\n"""\nfrom .EnumVdiskStatus import EnumVdiskStatus\nfrom .EnumVdiskType import EnumVdiskType\n\nfrom . import client_support\n\n\nclass Vdisk(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(blocksize, id, size, status, storagecluster, tlogStoragecluster, type, readOnly=None):\n        """\n        :type blocksize: int\n        :type id: str\n        :type readOnly: bool\n        :type size: int\n        :type status: EnumVdiskStatus\n        :type storagecluster: str\n        :type tlogStoragecluster: str\n        :type type: EnumVdiskType\n        :rtype: Vdisk\n        """\n\n        return Vdisk(\n            blocksize=blocksize,\n            id=id,\n            readOnly=readOnly,\n            size=size,\n            status=status,\n            storagecluster=storagecluster,\n            tlogStoragecluster=tlogStoragecluster,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Vdisk\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'blocksize\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.blocksize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readOnly\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'size\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'storagecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storagecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'tlogStoragecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.tlogStoragecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'722,class Vdisk(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(blocksize, id, size, status, storagecluster, tlogStoragecluster, type, readOnly=None):\n        """\n        :type blocksize: int\n        :type id: str\n        :type readOnly: bool\n        :type size: int\n        :type status: EnumVdiskStatus\n        :type storagecluster: str\n        :type tlogStoragecluster: str\n        :type type: EnumVdiskType\n        :rtype: Vdisk\n        """\n\n        return Vdisk(\n            blocksize=blocksize,\n            id=id,\n            readOnly=readOnly,\n            size=size,\n            status=status,\n            storagecluster=storagecluster,\n            tlogStoragecluster=tlogStoragecluster,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Vdisk\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'blocksize\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.blocksize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readOnly\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'size\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'storagecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storagecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'tlogStoragecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.tlogStoragecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'723,    @staticmethod\n    def create(blocksize, id, size, status, storagecluster, tlogStoragecluster, type, readOnly=None):\n        """\n        :type blocksize: int\n        :type id: str\n        :type readOnly: bool\n        :type size: int\n        :type status: EnumVdiskStatus\n        :type storagecluster: str\n        :type tlogStoragecluster: str\n        :type type: EnumVdiskType\n        :rtype: Vdisk\n        """\n\n        return Vdisk(\n            blocksize=blocksize,\n            id=id,\n            readOnly=readOnly,\n            size=size,\n            status=status,\n            storagecluster=storagecluster,\n            tlogStoragecluster=tlogStoragecluster,\n            type=type,\n        )\n'
u"724,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Vdisk'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'blocksize'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.blocksize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'readOnly'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'size'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'storagecluster'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storagecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'tlogStoragecluster'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.tlogStoragecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'type'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'725,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'726,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'727,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'728,"""\nAuto-generated class for VdiskCreate\n"""\nfrom .EnumVdiskCreateType import EnumVdiskCreateType\n\nfrom . import client_support\n\n\nclass VdiskCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(blocksize, id, size, storagecluster, type, readOnly=None, templatevdisk=None, tlogStoragecluster=None):\n        """\n        :type blocksize: int\n        :type id: str\n        :type readOnly: bool\n        :type size: int\n        :type storagecluster: str\n        :type templatevdisk: str\n        :type tlogStoragecluster: str\n        :type type: EnumVdiskCreateType\n        :rtype: VdiskCreate\n        """\n\n        return VdiskCreate(\n            blocksize=blocksize,\n            id=id,\n            readOnly=readOnly,\n            size=size,\n            storagecluster=storagecluster,\n            templatevdisk=templatevdisk,\n            tlogStoragecluster=tlogStoragecluster,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VdiskCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'blocksize\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.blocksize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readOnly\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'size\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'storagecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storagecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'templatevdisk\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.templatevdisk = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'tlogStoragecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.tlogStoragecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskCreateType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'729,class VdiskCreate(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(blocksize, id, size, storagecluster, type, readOnly=None, templatevdisk=None, tlogStoragecluster=None):\n        """\n        :type blocksize: int\n        :type id: str\n        :type readOnly: bool\n        :type size: int\n        :type storagecluster: str\n        :type templatevdisk: str\n        :type tlogStoragecluster: str\n        :type type: EnumVdiskCreateType\n        :rtype: VdiskCreate\n        """\n\n        return VdiskCreate(\n            blocksize=blocksize,\n            id=id,\n            readOnly=readOnly,\n            size=size,\n            storagecluster=storagecluster,\n            templatevdisk=templatevdisk,\n            tlogStoragecluster=tlogStoragecluster,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VdiskCreate\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'blocksize\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.blocksize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'readOnly\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'size\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'storagecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storagecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'templatevdisk\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.templatevdisk = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'tlogStoragecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.tlogStoragecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskCreateType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'730,    @staticmethod\n    def create(blocksize, id, size, storagecluster, type, readOnly=None, templatevdisk=None, tlogStoragecluster=None):\n        """\n        :type blocksize: int\n        :type id: str\n        :type readOnly: bool\n        :type size: int\n        :type storagecluster: str\n        :type templatevdisk: str\n        :type tlogStoragecluster: str\n        :type type: EnumVdiskCreateType\n        :rtype: VdiskCreate\n        """\n\n        return VdiskCreate(\n            blocksize=blocksize,\n            id=id,\n            readOnly=readOnly,\n            size=size,\n            storagecluster=storagecluster,\n            templatevdisk=templatevdisk,\n            tlogStoragecluster=tlogStoragecluster,\n            type=type,\n        )\n'
u"731,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VdiskCreate'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'blocksize'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.blocksize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'readOnly'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.readOnly = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'size'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.size = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'storagecluster'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storagecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'templatevdisk'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.templatevdisk = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'tlogStoragecluster'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.tlogStoragecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n        property_name = 'type'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskCreateType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'732,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'733,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'734,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'735,"""\nAuto-generated class for VdiskListItem\n"""\nfrom .EnumVdiskListItemStatus import EnumVdiskListItemStatus\nfrom .EnumVdiskListItemType import EnumVdiskListItemType\n\nfrom . import client_support\n\n\nclass VdiskListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, status, storagecluster, type):\n        """\n        :type id: str\n        :type status: EnumVdiskListItemStatus\n        :type storagecluster: str\n        :type type: EnumVdiskListItemType\n        :rtype: VdiskListItem\n        """\n\n        return VdiskListItem(\n            id=id,\n            status=status,\n            storagecluster=storagecluster,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VdiskListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'storagecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storagecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskListItemType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'736,class VdiskListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, status, storagecluster, type):\n        """\n        :type id: str\n        :type status: EnumVdiskListItemStatus\n        :type storagecluster: str\n        :type type: EnumVdiskListItemType\n        :rtype: VdiskListItem\n        """\n\n        return VdiskListItem(\n            id=id,\n            status=status,\n            storagecluster=storagecluster,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VdiskListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'storagecluster\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storagecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskListItemType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'737,    @staticmethod\n    def create(id, status, storagecluster, type):\n        """\n        :type id: str\n        :type status: EnumVdiskListItemStatus\n        :type storagecluster: str\n        :type type: EnumVdiskListItemType\n        :rtype: VdiskListItem\n        """\n\n        return VdiskListItem(\n            id=id,\n            status=status,\n            storagecluster=storagecluster,\n            type=type,\n        )\n'
u"738,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VdiskListItem'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskListItemStatus]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'storagecluster'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.storagecluster = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'type'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumVdiskListItemType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'739,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'740,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'741,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'742,"""\nAuto-generated class for VdiskResize\n"""\n\nfrom . import client_support\n\n\nclass VdiskResize(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(newSize):\n        """\n        :type newSize: int\n        :rtype: VdiskResize\n        """\n\n        return VdiskResize(\n            newSize=newSize,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VdiskResize\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'newSize\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.newSize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'743,class VdiskResize(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(newSize):\n        """\n        :type newSize: int\n        :rtype: VdiskResize\n        """\n\n        return VdiskResize(\n            newSize=newSize,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VdiskResize\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'newSize\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.newSize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'744,    @staticmethod\n    def create(newSize):\n        """\n        :type newSize: int\n        :rtype: VdiskResize\n        """\n\n        return VdiskResize(\n            newSize=newSize,\n        )\n'
u"745,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VdiskResize'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'newSize'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.newSize = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'746,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'747,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'748,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'749,"""\nAuto-generated class for VdiskRollback\n"""\n\nfrom . import client_support\n\n\nclass VdiskRollback(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(epoch):\n        """\n        :type epoch: int\n        :rtype: VdiskRollback\n        """\n\n        return VdiskRollback(\n            epoch=epoch,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VdiskRollback\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'epoch\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.epoch = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'750,class VdiskRollback(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(epoch):\n        """\n        :type epoch: int\n        :rtype: VdiskRollback\n        """\n\n        return VdiskRollback(\n            epoch=epoch,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'VdiskRollback\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'epoch\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.epoch = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'751,    @staticmethod\n    def create(epoch):\n        """\n        :type epoch: int\n        :rtype: VdiskRollback\n        """\n\n        return VdiskRollback(\n            epoch=epoch,\n        )\n'
u"752,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'VdiskRollback'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'epoch'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.epoch = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'753,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'754,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'755,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'756,"""\nAuto-generated class for WriteFile\n"""\n\nfrom . import client_support\n\n\nclass WriteFile(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(contents, path):\n        """\n        :type contents: str\n        :type path: str\n        :rtype: WriteFile\n        """\n\n        return WriteFile(\n            contents=contents,\n            path=path,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'WriteFile\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'contents\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.contents = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'path\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.path = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'757,class WriteFile(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(contents, path):\n        """\n        :type contents: str\n        :type path: str\n        :rtype: WriteFile\n        """\n\n        return WriteFile(\n            contents=contents,\n            path=path,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'WriteFile\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'contents\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.contents = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'path\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.path = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'758,    @staticmethod\n    def create(contents, path):\n        """\n        :type contents: str\n        :type path: str\n        :rtype: WriteFile\n        """\n\n        return WriteFile(\n            contents=contents,\n            path=path,\n        )\n'
u"759,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'WriteFile'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'contents'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.contents = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'path'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.path = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'760,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'761,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'762,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'763,"""\nAuto-generated class for Zerotier\n"""\nfrom .EnumZerotierType import EnumZerotierType\nfrom .ZerotierRoute import ZerotierRoute\n\nfrom . import client_support\n\n\nclass Zerotier(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(allowDefault, allowGlobal, allowManaged, assignedAddresses, bridge, broadcastEnabled, dhcp, mac, mtu, name, netconfRevision, nwid, portDeviceName, portError, routes, status, type):\n        """\n        :type allowDefault: bool\n        :type allowGlobal: bool\n        :type allowManaged: bool\n        :type assignedAddresses: list[str]\n        :type bridge: bool\n        :type broadcastEnabled: bool\n        :type dhcp: bool\n        :type mac: str\n        :type mtu: int\n        :type name: str\n        :type netconfRevision: int\n        :type nwid: str\n        :type portDeviceName: str\n        :type portError: int\n        :type routes: list[ZerotierRoute]\n        :type status: str\n        :type type: EnumZerotierType\n        :rtype: Zerotier\n        """\n\n        return Zerotier(\n            allowDefault=allowDefault,\n            allowGlobal=allowGlobal,\n            allowManaged=allowManaged,\n            assignedAddresses=assignedAddresses,\n            bridge=bridge,\n            broadcastEnabled=broadcastEnabled,\n            dhcp=dhcp,\n            mac=mac,\n            mtu=mtu,\n            name=name,\n            netconfRevision=netconfRevision,\n            nwid=nwid,\n            portDeviceName=portDeviceName,\n            portError=portError,\n            routes=routes,\n            status=status,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Zerotier\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'allowDefault\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.allowDefault = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'allowGlobal\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.allowGlobal = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'allowManaged\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.allowManaged = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'assignedAddresses\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.assignedAddresses = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'bridge\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.bridge = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'broadcastEnabled\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.broadcastEnabled = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dhcp\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.dhcp = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mac\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mac = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mtu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.mtu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'netconfRevision\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.netconfRevision = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nwid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nwid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portDeviceName\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.portDeviceName = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portError\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.portError = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'routes\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ZerotierRoute]\n            try:\n                self.routes = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumZerotierType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'764,class Zerotier(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(allowDefault, allowGlobal, allowManaged, assignedAddresses, bridge, broadcastEnabled, dhcp, mac, mtu, name, netconfRevision, nwid, portDeviceName, portError, routes, status, type):\n        """\n        :type allowDefault: bool\n        :type allowGlobal: bool\n        :type allowManaged: bool\n        :type assignedAddresses: list[str]\n        :type bridge: bool\n        :type broadcastEnabled: bool\n        :type dhcp: bool\n        :type mac: str\n        :type mtu: int\n        :type name: str\n        :type netconfRevision: int\n        :type nwid: str\n        :type portDeviceName: str\n        :type portError: int\n        :type routes: list[ZerotierRoute]\n        :type status: str\n        :type type: EnumZerotierType\n        :rtype: Zerotier\n        """\n\n        return Zerotier(\n            allowDefault=allowDefault,\n            allowGlobal=allowGlobal,\n            allowManaged=allowManaged,\n            assignedAddresses=assignedAddresses,\n            bridge=bridge,\n            broadcastEnabled=broadcastEnabled,\n            dhcp=dhcp,\n            mac=mac,\n            mtu=mtu,\n            name=name,\n            netconfRevision=netconfRevision,\n            nwid=nwid,\n            portDeviceName=portDeviceName,\n            portError=portError,\n            routes=routes,\n            status=status,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'Zerotier\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'allowDefault\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.allowDefault = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'allowGlobal\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.allowGlobal = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'allowManaged\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.allowManaged = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'assignedAddresses\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.assignedAddresses = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'bridge\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.bridge = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'broadcastEnabled\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.broadcastEnabled = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'dhcp\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.dhcp = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mac\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mac = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'mtu\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.mtu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'netconfRevision\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.netconfRevision = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nwid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nwid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portDeviceName\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.portDeviceName = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'portError\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.portError = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'routes\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ZerotierRoute]\n            try:\n                self.routes = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumZerotierType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'765,    @staticmethod\n    def create(allowDefault, allowGlobal, allowManaged, assignedAddresses, bridge, broadcastEnabled, dhcp, mac, mtu, name, netconfRevision, nwid, portDeviceName, portError, routes, status, type):\n        """\n        :type allowDefault: bool\n        :type allowGlobal: bool\n        :type allowManaged: bool\n        :type assignedAddresses: list[str]\n        :type bridge: bool\n        :type broadcastEnabled: bool\n        :type dhcp: bool\n        :type mac: str\n        :type mtu: int\n        :type name: str\n        :type netconfRevision: int\n        :type nwid: str\n        :type portDeviceName: str\n        :type portError: int\n        :type routes: list[ZerotierRoute]\n        :type status: str\n        :type type: EnumZerotierType\n        :rtype: Zerotier\n        """\n\n        return Zerotier(\n            allowDefault=allowDefault,\n            allowGlobal=allowGlobal,\n            allowManaged=allowManaged,\n            assignedAddresses=assignedAddresses,\n            bridge=bridge,\n            broadcastEnabled=broadcastEnabled,\n            dhcp=dhcp,\n            mac=mac,\n            mtu=mtu,\n            name=name,\n            netconfRevision=netconfRevision,\n            nwid=nwid,\n            portDeviceName=portDeviceName,\n            portError=portError,\n            routes=routes,\n            status=status,\n            type=type,\n        )\n'
u"766,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'Zerotier'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'allowDefault'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.allowDefault = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'allowGlobal'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.allowGlobal = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'allowManaged'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.allowManaged = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'assignedAddresses'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.assignedAddresses = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'bridge'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.bridge = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'broadcastEnabled'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.broadcastEnabled = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'dhcp'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [bool]\n            try:\n                self.dhcp = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'mac'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.mac = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'mtu'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.mtu = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'netconfRevision'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.netconfRevision = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nwid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nwid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'portDeviceName'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.portDeviceName = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'portError'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.portError = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'routes'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [ZerotierRoute]\n            try:\n                self.routes = client_support.list_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'type'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumZerotierType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'767,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'768,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'769,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'770,"""\nAuto-generated class for ZerotierBridge\n"""\n\nfrom . import client_support\n\n\nclass ZerotierBridge(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, token=None):\n        """\n        :type id: str\n        :type token: str\n        :rtype: ZerotierBridge\n        """\n\n        return ZerotierBridge(\n            id=id,\n            token=token,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ZerotierBridge\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'token\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.token = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'771,class ZerotierBridge(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(id, token=None):\n        """\n        :type id: str\n        :type token: str\n        :rtype: ZerotierBridge\n        """\n\n        return ZerotierBridge(\n            id=id,\n            token=token,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ZerotierBridge\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'id\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'token\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.token = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'772,    @staticmethod\n    def create(id, token=None):\n        """\n        :type id: str\n        :type token: str\n        :rtype: ZerotierBridge\n        """\n\n        return ZerotierBridge(\n            id=id,\n            token=token,\n        )\n'
u"773,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ZerotierBridge'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'id'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.id = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'token'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.token = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'774,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'775,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'776,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'777,"""\nAuto-generated class for ZerotierJoin\n"""\n\nfrom . import client_support\n\n\nclass ZerotierJoin(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(nwid, token=None):\n        """\n        :type nwid: str\n        :type token: str\n        :rtype: ZerotierJoin\n        """\n\n        return ZerotierJoin(\n            nwid=nwid,\n            token=token,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ZerotierJoin\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'nwid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nwid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'token\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.token = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'778,class ZerotierJoin(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(nwid, token=None):\n        """\n        :type nwid: str\n        :type token: str\n        :rtype: ZerotierJoin\n        """\n\n        return ZerotierJoin(\n            nwid=nwid,\n            token=token,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ZerotierJoin\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'nwid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nwid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'token\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.token = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'779,    @staticmethod\n    def create(nwid, token=None):\n        """\n        :type nwid: str\n        :type token: str\n        :rtype: ZerotierJoin\n        """\n\n        return ZerotierJoin(\n            nwid=nwid,\n            token=token,\n        )\n'
u"780,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ZerotierJoin'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'nwid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nwid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'token'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.token = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n"
u'781,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'782,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'783,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'784,"""\nAuto-generated class for ZerotierListItem\n"""\nfrom .EnumZerotierListItemType import EnumZerotierListItemType\n\nfrom . import client_support\n\n\nclass ZerotierListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, nwid, status, type):\n        """\n        :type name: str\n        :type nwid: str\n        :type status: str\n        :type type: EnumZerotierListItemType\n        :rtype: ZerotierListItem\n        """\n\n        return ZerotierListItem(\n            name=name,\n            nwid=nwid,\n            status=status,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ZerotierListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nwid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nwid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumZerotierListItemType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'785,class ZerotierListItem(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(name, nwid, status, type):\n        """\n        :type name: str\n        :type nwid: str\n        :type status: str\n        :type type: EnumZerotierListItemType\n        :rtype: ZerotierListItem\n        """\n\n        return ZerotierListItem(\n            name=name,\n            nwid=nwid,\n            status=status,\n            type=type,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ZerotierListItem\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'name\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'nwid\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nwid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'status\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'type\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumZerotierListItemType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'786,    @staticmethod\n    def create(name, nwid, status, type):\n        """\n        :type name: str\n        :type nwid: str\n        :type status: str\n        :type type: EnumZerotierListItemType\n        :rtype: ZerotierListItem\n        """\n\n        return ZerotierListItem(\n            name=name,\n            nwid=nwid,\n            status=status,\n            type=type,\n        )\n'
u"787,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ZerotierListItem'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'name'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.name = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'nwid'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.nwid = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'status'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.status = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'type'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [EnumZerotierListItemType]\n            try:\n                self.type = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'788,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'789,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'790,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'791,"""\nAuto-generated class for ZerotierRoute\n"""\n\nfrom . import client_support\n\n\nclass ZerotierRoute(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(flags, metric, target, via):\n        """\n        :type flags: int\n        :type metric: int\n        :type target: str\n        :type via: str\n        :rtype: ZerotierRoute\n        """\n\n        return ZerotierRoute(\n            flags=flags,\n            metric=metric,\n            target=target,\n            via=via,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ZerotierRoute\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'flags\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.flags = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'metric\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.metric = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'target\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.target = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'via\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.via = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'792,class ZerotierRoute(object):\n    """\n    auto-generated. don\'t touch.\n    """\n\n    @staticmethod\n    def create(flags, metric, target, via):\n        """\n        :type flags: int\n        :type metric: int\n        :type target: str\n        :type via: str\n        :rtype: ZerotierRoute\n        """\n\n        return ZerotierRoute(\n            flags=flags,\n            metric=metric,\n            target=target,\n            via=via,\n        )\n\n    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError(\'No data or kwargs present\')\n\n        class_name = \'ZerotierRoute\'\n        create_error = \'{cls}: unable to create {prop} from value: {val}: {err}\'\n        required_error = \'{cls}: missing required property {prop}\'\n\n        data = json or kwargs\n\n        property_name = \'flags\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.flags = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'metric\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.metric = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'target\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.target = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = \'via\'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.via = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n    def __str__(self):\n        return self.as_json(indent=4)\n\n    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n\n    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'793,    @staticmethod\n    def create(flags, metric, target, via):\n        """\n        :type flags: int\n        :type metric: int\n        :type target: str\n        :type via: str\n        :rtype: ZerotierRoute\n        """\n\n        return ZerotierRoute(\n            flags=flags,\n            metric=metric,\n            target=target,\n            via=via,\n        )\n'
u"794,    def __init__(self, json=None, **kwargs):\n        if json is None and not kwargs:\n            raise ValueError('No data or kwargs present')\n\n        class_name = 'ZerotierRoute'\n        create_error = '{cls}: unable to create {prop} from value: {val}: {err}'\n        required_error = '{cls}: missing required property {prop}'\n\n        data = json or kwargs\n\n        property_name = 'flags'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.flags = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'metric'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [int]\n            try:\n                self.metric = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'target'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.target = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n\n        property_name = 'via'\n        val = data.get(property_name)\n        if val is not None:\n            datatypes = [str]\n            try:\n                self.via = client_support.val_factory(val, datatypes)\n            except ValueError as err:\n                raise ValueError(create_error.format(cls=class_name, prop=property_name, val=val, err=err))\n        else:\n            raise ValueError(required_error.format(cls=class_name, prop=property_name))\n"
u'795,    def __str__(self):\n        return self.as_json(indent=4)\n'
u'796,    def as_json(self, indent=0):\n        return client_support.to_json(self, indent=indent)\n'
u'797,    def as_dict(self):\n        return client_support.to_dict(self)\n'
u'798,import requests\n\n\nfrom .Bridge import Bridge\nfrom .BridgeCreate import BridgeCreate\nfrom .BridgeCreateSetting import BridgeCreateSetting\nfrom .CPUInfo import CPUInfo\nfrom .CPUStats import CPUStats\nfrom .CloudInit import CloudInit\nfrom .Cluster import Cluster\nfrom .ClusterCreate import ClusterCreate\nfrom .Container import Container\nfrom .ContainerListItem import ContainerListItem\nfrom .ContainerNIC import ContainerNIC\nfrom .ContainerNICconfig import ContainerNICconfig\nfrom .CoreStateResult import CoreStateResult\nfrom .CoreSystem import CoreSystem\nfrom .CreateContainer import CreateContainer\nfrom .CreateSnapshotReqBody import CreateSnapshotReqBody\nfrom .DHCP import DHCP\nfrom .DeleteFile import DeleteFile\nfrom .DiskInfo import DiskInfo\nfrom .DiskPartition import DiskPartition\nfrom .EnumBridgeCreateNetworkMode import EnumBridgeCreateNetworkMode\nfrom .EnumBridgeStatus import EnumBridgeStatus\nfrom .EnumClusterCreateClusterType import EnumClusterCreateClusterType\nfrom .EnumClusterCreateDriveType import EnumClusterCreateDriveType\nfrom .EnumClusterDriveType import EnumClusterDriveType\nfrom .EnumClusterStatus import EnumClusterStatus\nfrom .EnumContainerListItemStatus import EnumContainerListItemStatus\nfrom .EnumContainerNICStatus import EnumContainerNICStatus\nfrom .EnumContainerNICType import EnumContainerNICType\nfrom .EnumContainerStatus import EnumContainerStatus\nfrom .EnumDiskInfoType import EnumDiskInfoType\nfrom .EnumGWNICType import EnumGWNICType\nfrom .EnumJobResultName import EnumJobResultName\nfrom .EnumJobResultState import EnumJobResultState\nfrom .EnumNicLinkType import EnumNicLinkType\nfrom .EnumNodeStatus import EnumNodeStatus\nfrom .EnumStoragePoolCreateDataProfile import EnumStoragePoolCreateDataProfile\nfrom .EnumStoragePoolCreateMetadataProfile import EnumStoragePoolCreateMetadataProfile\nfrom .EnumStoragePoolDataProfile import EnumStoragePoolDataProfile\nfrom .EnumStoragePoolDeviceStatus import EnumStoragePoolDeviceStatus\nfrom .EnumStoragePoolListItemStatus import EnumStoragePoolListItemStatus\nfrom .EnumStoragePoolMetadataProfile import EnumStoragePoolMetadataProfile\nfrom .EnumStoragePoolStatus import EnumStoragePoolStatus\nfrom .EnumStorageServerStatus import EnumStorageServerStatus\nfrom .EnumVMListItemStatus import EnumVMListItemStatus\nfrom .EnumVMStatus import EnumVMStatus\nfrom .EnumVdiskCreateType import EnumVdiskCreateType\nfrom .EnumVdiskListItemStatus import EnumVdiskListItemStatus\nfrom .EnumVdiskListItemType import EnumVdiskListItemType\nfrom .EnumVdiskStatus import EnumVdiskStatus\nfrom .EnumVdiskType import EnumVdiskType\nfrom .EnumZerotierListItemType import EnumZerotierListItemType\nfrom .EnumZerotierType import EnumZerotierType\nfrom .Filesystem import Filesystem\nfrom .FilesystemCreate import FilesystemCreate\nfrom .GW import GW\nfrom .GWCreate import GWCreate\nfrom .GWHost import GWHost\nfrom .GWNIC import GWNIC\nfrom .GWNICconfig import GWNICconfig\nfrom .GetGW import GetGW\nfrom .HTTPProxy import HTTPProxy\nfrom .HTTPType import HTTPType\nfrom .IPProtocol import IPProtocol\nfrom .Job import Job\nfrom .JobListItem import JobListItem\nfrom .JobResult import JobResult\nfrom .ListGW import ListGW\nfrom .MemInfo import MemInfo\nfrom .NicInfo import NicInfo\nfrom .NicLink import NicLink\nfrom .Node import Node\nfrom .NodeMount import NodeMount\nfrom .OSInfo import OSInfo\nfrom .PortForward import PortForward\nfrom .Process import Process\nfrom .ProcessSignal import ProcessSignal\nfrom .Run import Run\nfrom .RunState import RunState\nfrom .Snapshot import Snapshot\nfrom .StoragePool import StoragePool\nfrom .StoragePoolCreate import StoragePoolCreate\nfrom .StoragePoolDevice import StoragePoolDevice\nfrom .StoragePoolListItem import StoragePoolListItem\nfrom .StorageServer import StorageServer\nfrom .VDiskLink import VDiskLink\nfrom .VM import VM\nfrom .VMCreate import VMCreate\nfrom .VMDiskInfo import VMDiskInfo\nfrom .VMInfo import VMInfo\nfrom .VMListItem import VMListItem\nfrom .VMMigrate import VMMigrate\nfrom .VMNicInfo import VMNicInfo\nfrom .VMUpdate import VMUpdate\nfrom .Vdisk import Vdisk\nfrom .VdiskCreate import VdiskCreate\nfrom .VdiskListItem import VdiskListItem\nfrom .VdiskResize import VdiskResize\nfrom .VdiskRollback import VdiskRollback\nfrom .WriteFile import WriteFile\nfrom .Zerotier import Zerotier\nfrom .ZerotierBridge import ZerotierBridge\nfrom .ZerotierJoin import ZerotierJoin\nfrom .ZerotierListItem import ZerotierListItem\nfrom .ZerotierRoute import ZerotierRoute\n\nfrom .client import Client as APIClient\n\nfrom .oauth2_client_itsyouonline import Oauth2ClientItsyouonline\n\nclass Client:\n    def __init__(self, base_uri=""):\n        self.api = APIClient(base_uri)\n        \n        self.oauth2_client_itsyouonline = Oauth2ClientItsyouonline()\n'
u'799,class Client:\n    def __init__(self, base_uri=""):\n        self.api = APIClient(base_uri)\n        \n        self.oauth2_client_itsyouonline = Oauth2ClientItsyouonline()\n'
u'800,    def __init__(self, base_uri=""):\n        self.api = APIClient(base_uri)\n        \n        self.oauth2_client_itsyouonline = Oauth2ClientItsyouonline()\n'
u'801,import requests\n\nfrom .nodes_service import NodesService \nfrom .runs_service import RunsService \nfrom .storageclusters_service import StorageclustersService \nfrom .vdisks_service import VdisksService \n\n\nclass Client:\n    def __init__(self, base_uri=""):\n        self.base_url = base_uri\n        self.session = requests.Session()\n        \n        self.nodes = NodesService(self)\n        self.runs = RunsService(self)\n        self.storageclusters = StorageclustersService(self)\n        self.vdisks = VdisksService(self)\n\n    def is_goraml_class(self, data):\n        # check if a data is go-raml generated class\n        # we currently only check the existence\n        # of as_json method\n        op = getattr(data, "as_json", None)\n        if callable(op):\n            return True\n        return False\n\n    def set_auth_header(self, val):\n        \'\'\' set authorization header value\'\'\'\n        self.session.headers.update({"Authorization": val})\n\n    def _get_headers(self, headers, content_type):\n        if content_type:\n            contentheader = {"Content-Type": content_type}\n            if headers is None:\n                headers = contentheader\n            else:\n                headers.update(contentheader)\n        return headers\n\n    def _handle_data(self, uri, data, headers, params, content_type, method):\n        headers = self._get_headers(headers, content_type)\n        if self.is_goraml_class(data):\n            data = data.as_json()\n\n        if content_type == "multipart/form-data":\n            # when content type is multipart/formdata remove the content-type header\n            # as requests will set this itself with correct boundary\n            headers.pop(\'Content-Type\')\n            res = method(uri, files=data, headers=headers, params=params)\n        elif data is None:\n            res = method(uri, headers=headers, params=params)\n        elif type(data) is str:\n            res = method(uri, data=data, headers=headers, params=params)\n        else:\n            res = method(uri, json=data, headers=headers, params=params)\n        res.raise_for_status()\n        return res\n\n    def post(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.post)\n\n    def put(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.put)\n\n    def patch(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.patch)\n\n    def get(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.get)\n\n    def delete(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.delete)\n'
u'802,class Client:\n    def __init__(self, base_uri=""):\n        self.base_url = base_uri\n        self.session = requests.Session()\n        \n        self.nodes = NodesService(self)\n        self.runs = RunsService(self)\n        self.storageclusters = StorageclustersService(self)\n        self.vdisks = VdisksService(self)\n\n    def is_goraml_class(self, data):\n        # check if a data is go-raml generated class\n        # we currently only check the existence\n        # of as_json method\n        op = getattr(data, "as_json", None)\n        if callable(op):\n            return True\n        return False\n\n    def set_auth_header(self, val):\n        \'\'\' set authorization header value\'\'\'\n        self.session.headers.update({"Authorization": val})\n\n    def _get_headers(self, headers, content_type):\n        if content_type:\n            contentheader = {"Content-Type": content_type}\n            if headers is None:\n                headers = contentheader\n            else:\n                headers.update(contentheader)\n        return headers\n\n    def _handle_data(self, uri, data, headers, params, content_type, method):\n        headers = self._get_headers(headers, content_type)\n        if self.is_goraml_class(data):\n            data = data.as_json()\n\n        if content_type == "multipart/form-data":\n            # when content type is multipart/formdata remove the content-type header\n            # as requests will set this itself with correct boundary\n            headers.pop(\'Content-Type\')\n            res = method(uri, files=data, headers=headers, params=params)\n        elif data is None:\n            res = method(uri, headers=headers, params=params)\n        elif type(data) is str:\n            res = method(uri, data=data, headers=headers, params=params)\n        else:\n            res = method(uri, json=data, headers=headers, params=params)\n        res.raise_for_status()\n        return res\n\n    def post(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.post)\n\n    def put(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.put)\n\n    def patch(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.patch)\n\n    def get(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.get)\n\n    def delete(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.delete)\n'
u'803,    def __init__(self, base_uri=""):\n        self.base_url = base_uri\n        self.session = requests.Session()\n        \n        self.nodes = NodesService(self)\n        self.runs = RunsService(self)\n        self.storageclusters = StorageclustersService(self)\n        self.vdisks = VdisksService(self)\n'
u'804,    def is_goraml_class(self, data):\n        # check if a data is go-raml generated class\n        # we currently only check the existence\n        # of as_json method\n        op = getattr(data, "as_json", None)\n        if callable(op):\n            return True\n        return False\n'
u'805,    def set_auth_header(self, val):\n        \'\'\' set authorization header value\'\'\'\n        self.session.headers.update({"Authorization": val})\n'
u'806,    def _get_headers(self, headers, content_type):\n        if content_type:\n            contentheader = {"Content-Type": content_type}\n            if headers is None:\n                headers = contentheader\n            else:\n                headers.update(contentheader)\n        return headers\n'
u'807,    def _handle_data(self, uri, data, headers, params, content_type, method):\n        headers = self._get_headers(headers, content_type)\n        if self.is_goraml_class(data):\n            data = data.as_json()\n\n        if content_type == "multipart/form-data":\n            # when content type is multipart/formdata remove the content-type header\n            # as requests will set this itself with correct boundary\n            headers.pop(\'Content-Type\')\n            res = method(uri, files=data, headers=headers, params=params)\n        elif data is None:\n            res = method(uri, headers=headers, params=params)\n        elif type(data) is str:\n            res = method(uri, data=data, headers=headers, params=params)\n        else:\n            res = method(uri, json=data, headers=headers, params=params)\n        res.raise_for_status()\n        return res\n'
u'808,    def post(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.post)\n'
u'809,    def put(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.put)\n'
u'810,    def patch(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.patch)\n'
u'811,    def get(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.get)\n'
u'812,    def delete(self, uri, data, headers, params, content_type):\n        return self._handle_data(uri, data, headers, params, content_type, self.session.delete)\n'
u'813,"""\nsupport methods for python clients\n"""\n\nimport json\nimport collections\nfrom datetime import datetime\nfrom uuid import UUID\nfrom enum import Enum\nfrom dateutil import parser\n\n\n# python2/3 compatible basestring, for use in to_dict\ntry:\n    basestring\nexcept NameError:\n    basestring = str\n\n\ndef timestamp_from_datetime(datetime):\n    """\n        Convert from datetime format to timestamp format\n        Input: Time in datetime format\n        Output: Time in timestamp format\n    """\n    return datetime.strftime(\'%Y-%m-%dT%H:%M:%S.%fZ\')\n\n\ndef timestamp_to_datetime(timestamp):\n    """\n        Convert from timestamp format to datetime format\n        Input: Time in timestamp format\n        Output: Time in datetime format\n    """\n    return parser.parse(timestamp).replace(tzinfo=None)\n\n\ndef has_properties(cls, property, child_properties):\n    for child_prop in child_properties:\n        if getattr(property, child_prop, None) is None:\n            return False\n\n    return True\n\n\ndef list_factory(val, member_type):\n    if not isinstance(val, list):\n        raise ValueError(\'list_factory: value must be a list\')\n    return [val_factory(v, member_type) for v in val]\n\n\ndef dict_factory(val, objmap):\n    # objmap is a dict outlining the structure of this value\n    # its format is {\'attrname\': {\'datatype\': [type], \'required\': bool}}\n    objdict = {}\n    for attrname, attrdict in objmap.items():\n        value = val.get(attrname)\n        if value is not None:\n            for dt in attrdict[\'datatype\']:\n                try:\n                    if isinstance(dt, dict):\n                        objdict[attrname] = dict_factory(value, attrdict)\n                    else:\n                        objdict[attrname] = val_factory(value, [dt])\n                except Exception:\n                    pass\n            if objdict.get(attrname) is None:\n                raise ValueError(\'dict_factory: {attr}: unable to instantiate with any supplied type\'.format(attr=attrname))\n        elif attrdict.get(\'required\'):\n            raise ValueError(\'dict_factory: {attr} is required\'.format(attr=attrname))\n\n    return objdict\n\n\ndef val_factory(val, datatypes):\n    """\n    return an instance of `val` that is of type `datatype`.\n    keep track of exceptions so we can produce meaningful error messages.\n    """\n    exceptions = []\n    for dt in datatypes:\n        try:\n            if isinstance(val, dt):\n                return val\n            return type_handler_object(val, dt)\n        except Exception as e:\n            exceptions.append(str(e))\n    # if we get here, we never found a valid value. raise an error\n    raise ValueError(\'val_factory: Unable to instantiate {val} from types {types}. Exceptions: {excs}\'.\n                     format(val=val, types=datatypes, excs=exceptions))\n\n\ndef to_json(cls, indent=0):\n    """\n    serialize to JSON\n    :rtype: str\n    """\n    # for consistency, use as_dict then go to json from there\n    return json.dumps(cls.as_dict(), indent=indent)\n\n\ndef to_dict(cls, convert_datetime=True):\n    """\n    return a dict representation of the Event and its sub-objects\n    `convert_datetime` controls whether datetime objects are converted to strings or not\n    :rtype: dict\n    """\n    def todict(obj):\n        """\n        recurse the objects and represent as a dict\n        use the registered handlers if possible\n        """\n        data = {}\n        if isinstance(obj, dict):\n            for (key, val) in obj.items():\n                data[key] = todict(val)\n            return data\n        if not convert_datetime and isinstance(obj, datetime):\n            return obj\n        elif type_handler_value(obj):\n            return type_handler_value(obj)\n        elif isinstance(obj, collections.Sequence) and not isinstance(obj, basestring):\n            return [todict(v) for v in obj]\n        elif hasattr(obj, "__dict__"):\n            for key, value in obj.__dict__.items():\n                if not callable(value) and not key.startswith(\'_\'):\n                    data[key] = todict(value)\n            return data\n        else:\n            return obj\n\n    return todict(cls)\n\n\nclass DatetimeHandler(object):\n    """\n    output datetime objects as iso-8601 compliant strings\n    """\n    @classmethod\n    def flatten(cls, obj):\n        """flatten"""\n        return timestamp_from_datetime(obj)\n\n    @classmethod\n    def restore(cls, data):\n        """restore"""\n        return timestamp_to_datetime(data)\n\n\nclass UUIDHandler(object):\n    """\n    output UUID objects as a string\n    """\n    @classmethod\n    def flatten(cls, obj):\n        """flatten"""\n        return str(obj)\n\n    @classmethod\n    def restore(cls, data):\n        """restore"""\n        return UUID(data)\n\n\nclass EnumHandler(object):\n    """\n    output Enum objects as their value\n    """\n    @classmethod\n    def flatten(cls, obj):\n        """flatten"""\n        return obj.value\n\n    @classmethod\n    def restore(cls, data):\n        """\n        cannot restore here because we don\'t know what type of enum it is\n        """\n        raise NotImplementedError\n\n\nhandlers = {\n    datetime: DatetimeHandler,\n    Enum: EnumHandler,\n    UUID: UUIDHandler,\n}\n\n\ndef handler_for(obj):\n    """return the handler for the object type"""\n    for handler_type in handlers:\n        if isinstance(obj, handler_type):\n            return handlers[handler_type]\n\n    try:\n        for handler_type in handlers:\n            if issubclass(obj, handler_type):\n                return handlers[handler_type]\n    except TypeError:\n        # if obj isn\'t a class, issubclass will raise a TypeError\n        pass\n\n\ndef type_handler_value(obj):\n    """\n    return the serialized (flattened) value from the registered handler for the type\n    """\n    handler = handler_for(obj)\n    if handler:\n        return handler().flatten(obj)\n\n\ndef type_handler_object(val, objtype):\n    """\n    return the deserialized (restored) value from the registered handler for the type\n    """\n    handler = handlers.get(objtype)\n    if handler:\n        return handler().restore(val)\n    else:\n        return objtype(val)\n'
u'814,def timestamp_from_datetime(datetime):\n    """\n        Convert from datetime format to timestamp format\n        Input: Time in datetime format\n        Output: Time in timestamp format\n    """\n    return datetime.strftime(\'%Y-%m-%dT%H:%M:%S.%fZ\')\n'
u'815,def timestamp_to_datetime(timestamp):\n    """\n        Convert from timestamp format to datetime format\n        Input: Time in timestamp format\n        Output: Time in datetime format\n    """\n    return parser.parse(timestamp).replace(tzinfo=None)\n'
u'816,def has_properties(cls, property, child_properties):\n    for child_prop in child_properties:\n        if getattr(property, child_prop, None) is None:\n            return False\n\n    return True\n'
u"817,def list_factory(val, member_type):\n    if not isinstance(val, list):\n        raise ValueError('list_factory: value must be a list')\n    return [val_factory(v, member_type) for v in val]\n"
u"818,def dict_factory(val, objmap):\n    # objmap is a dict outlining the structure of this value\n    # its format is {'attrname': {'datatype': [type], 'required': bool}}\n    objdict = {}\n    for attrname, attrdict in objmap.items():\n        value = val.get(attrname)\n        if value is not None:\n            for dt in attrdict['datatype']:\n                try:\n                    if isinstance(dt, dict):\n                        objdict[attrname] = dict_factory(value, attrdict)\n                    else:\n                        objdict[attrname] = val_factory(value, [dt])\n                except Exception:\n                    pass\n            if objdict.get(attrname) is None:\n                raise ValueError('dict_factory: {attr}: unable to instantiate with any supplied type'.format(attr=attrname))\n        elif attrdict.get('required'):\n            raise ValueError('dict_factory: {attr} is required'.format(attr=attrname))\n\n    return objdict\n"
u'819,def val_factory(val, datatypes):\n    """\n    return an instance of `val` that is of type `datatype`.\n    keep track of exceptions so we can produce meaningful error messages.\n    """\n    exceptions = []\n    for dt in datatypes:\n        try:\n            if isinstance(val, dt):\n                return val\n            return type_handler_object(val, dt)\n        except Exception as e:\n            exceptions.append(str(e))\n    # if we get here, we never found a valid value. raise an error\n    raise ValueError(\'val_factory: Unable to instantiate {val} from types {types}. Exceptions: {excs}\'.\n                     format(val=val, types=datatypes, excs=exceptions))\n'
u'820,def to_json(cls, indent=0):\n    """\n    serialize to JSON\n    :rtype: str\n    """\n    # for consistency, use as_dict then go to json from there\n    return json.dumps(cls.as_dict(), indent=indent)\n'
u'821,def to_dict(cls, convert_datetime=True):\n    """\n    return a dict representation of the Event and its sub-objects\n    `convert_datetime` controls whether datetime objects are converted to strings or not\n    :rtype: dict\n    """\n    def todict(obj):\n        """\n        recurse the objects and represent as a dict\n        use the registered handlers if possible\n        """\n        data = {}\n        if isinstance(obj, dict):\n            for (key, val) in obj.items():\n                data[key] = todict(val)\n            return data\n        if not convert_datetime and isinstance(obj, datetime):\n            return obj\n        elif type_handler_value(obj):\n            return type_handler_value(obj)\n        elif isinstance(obj, collections.Sequence) and not isinstance(obj, basestring):\n            return [todict(v) for v in obj]\n        elif hasattr(obj, "__dict__"):\n            for key, value in obj.__dict__.items():\n                if not callable(value) and not key.startswith(\'_\'):\n                    data[key] = todict(value)\n            return data\n        else:\n            return obj\n\n    return todict(cls)\n'
u'822,class DatetimeHandler(object):\n    """\n    output datetime objects as iso-8601 compliant strings\n    """\n    @classmethod\n    def flatten(cls, obj):\n        """flatten"""\n        return timestamp_from_datetime(obj)\n\n    @classmethod\n    def restore(cls, data):\n        """restore"""\n        return timestamp_to_datetime(data)\n'
u'823,class UUIDHandler(object):\n    """\n    output UUID objects as a string\n    """\n    @classmethod\n    def flatten(cls, obj):\n        """flatten"""\n        return str(obj)\n\n    @classmethod\n    def restore(cls, data):\n        """restore"""\n        return UUID(data)\n'
u'824,class EnumHandler(object):\n    """\n    output Enum objects as their value\n    """\n    @classmethod\n    def flatten(cls, obj):\n        """flatten"""\n        return obj.value\n\n    @classmethod\n    def restore(cls, data):\n        """\n        cannot restore here because we don\'t know what type of enum it is\n        """\n        raise NotImplementedError\n'
u'825,def handler_for(obj):\n    """return the handler for the object type"""\n    for handler_type in handlers:\n        if isinstance(obj, handler_type):\n            return handlers[handler_type]\n\n    try:\n        for handler_type in handlers:\n            if issubclass(obj, handler_type):\n                return handlers[handler_type]\n    except TypeError:\n        # if obj isn\'t a class, issubclass will raise a TypeError\n        pass\n'
u'826,def type_handler_value(obj):\n    """\n    return the serialized (flattened) value from the registered handler for the type\n    """\n    handler = handler_for(obj)\n    if handler:\n        return handler().flatten(obj)\n'
u'827,def type_handler_object(val, objtype):\n    """\n    return the deserialized (restored) value from the registered handler for the type\n    """\n    handler = handlers.get(objtype)\n    if handler:\n        return handler().restore(val)\n    else:\n        return objtype(val)\n'
u'828,    def todict(obj):\n        """\n        recurse the objects and represent as a dict\n        use the registered handlers if possible\n        """\n        data = {}\n        if isinstance(obj, dict):\n            for (key, val) in obj.items():\n                data[key] = todict(val)\n            return data\n        if not convert_datetime and isinstance(obj, datetime):\n            return obj\n        elif type_handler_value(obj):\n            return type_handler_value(obj)\n        elif isinstance(obj, collections.Sequence) and not isinstance(obj, basestring):\n            return [todict(v) for v in obj]\n        elif hasattr(obj, "__dict__"):\n            for key, value in obj.__dict__.items():\n                if not callable(value) and not key.startswith(\'_\'):\n                    data[key] = todict(value)\n            return data\n        else:\n            return obj\n'
u'829,    @classmethod\n    def flatten(cls, obj):\n        """flatten"""\n        return timestamp_from_datetime(obj)\n'
u'830,    @classmethod\n    def restore(cls, data):\n        """restore"""\n        return timestamp_to_datetime(data)\n'
u'831,    @classmethod\n    def flatten(cls, obj):\n        """flatten"""\n        return str(obj)\n'
u'832,    @classmethod\n    def restore(cls, data):\n        """restore"""\n        return UUID(data)\n'
u'833,    @classmethod\n    def flatten(cls, obj):\n        """flatten"""\n        return obj.value\n'
u'834,    @classmethod\n    def restore(cls, data):\n        """\n        cannot restore here because we don\'t know what type of enum it is\n        """\n        raise NotImplementedError\n'
u'835,import datetime\nimport time\n\n\ndef generate_rfc3339(d, local_tz=True):\n    """\n    generate rfc3339 time format\n    input :\n    d = date type\n    local_tz = use local time zone if true,\n    otherwise mark as utc\n\n    output :\n    rfc3339 string date format. ex : `2008-04-02T20:00:00+07:00`\n    """\n    try:\n        if local_tz:\n            d = datetime.datetime.fromtimestamp(d)\n        else:\n            d = datetime.datetime.utcfromtimestamp(d)\n    except TypeError:\n        pass\n\n    if not isinstance(d, datetime.date):\n        raise TypeError(\'Not timestamp or date object. Got %r.\' % type(d))\n\n    if not isinstance(d, datetime.datetime):\n        d = datetime.datetime(*d.timetuple()[:3])\n\n    return (\'%04d-%02d-%02dT%02d:%02d:%02d%s\' %\n            (d.year, d.month, d.day, d.hour, d.minute, d.second,\n             _generate_timezone(d, local_tz)))\n\n\ndef _calculate_offset(date, local_tz):\n    """\n    input :\n    date : date type\n    local_tz : if true, use system timezone, otherwise return 0\n\n    return the date of UTC offset.\n    If date does not have any timezone info, we use local timezone,\n    otherwise return 0\n    """\n    if local_tz:\n        #handle year before 1970 most sytem there is no timezone information before 1970.\n        if date.year < 1970:\n            # Use 1972 because 1970 doesn\'t have a leap day\n            t = time.mktime(date.replace(year=1972).timetuple)\n        else:\n            t = time.mktime(date.timetuple())\n\n        # handle daylightsaving, if daylightsaving use altzone, otherwise use timezone\n        if time.localtime(t).tm_isdst:\n            return -time.altzone\n        else:\n            return -time.timezone\n    else:\n        return 0\n\n\ndef _generate_timezone(date, local_tz):\n    """\n    input :\n    date : date type\n    local_tz : bool\n\n    offset generated from _calculate_offset\n    offset in seconds\n    offset = 0 -> +00:00\n    offset = 1800 -> +00:30\n    offset = -3600 -> -01:00\n    """\n    offset = _calculate_offset(date, local_tz)\n\n    hour = abs(offset) // 3600\n    minute = abs(offset) % 3600 // 60\n\n    if offset < 0:\n        return \'%c%02d:%02d\' % ("-", hour, minute)\n    else:\n        return \'%c%02d:%02d\' % ("+", hour, minute)\n'
u'836,def generate_rfc3339(d, local_tz=True):\n    """\n    generate rfc3339 time format\n    input :\n    d = date type\n    local_tz = use local time zone if true,\n    otherwise mark as utc\n\n    output :\n    rfc3339 string date format. ex : `2008-04-02T20:00:00+07:00`\n    """\n    try:\n        if local_tz:\n            d = datetime.datetime.fromtimestamp(d)\n        else:\n            d = datetime.datetime.utcfromtimestamp(d)\n    except TypeError:\n        pass\n\n    if not isinstance(d, datetime.date):\n        raise TypeError(\'Not timestamp or date object. Got %r.\' % type(d))\n\n    if not isinstance(d, datetime.datetime):\n        d = datetime.datetime(*d.timetuple()[:3])\n\n    return (\'%04d-%02d-%02dT%02d:%02d:%02d%s\' %\n            (d.year, d.month, d.day, d.hour, d.minute, d.second,\n             _generate_timezone(d, local_tz)))\n'
u'837,def _calculate_offset(date, local_tz):\n    """\n    input :\n    date : date type\n    local_tz : if true, use system timezone, otherwise return 0\n\n    return the date of UTC offset.\n    If date does not have any timezone info, we use local timezone,\n    otherwise return 0\n    """\n    if local_tz:\n        #handle year before 1970 most sytem there is no timezone information before 1970.\n        if date.year < 1970:\n            # Use 1972 because 1970 doesn\'t have a leap day\n            t = time.mktime(date.replace(year=1972).timetuple)\n        else:\n            t = time.mktime(date.timetuple())\n\n        # handle daylightsaving, if daylightsaving use altzone, otherwise use timezone\n        if time.localtime(t).tm_isdst:\n            return -time.altzone\n        else:\n            return -time.timezone\n    else:\n        return 0\n'
u'838,def _generate_timezone(date, local_tz):\n    """\n    input :\n    date : date type\n    local_tz : bool\n\n    offset generated from _calculate_offset\n    offset in seconds\n    offset = 0 -> +00:00\n    offset = 1800 -> +00:30\n    offset = -3600 -> -01:00\n    """\n    offset = _calculate_offset(date, local_tz)\n\n    hour = abs(offset) // 3600\n    minute = abs(offset) % 3600 // 60\n\n    if offset < 0:\n        return \'%c%02d:%02d\' % ("-", hour, minute)\n    else:\n        return \'%c%02d:%02d\' % ("+", hour, minute)\n'
u'839,class NodesService:\n    def __init__(self, client):\n        self.client = client\n\n\n\n    def DeleteBridge(self, bridgeid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Remove bridge\n        It is method for DELETE /nodes/{nodeid}/bridges/{bridgeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges/"+bridgeid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetBridge(self, bridgeid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get bridge details\n        It is method for GET /nodes/{nodeid}/bridges/{bridgeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges/"+bridgeid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListBridges(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List bridges\n        It is method for GET /nodes/{nodeid}/bridges\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateBridge(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Creates a new bridge\n        It is method for POST /nodes/{nodeid}/bridges\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetContainerCPUInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all CPUs in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/cpus\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/cpus"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetContainerDiskInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all the disks in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/disks\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/disks"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def FileDelete(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete file from container\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/filesystem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/filesystem"\n        return self.client.delete(uri, data, headers, query_params, content_type)\n\n\n    def FileDownload(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Download file from container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/filesystem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/filesystem"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def FileUpload(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Upload file to container\n        It is method for POST /nodes/{nodeid}/containers/{containername}/filesystem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/filesystem"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetContainerOSInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of the container OS\n        It is method for GET /nodes/{nodeid}/containers/{containername}/info\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/info"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def KillContainerJob(self, jobid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the job\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs/"+jobid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetContainerJob(self, jobid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get details of a submitted job on the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs/"+jobid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def SendSignalToJob(self, data, jobid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Send signal to the job\n        It is method for POST /nodes/{nodeid}/containers/{containername}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs/"+jobid\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def KillAllContainerJobs(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kill all running jobs on the container\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs"\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def ListContainerJobs(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running jobs on the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def StartContainerJob(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start a new job in this container\n        It is method for POST /nodes/{nodeid}/containers/{containername}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetContainerMemInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the memory in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/mem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/mem"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetContainerNicInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the network interfaces in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/nics\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/nics"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def PingContainer(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Ping this container\n        It is method for POST /nodes/{nodeid}/containers/{containername}/ping\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/ping"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def KillContainerProcess(self, processid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the process by sending sigterm signal to the process. If it is still running, a sigkill signal will be sent to the process\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes/"+processid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetContainerProcess(self, processid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get process details\n        It is method for GET /nodes/{nodeid}/containers/{containername}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes/"+processid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def SendSignalToProcess(self, data, processid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Send signal to the process\n        It is method for POST /nodes/{nodeid}/containers/{containername}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes/"+processid\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def ListContainerProcesses(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get running processes in this container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/processes\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def StartContainer(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start container instance\n        It is method for POST /nodes/{nodeid}/containers/{containername}/start\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/start"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetContainerState(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get aggregated consumption of container + all processes (CPU, memory, etc.)\n        It is method for GET /nodes/{nodeid}/containers/{containername}/state\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/state"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def StopContainer(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Stop container instance\n        It is method for POST /nodes/{nodeid}/containers/{containername}/stop\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/stop"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteContainer(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete container instance\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetContainer(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get container\n        It is method for GET /nodes/{nodeid}/containers/{containername}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListContainers(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running containers\n        It is method for GET /nodes/{nodeid}/containers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateContainer(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new container\n        It is method for POST /nodes/{nodeid}/containers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetCPUInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all CPUs in the node\n        It is method for GET /nodes/{nodeid}/cpus\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/cpus"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetDiskInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all the disks in the node\n        It is method for GET /nodes/{nodeid}/disks\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/disks"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetGWFWConfig(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get current FW config\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/advanced/firewall\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/firewall"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def SetGWFWConfig(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Set FW config\n        Once used you can not use gw.portforwards any longer\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/advanced/firewall\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/firewall"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetGWHTTPConfig(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get current HTTP config\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/advanced/http\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/http"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def SetGWHTTPConfig(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Set HTTP config\n        Once used you can not use gw.httpproxxies any longer\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/advanced/http\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/http"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteDHCPHost(self, macaddress, interface, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete dhcp host\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}/dhcp/{interface}/hosts/{macaddress}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/dhcp/"+interface+"/hosts/"+macaddress\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def ListGWDHCPHosts(self, interface, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List DHCPHosts for specified interface\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/dhcp/{interface}/hosts\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/dhcp/"+interface+"/hosts"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def AddGWDHCPHost(self, data, interface, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Add a dhcp host to a specified interface\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/dhcp/{interface}/hosts\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/dhcp/"+interface+"/hosts"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteGWForward(self, forwardid, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete portforward, forwardid = srcip:srcport\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}/firewall/forwards/{forwardid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/firewall/forwards/"+forwardid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetGWForwards(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get list for IPv4 Forwards\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/firewall/forwards\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/firewall/forwards"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateGWForwards(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new Portforwarding\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/firewall/forwards\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/firewall/forwards"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteHTTPProxies(self, proxyid, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete HTTP proxy\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}/httpproxies/{proxyid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies/"+proxyid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetHTTPProxy(self, proxyid, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get info of HTTP proxy\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/httpproxies/{proxyid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies/"+proxyid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListHTTPProxies(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List for HTTP proxies\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/httpproxies\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateHTTPProxies(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create new HTTP proxies\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/httpproxies\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def StartGateway(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start Gateway instance\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/start\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/start"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def StopGateway(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Stop gateway instance\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/stop\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/stop"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteGateway(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete gateway instance\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetGateway(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get gateway\n        It is method for GET /nodes/{nodeid}/gws/{gwname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def UpdateGateway(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Update Gateway\n        It is method for PUT /nodes/{nodeid}/gws/{gwname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname\n        return self.client.put(uri, data, headers, query_params, content_type)\n\n\n    def ListGateways(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running gateways\n        It is method for GET /nodes/{nodeid}/gws\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateGW(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new gateway\n        It is method for POST /nodes/{nodeid}/gws\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetNodeOSInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of the OS of the node\n        It is method for GET /nodes/{nodeid}/info\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/info"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def KillNodeJob(self, jobid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the job\n        It is method for DELETE /nodes/{nodeid}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs/"+jobid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetNodeJob(self, jobid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get the details of a submitted job\n        It is method for GET /nodes/{nodeid}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs/"+jobid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def KillAllNodeJobs(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kill all running jobs\n        It is method for DELETE /nodes/{nodeid}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs"\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def ListNodeJobs(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running jobs\n        It is method for GET /nodes/{nodeid}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetMemInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the memory in the node\n        It is method for GET /nodes/{nodeid}/mem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/mem"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetNodeMounts(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all the mountpoints on the node\n        It is method for GET /nodes/{nodeid}/mounts\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/mounts"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetNicInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the network interfaces in the node\n        It is method for GET /nodes/{nodeid}/nics\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/nics"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def PingNode(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Ping this node\n        It is method for POST /nodes/{nodeid}/ping\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/ping"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def KillNodeProcess(self, processid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the process by sending sigterm signal to the process. If it is still running, a sigkill signal will be sent to the process\n        It is method for DELETE /nodes/{nodeid}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/processes/"+processid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetNodeProcess(self, processid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get process details\n        It is method for GET /nodes/{nodeid}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/processes/"+processid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListNodeProcesses(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get processes\n        It is method for GET /nodes/{nodeid}/processes\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/processes"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def RebootNode(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Immediately reboot the machine\n        It is method for POST /nodes/{nodeid}/reboot\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/reboot"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetNodeState(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        The aggregated consumption of node + all processes (cpu, memory, etc...)\n        It is method for GET /nodes/{nodeid}/state\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/state"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def DeleteStoragePoolDevice(self, deviceuuid, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Removes the device from the storage pool\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}/devices/{deviceuuid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices/"+deviceuuid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetStoragePoolDeviceInfo(self, deviceuuid, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get information of the device\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/devices/{deviceuuid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices/"+deviceuuid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListStoragePoolDevices(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List the devices in the storage pool\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/devices\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateStoragePoolDevices(self, data, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Add extra devices to this storage pool\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/devices\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def RollbackFilesystemSnapshot(self, data, snapshotname, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Rollback the file system to the state at the moment the snapshot was taken\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots/{snapshotname}/rollback\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots/"+snapshotname+"/rollback"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteFilesystemSnapshot(self, snapshotname, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete snapshot\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots/{snapshotname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots/"+snapshotname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetFilesystemSnapshotInfo(self, snapshotname, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information on the snapshot\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots/{snapshotname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots/"+snapshotname\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListFilesystemSnapshots(self, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List snapshots of this file system\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateSnapshot(self, data, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new read-only snapshot of the current state of the vdisk\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteFilesystem(self, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete file system\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetFilesystemInfo(self, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed file system information\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListFilesystems(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all file systems\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateFilesystem(self, data, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new file system\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteStoragePool(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete the storage pool\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetStoragePoolInfo(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of this storage pool\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListStoragePools(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List storage pools present in the node\n        It is method for GET /nodes/{nodeid}/storagepools\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateStoragePool(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new storage pool in the node\n        It is method for POST /nodes/{nodeid}/storagepools\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetVMInfo(self, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get statistical information about the virtual machine.\n        It is method for GET /nodes/{nodeid}/vms/{vmid}/info\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/info"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def MigrateVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Migrate the virtual machine to another host\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/migrate\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/migrate"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def PauseVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Pauses the VM\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/pause\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/pause"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def ResumeVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Resumes the virtual machine\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/resume\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/resume"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def ShutdownVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Gracefully shutdown the virtual machine\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/shutdown\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/shutdown"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def StartVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start the virtual machine\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/start\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/start"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def StopVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Stops the VM\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/stop\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/stop"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteVM(self, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Deletes the virtual machine\n        It is method for DELETE /nodes/{nodeid}/vms/{vmid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetVM(self, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get the virtual machine object\n        It is method for GET /nodes/{nodeid}/vms/{vmid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def UpdateVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Updates the virtual machine\n        It is method for PUT /nodes/{nodeid}/vms/{vmid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid\n        return self.client.put(uri, data, headers, query_params, content_type)\n\n\n    def ListVMs(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all virtual machines\n        It is method for GET /nodes/{nodeid}/vms\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateVM(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Creates a new virtual machine\n        It is method for POST /nodes/{nodeid}/vms\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def ExitZerotier(self, zerotierid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Exit the ZeroTier network\n        It is method for DELETE /nodes/{nodeid}/zerotiers/{zerotierid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers/"+zerotierid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetZerotier(self, zerotierid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get ZeroTier network details\n        It is method for GET /nodes/{nodeid}/zerotiers/{zerotierid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers/"+zerotierid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListZerotier(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running ZeroTier networks\n        It is method for GET /nodes/{nodeid}/zerotiers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def JoinZerotier(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Join ZeroTier network\n        It is method for POST /nodes/{nodeid}/zerotiers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteNode(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete a node\n        It is method for DELETE /nodes/{nodeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetNode(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of a node\n        It is method for GET /nodes/{nodeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListNodes(self, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all nodes\n        It is method for GET /nodes\n        """\n        uri = self.client.base_url + "/nodes"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'840,class NodesService:\n    def __init__(self, client):\n        self.client = client\n\n\n\n    def DeleteBridge(self, bridgeid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Remove bridge\n        It is method for DELETE /nodes/{nodeid}/bridges/{bridgeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges/"+bridgeid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetBridge(self, bridgeid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get bridge details\n        It is method for GET /nodes/{nodeid}/bridges/{bridgeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges/"+bridgeid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListBridges(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List bridges\n        It is method for GET /nodes/{nodeid}/bridges\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateBridge(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Creates a new bridge\n        It is method for POST /nodes/{nodeid}/bridges\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetContainerCPUInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all CPUs in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/cpus\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/cpus"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetContainerDiskInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all the disks in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/disks\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/disks"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def FileDelete(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete file from container\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/filesystem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/filesystem"\n        return self.client.delete(uri, data, headers, query_params, content_type)\n\n\n    def FileDownload(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Download file from container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/filesystem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/filesystem"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def FileUpload(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Upload file to container\n        It is method for POST /nodes/{nodeid}/containers/{containername}/filesystem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/filesystem"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetContainerOSInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of the container OS\n        It is method for GET /nodes/{nodeid}/containers/{containername}/info\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/info"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def KillContainerJob(self, jobid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the job\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs/"+jobid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetContainerJob(self, jobid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get details of a submitted job on the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs/"+jobid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def SendSignalToJob(self, data, jobid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Send signal to the job\n        It is method for POST /nodes/{nodeid}/containers/{containername}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs/"+jobid\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def KillAllContainerJobs(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kill all running jobs on the container\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs"\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def ListContainerJobs(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running jobs on the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def StartContainerJob(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start a new job in this container\n        It is method for POST /nodes/{nodeid}/containers/{containername}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetContainerMemInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the memory in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/mem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/mem"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetContainerNicInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the network interfaces in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/nics\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/nics"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def PingContainer(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Ping this container\n        It is method for POST /nodes/{nodeid}/containers/{containername}/ping\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/ping"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def KillContainerProcess(self, processid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the process by sending sigterm signal to the process. If it is still running, a sigkill signal will be sent to the process\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes/"+processid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetContainerProcess(self, processid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get process details\n        It is method for GET /nodes/{nodeid}/containers/{containername}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes/"+processid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def SendSignalToProcess(self, data, processid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Send signal to the process\n        It is method for POST /nodes/{nodeid}/containers/{containername}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes/"+processid\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def ListContainerProcesses(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get running processes in this container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/processes\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def StartContainer(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start container instance\n        It is method for POST /nodes/{nodeid}/containers/{containername}/start\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/start"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetContainerState(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get aggregated consumption of container + all processes (CPU, memory, etc.)\n        It is method for GET /nodes/{nodeid}/containers/{containername}/state\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/state"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def StopContainer(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Stop container instance\n        It is method for POST /nodes/{nodeid}/containers/{containername}/stop\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/stop"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteContainer(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete container instance\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetContainer(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get container\n        It is method for GET /nodes/{nodeid}/containers/{containername}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListContainers(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running containers\n        It is method for GET /nodes/{nodeid}/containers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateContainer(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new container\n        It is method for POST /nodes/{nodeid}/containers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetCPUInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all CPUs in the node\n        It is method for GET /nodes/{nodeid}/cpus\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/cpus"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetDiskInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all the disks in the node\n        It is method for GET /nodes/{nodeid}/disks\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/disks"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetGWFWConfig(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get current FW config\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/advanced/firewall\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/firewall"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def SetGWFWConfig(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Set FW config\n        Once used you can not use gw.portforwards any longer\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/advanced/firewall\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/firewall"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetGWHTTPConfig(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get current HTTP config\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/advanced/http\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/http"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def SetGWHTTPConfig(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Set HTTP config\n        Once used you can not use gw.httpproxxies any longer\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/advanced/http\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/http"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteDHCPHost(self, macaddress, interface, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete dhcp host\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}/dhcp/{interface}/hosts/{macaddress}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/dhcp/"+interface+"/hosts/"+macaddress\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def ListGWDHCPHosts(self, interface, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List DHCPHosts for specified interface\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/dhcp/{interface}/hosts\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/dhcp/"+interface+"/hosts"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def AddGWDHCPHost(self, data, interface, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Add a dhcp host to a specified interface\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/dhcp/{interface}/hosts\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/dhcp/"+interface+"/hosts"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteGWForward(self, forwardid, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete portforward, forwardid = srcip:srcport\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}/firewall/forwards/{forwardid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/firewall/forwards/"+forwardid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetGWForwards(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get list for IPv4 Forwards\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/firewall/forwards\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/firewall/forwards"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateGWForwards(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new Portforwarding\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/firewall/forwards\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/firewall/forwards"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteHTTPProxies(self, proxyid, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete HTTP proxy\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}/httpproxies/{proxyid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies/"+proxyid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetHTTPProxy(self, proxyid, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get info of HTTP proxy\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/httpproxies/{proxyid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies/"+proxyid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListHTTPProxies(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List for HTTP proxies\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/httpproxies\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateHTTPProxies(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create new HTTP proxies\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/httpproxies\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def StartGateway(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start Gateway instance\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/start\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/start"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def StopGateway(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Stop gateway instance\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/stop\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/stop"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteGateway(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete gateway instance\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetGateway(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get gateway\n        It is method for GET /nodes/{nodeid}/gws/{gwname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def UpdateGateway(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Update Gateway\n        It is method for PUT /nodes/{nodeid}/gws/{gwname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname\n        return self.client.put(uri, data, headers, query_params, content_type)\n\n\n    def ListGateways(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running gateways\n        It is method for GET /nodes/{nodeid}/gws\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateGW(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new gateway\n        It is method for POST /nodes/{nodeid}/gws\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetNodeOSInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of the OS of the node\n        It is method for GET /nodes/{nodeid}/info\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/info"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def KillNodeJob(self, jobid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the job\n        It is method for DELETE /nodes/{nodeid}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs/"+jobid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetNodeJob(self, jobid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get the details of a submitted job\n        It is method for GET /nodes/{nodeid}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs/"+jobid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def KillAllNodeJobs(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kill all running jobs\n        It is method for DELETE /nodes/{nodeid}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs"\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def ListNodeJobs(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running jobs\n        It is method for GET /nodes/{nodeid}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetMemInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the memory in the node\n        It is method for GET /nodes/{nodeid}/mem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/mem"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetNodeMounts(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all the mountpoints on the node\n        It is method for GET /nodes/{nodeid}/mounts\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/mounts"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetNicInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the network interfaces in the node\n        It is method for GET /nodes/{nodeid}/nics\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/nics"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def PingNode(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Ping this node\n        It is method for POST /nodes/{nodeid}/ping\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/ping"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def KillNodeProcess(self, processid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the process by sending sigterm signal to the process. If it is still running, a sigkill signal will be sent to the process\n        It is method for DELETE /nodes/{nodeid}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/processes/"+processid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetNodeProcess(self, processid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get process details\n        It is method for GET /nodes/{nodeid}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/processes/"+processid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListNodeProcesses(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get processes\n        It is method for GET /nodes/{nodeid}/processes\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/processes"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def RebootNode(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Immediately reboot the machine\n        It is method for POST /nodes/{nodeid}/reboot\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/reboot"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetNodeState(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        The aggregated consumption of node + all processes (cpu, memory, etc...)\n        It is method for GET /nodes/{nodeid}/state\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/state"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def DeleteStoragePoolDevice(self, deviceuuid, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Removes the device from the storage pool\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}/devices/{deviceuuid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices/"+deviceuuid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetStoragePoolDeviceInfo(self, deviceuuid, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get information of the device\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/devices/{deviceuuid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices/"+deviceuuid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListStoragePoolDevices(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List the devices in the storage pool\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/devices\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateStoragePoolDevices(self, data, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Add extra devices to this storage pool\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/devices\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def RollbackFilesystemSnapshot(self, data, snapshotname, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Rollback the file system to the state at the moment the snapshot was taken\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots/{snapshotname}/rollback\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots/"+snapshotname+"/rollback"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteFilesystemSnapshot(self, snapshotname, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete snapshot\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots/{snapshotname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots/"+snapshotname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetFilesystemSnapshotInfo(self, snapshotname, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information on the snapshot\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots/{snapshotname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots/"+snapshotname\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListFilesystemSnapshots(self, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List snapshots of this file system\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateSnapshot(self, data, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new read-only snapshot of the current state of the vdisk\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteFilesystem(self, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete file system\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetFilesystemInfo(self, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed file system information\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListFilesystems(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all file systems\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateFilesystem(self, data, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new file system\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteStoragePool(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete the storage pool\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetStoragePoolInfo(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of this storage pool\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListStoragePools(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List storage pools present in the node\n        It is method for GET /nodes/{nodeid}/storagepools\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateStoragePool(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new storage pool in the node\n        It is method for POST /nodes/{nodeid}/storagepools\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def GetVMInfo(self, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get statistical information about the virtual machine.\n        It is method for GET /nodes/{nodeid}/vms/{vmid}/info\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/info"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def MigrateVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Migrate the virtual machine to another host\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/migrate\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/migrate"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def PauseVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Pauses the VM\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/pause\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/pause"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def ResumeVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Resumes the virtual machine\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/resume\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/resume"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def ShutdownVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Gracefully shutdown the virtual machine\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/shutdown\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/shutdown"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def StartVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start the virtual machine\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/start\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/start"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def StopVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Stops the VM\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/stop\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/stop"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteVM(self, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Deletes the virtual machine\n        It is method for DELETE /nodes/{nodeid}/vms/{vmid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetVM(self, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get the virtual machine object\n        It is method for GET /nodes/{nodeid}/vms/{vmid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def UpdateVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Updates the virtual machine\n        It is method for PUT /nodes/{nodeid}/vms/{vmid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid\n        return self.client.put(uri, data, headers, query_params, content_type)\n\n\n    def ListVMs(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all virtual machines\n        It is method for GET /nodes/{nodeid}/vms\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateVM(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Creates a new virtual machine\n        It is method for POST /nodes/{nodeid}/vms\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def ExitZerotier(self, zerotierid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Exit the ZeroTier network\n        It is method for DELETE /nodes/{nodeid}/zerotiers/{zerotierid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers/"+zerotierid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetZerotier(self, zerotierid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get ZeroTier network details\n        It is method for GET /nodes/{nodeid}/zerotiers/{zerotierid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers/"+zerotierid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListZerotier(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running ZeroTier networks\n        It is method for GET /nodes/{nodeid}/zerotiers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def JoinZerotier(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Join ZeroTier network\n        It is method for POST /nodes/{nodeid}/zerotiers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteNode(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete a node\n        It is method for DELETE /nodes/{nodeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetNode(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of a node\n        It is method for GET /nodes/{nodeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListNodes(self, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all nodes\n        It is method for GET /nodes\n        """\n        uri = self.client.base_url + "/nodes"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'841,    def __init__(self, client):\n        self.client = client\n'
u'842,    def DeleteBridge(self, bridgeid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Remove bridge\n        It is method for DELETE /nodes/{nodeid}/bridges/{bridgeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges/"+bridgeid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'843,    def GetBridge(self, bridgeid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get bridge details\n        It is method for GET /nodes/{nodeid}/bridges/{bridgeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges/"+bridgeid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'844,    def ListBridges(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List bridges\n        It is method for GET /nodes/{nodeid}/bridges\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'845,    def CreateBridge(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Creates a new bridge\n        It is method for POST /nodes/{nodeid}/bridges\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/bridges"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'846,    def GetContainerCPUInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all CPUs in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/cpus\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/cpus"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'847,    def GetContainerDiskInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all the disks in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/disks\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/disks"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'848,    def FileDelete(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete file from container\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/filesystem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/filesystem"\n        return self.client.delete(uri, data, headers, query_params, content_type)\n'
u'849,    def FileDownload(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Download file from container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/filesystem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/filesystem"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'850,    def FileUpload(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Upload file to container\n        It is method for POST /nodes/{nodeid}/containers/{containername}/filesystem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/filesystem"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'851,    def GetContainerOSInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of the container OS\n        It is method for GET /nodes/{nodeid}/containers/{containername}/info\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/info"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'852,    def KillContainerJob(self, jobid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the job\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs/"+jobid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'853,    def GetContainerJob(self, jobid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get details of a submitted job on the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs/"+jobid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'854,    def SendSignalToJob(self, data, jobid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Send signal to the job\n        It is method for POST /nodes/{nodeid}/containers/{containername}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs/"+jobid\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'855,    def KillAllContainerJobs(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kill all running jobs on the container\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs"\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'856,    def ListContainerJobs(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running jobs on the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'857,    def StartContainerJob(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start a new job in this container\n        It is method for POST /nodes/{nodeid}/containers/{containername}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/jobs"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'858,    def GetContainerMemInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the memory in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/mem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/mem"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'859,    def GetContainerNicInfo(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the network interfaces in the container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/nics\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/nics"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'860,    def PingContainer(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Ping this container\n        It is method for POST /nodes/{nodeid}/containers/{containername}/ping\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/ping"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'861,    def KillContainerProcess(self, processid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the process by sending sigterm signal to the process. If it is still running, a sigkill signal will be sent to the process\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes/"+processid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'862,    def GetContainerProcess(self, processid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get process details\n        It is method for GET /nodes/{nodeid}/containers/{containername}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes/"+processid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'863,    def SendSignalToProcess(self, data, processid, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Send signal to the process\n        It is method for POST /nodes/{nodeid}/containers/{containername}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes/"+processid\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'864,    def ListContainerProcesses(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get running processes in this container\n        It is method for GET /nodes/{nodeid}/containers/{containername}/processes\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/processes"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'865,    def StartContainer(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start container instance\n        It is method for POST /nodes/{nodeid}/containers/{containername}/start\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/start"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'866,    def GetContainerState(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get aggregated consumption of container + all processes (CPU, memory, etc.)\n        It is method for GET /nodes/{nodeid}/containers/{containername}/state\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/state"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'867,    def StopContainer(self, data, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Stop container instance\n        It is method for POST /nodes/{nodeid}/containers/{containername}/stop\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername+"/stop"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'868,    def DeleteContainer(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete container instance\n        It is method for DELETE /nodes/{nodeid}/containers/{containername}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'869,    def GetContainer(self, containername, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get container\n        It is method for GET /nodes/{nodeid}/containers/{containername}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers/"+containername\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'870,    def ListContainers(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running containers\n        It is method for GET /nodes/{nodeid}/containers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'871,    def CreateContainer(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new container\n        It is method for POST /nodes/{nodeid}/containers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/containers"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'872,    def GetCPUInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all CPUs in the node\n        It is method for GET /nodes/{nodeid}/cpus\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/cpus"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'873,    def GetDiskInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all the disks in the node\n        It is method for GET /nodes/{nodeid}/disks\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/disks"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'874,    def GetGWFWConfig(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get current FW config\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/advanced/firewall\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/firewall"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'875,    def SetGWFWConfig(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Set FW config\n        Once used you can not use gw.portforwards any longer\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/advanced/firewall\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/firewall"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'876,    def GetGWHTTPConfig(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get current HTTP config\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/advanced/http\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/http"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'877,    def SetGWHTTPConfig(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Set HTTP config\n        Once used you can not use gw.httpproxxies any longer\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/advanced/http\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/advanced/http"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'878,    def DeleteDHCPHost(self, macaddress, interface, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete dhcp host\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}/dhcp/{interface}/hosts/{macaddress}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/dhcp/"+interface+"/hosts/"+macaddress\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'879,    def ListGWDHCPHosts(self, interface, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List DHCPHosts for specified interface\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/dhcp/{interface}/hosts\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/dhcp/"+interface+"/hosts"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'880,    def AddGWDHCPHost(self, data, interface, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Add a dhcp host to a specified interface\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/dhcp/{interface}/hosts\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/dhcp/"+interface+"/hosts"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'881,    def DeleteGWForward(self, forwardid, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete portforward, forwardid = srcip:srcport\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}/firewall/forwards/{forwardid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/firewall/forwards/"+forwardid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'882,    def GetGWForwards(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get list for IPv4 Forwards\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/firewall/forwards\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/firewall/forwards"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'883,    def CreateGWForwards(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new Portforwarding\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/firewall/forwards\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/firewall/forwards"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'884,    def DeleteHTTPProxies(self, proxyid, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete HTTP proxy\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}/httpproxies/{proxyid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies/"+proxyid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'885,    def GetHTTPProxy(self, proxyid, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get info of HTTP proxy\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/httpproxies/{proxyid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies/"+proxyid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'886,    def ListHTTPProxies(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List for HTTP proxies\n        It is method for GET /nodes/{nodeid}/gws/{gwname}/httpproxies\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'887,    def CreateHTTPProxies(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create new HTTP proxies\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/httpproxies\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/httpproxies"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'888,    def StartGateway(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start Gateway instance\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/start\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/start"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'889,    def StopGateway(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Stop gateway instance\n        It is method for POST /nodes/{nodeid}/gws/{gwname}/stop\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname+"/stop"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'890,    def DeleteGateway(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete gateway instance\n        It is method for DELETE /nodes/{nodeid}/gws/{gwname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'891,    def GetGateway(self, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get gateway\n        It is method for GET /nodes/{nodeid}/gws/{gwname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'892,    def UpdateGateway(self, data, gwname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Update Gateway\n        It is method for PUT /nodes/{nodeid}/gws/{gwname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws/"+gwname\n        return self.client.put(uri, data, headers, query_params, content_type)\n'
u'893,    def ListGateways(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running gateways\n        It is method for GET /nodes/{nodeid}/gws\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'894,    def CreateGW(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new gateway\n        It is method for POST /nodes/{nodeid}/gws\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/gws"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'895,    def GetNodeOSInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of the OS of the node\n        It is method for GET /nodes/{nodeid}/info\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/info"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'896,    def KillNodeJob(self, jobid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the job\n        It is method for DELETE /nodes/{nodeid}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs/"+jobid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'897,    def GetNodeJob(self, jobid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get the details of a submitted job\n        It is method for GET /nodes/{nodeid}/jobs/{jobid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs/"+jobid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'898,    def KillAllNodeJobs(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kill all running jobs\n        It is method for DELETE /nodes/{nodeid}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs"\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'899,    def ListNodeJobs(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running jobs\n        It is method for GET /nodes/{nodeid}/jobs\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/jobs"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'900,    def GetMemInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the memory in the node\n        It is method for GET /nodes/{nodeid}/mem\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/mem"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'901,    def GetNodeMounts(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of all the mountpoints on the node\n        It is method for GET /nodes/{nodeid}/mounts\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/mounts"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'902,    def GetNicInfo(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information about the network interfaces in the node\n        It is method for GET /nodes/{nodeid}/nics\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/nics"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'903,    def PingNode(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Ping this node\n        It is method for POST /nodes/{nodeid}/ping\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/ping"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'904,    def KillNodeProcess(self, processid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kills the process by sending sigterm signal to the process. If it is still running, a sigkill signal will be sent to the process\n        It is method for DELETE /nodes/{nodeid}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/processes/"+processid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'905,    def GetNodeProcess(self, processid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get process details\n        It is method for GET /nodes/{nodeid}/processes/{processid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/processes/"+processid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'906,    def ListNodeProcesses(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get processes\n        It is method for GET /nodes/{nodeid}/processes\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/processes"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'907,    def RebootNode(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Immediately reboot the machine\n        It is method for POST /nodes/{nodeid}/reboot\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/reboot"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'908,    def GetNodeState(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        The aggregated consumption of node + all processes (cpu, memory, etc...)\n        It is method for GET /nodes/{nodeid}/state\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/state"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'909,    def DeleteStoragePoolDevice(self, deviceuuid, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Removes the device from the storage pool\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}/devices/{deviceuuid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices/"+deviceuuid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'910,    def GetStoragePoolDeviceInfo(self, deviceuuid, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get information of the device\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/devices/{deviceuuid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices/"+deviceuuid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'911,    def ListStoragePoolDevices(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List the devices in the storage pool\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/devices\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'912,    def CreateStoragePoolDevices(self, data, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Add extra devices to this storage pool\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/devices\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/devices"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'913,    def RollbackFilesystemSnapshot(self, data, snapshotname, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Rollback the file system to the state at the moment the snapshot was taken\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots/{snapshotname}/rollback\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots/"+snapshotname+"/rollback"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'914,    def DeleteFilesystemSnapshot(self, snapshotname, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete snapshot\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots/{snapshotname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots/"+snapshotname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'915,    def GetFilesystemSnapshotInfo(self, snapshotname, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information on the snapshot\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots/{snapshotname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots/"+snapshotname\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'916,    def ListFilesystemSnapshots(self, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List snapshots of this file system\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'917,    def CreateSnapshot(self, data, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new read-only snapshot of the current state of the vdisk\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}/snapshots\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname+"/snapshots"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'918,    def DeleteFilesystem(self, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete file system\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'919,    def GetFilesystemInfo(self, filesystemname, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed file system information\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems/{filesystemname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems/"+filesystemname\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'920,    def ListFilesystems(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all file systems\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'921,    def CreateFilesystem(self, data, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new file system\n        It is method for POST /nodes/{nodeid}/storagepools/{storagepoolname}/filesystems\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname+"/filesystems"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'922,    def DeleteStoragePool(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete the storage pool\n        It is method for DELETE /nodes/{nodeid}/storagepools/{storagepoolname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'923,    def GetStoragePoolInfo(self, storagepoolname, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of this storage pool\n        It is method for GET /nodes/{nodeid}/storagepools/{storagepoolname}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools/"+storagepoolname\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'924,    def ListStoragePools(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List storage pools present in the node\n        It is method for GET /nodes/{nodeid}/storagepools\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'925,    def CreateStoragePool(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new storage pool in the node\n        It is method for POST /nodes/{nodeid}/storagepools\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/storagepools"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'926,    def GetVMInfo(self, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get statistical information about the virtual machine.\n        It is method for GET /nodes/{nodeid}/vms/{vmid}/info\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/info"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'927,    def MigrateVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Migrate the virtual machine to another host\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/migrate\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/migrate"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'928,    def PauseVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Pauses the VM\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/pause\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/pause"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'929,    def ResumeVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Resumes the virtual machine\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/resume\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/resume"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'930,    def ShutdownVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Gracefully shutdown the virtual machine\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/shutdown\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/shutdown"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'931,    def StartVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Start the virtual machine\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/start\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/start"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'932,    def StopVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Stops the VM\n        It is method for POST /nodes/{nodeid}/vms/{vmid}/stop\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid+"/stop"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'933,    def DeleteVM(self, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Deletes the virtual machine\n        It is method for DELETE /nodes/{nodeid}/vms/{vmid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'934,    def GetVM(self, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get the virtual machine object\n        It is method for GET /nodes/{nodeid}/vms/{vmid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'935,    def UpdateVM(self, data, vmid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Updates the virtual machine\n        It is method for PUT /nodes/{nodeid}/vms/{vmid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms/"+vmid\n        return self.client.put(uri, data, headers, query_params, content_type)\n'
u'936,    def ListVMs(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all virtual machines\n        It is method for GET /nodes/{nodeid}/vms\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'937,    def CreateVM(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Creates a new virtual machine\n        It is method for POST /nodes/{nodeid}/vms\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/vms"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'938,    def ExitZerotier(self, zerotierid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Exit the ZeroTier network\n        It is method for DELETE /nodes/{nodeid}/zerotiers/{zerotierid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers/"+zerotierid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'939,    def GetZerotier(self, zerotierid, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get ZeroTier network details\n        It is method for GET /nodes/{nodeid}/zerotiers/{zerotierid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers/"+zerotierid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'940,    def ListZerotier(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        List running ZeroTier networks\n        It is method for GET /nodes/{nodeid}/zerotiers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'941,    def JoinZerotier(self, data, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Join ZeroTier network\n        It is method for POST /nodes/{nodeid}/zerotiers\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid+"/zerotiers"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'942,    def DeleteNode(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete a node\n        It is method for DELETE /nodes/{nodeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'943,    def GetNode(self, nodeid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get detailed information of a node\n        It is method for GET /nodes/{nodeid}\n        """\n        uri = self.client.base_url + "/nodes/"+nodeid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'944,    def ListNodes(self, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all nodes\n        It is method for GET /nodes\n        """\n        uri = self.client.base_url + "/nodes"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'945,import requests\n\nclass Oauth2ClientItsyouonline():\n    def __init__(self, access_token_uri=\'https://itsyou.online/v1/oauth/access_token?response_type=id_token\'):\n        self.access_token_uri = access_token_uri\n\n    def get_access_token(self, client_id, client_secret, scopes=[], audiences=[]):\n        params = {\n            \'grant_type\': \'client_credentials\',\n            \'client_id\': client_id,\n            \'client_secret\': client_secret,\n            \'validity\': 3600,\n        }\n\n        if len(scopes) > 0:\n            params[\'scope\'] = ",".join(scopes)\n        if len(audiences) > 0:\n            params[\'aud\'] = ",".join(audiences)\n        \n        return requests.post(self.access_token_uri, params=params)\n'
u'946,class Oauth2ClientItsyouonline():\n    def __init__(self, access_token_uri=\'https://itsyou.online/v1/oauth/access_token?response_type=id_token\'):\n        self.access_token_uri = access_token_uri\n\n    def get_access_token(self, client_id, client_secret, scopes=[], audiences=[]):\n        params = {\n            \'grant_type\': \'client_credentials\',\n            \'client_id\': client_id,\n            \'client_secret\': client_secret,\n            \'validity\': 3600,\n        }\n\n        if len(scopes) > 0:\n            params[\'scope\'] = ",".join(scopes)\n        if len(audiences) > 0:\n            params[\'aud\'] = ",".join(audiences)\n        \n        return requests.post(self.access_token_uri, params=params)\n'
u"947,    def __init__(self, access_token_uri='https://itsyou.online/v1/oauth/access_token?response_type=id_token'):\n        self.access_token_uri = access_token_uri\n"
u'948,    def get_access_token(self, client_id, client_secret, scopes=[], audiences=[]):\n        params = {\n            \'grant_type\': \'client_credentials\',\n            \'client_id\': client_id,\n            \'client_secret\': client_secret,\n            \'validity\': 3600,\n        }\n\n        if len(scopes) > 0:\n            params[\'scope\'] = ",".join(scopes)\n        if len(audiences) > 0:\n            params[\'aud\'] = ",".join(audiences)\n        \n        return requests.post(self.access_token_uri, params=params)\n'
u'949,class RunsService:\n    def __init__(self, client):\n        self.client = client\n\n\n\n    def WaitOnRun(self, runid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Wait for Run\n        It is method for GET /runs/{runid}/wait\n        """\n        uri = self.client.base_url + "/runs/"+runid+"/wait"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetRunState(self, runid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get Run Status\n        It is method for GET /runs/{runid}\n        """\n        uri = self.client.base_url + "/runs/"+runid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'950,class RunsService:\n    def __init__(self, client):\n        self.client = client\n\n\n\n    def WaitOnRun(self, runid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Wait for Run\n        It is method for GET /runs/{runid}/wait\n        """\n        uri = self.client.base_url + "/runs/"+runid+"/wait"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def GetRunState(self, runid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get Run Status\n        It is method for GET /runs/{runid}\n        """\n        uri = self.client.base_url + "/runs/"+runid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'951,    def __init__(self, client):\n        self.client = client\n'
u'952,    def WaitOnRun(self, runid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Wait for Run\n        It is method for GET /runs/{runid}/wait\n        """\n        uri = self.client.base_url + "/runs/"+runid+"/wait"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'953,    def GetRunState(self, runid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get Run Status\n        It is method for GET /runs/{runid}\n        """\n        uri = self.client.base_url + "/runs/"+runid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'954,class StorageclustersService:\n    def __init__(self, client):\n        self.client = client\n\n\n\n    def KillCluster(self, label, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kill cluster\n        It is method for DELETE /storageclusters/{label}\n        """\n        uri = self.client.base_url + "/storageclusters/"+label\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetClusterInfo(self, label, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get full information about specific cluster\n        It is method for GET /storageclusters/{label}\n        """\n        uri = self.client.base_url + "/storageclusters/"+label\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListAllClusters(self, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all running clusters\n        It is method for GET /storageclusters\n        """\n        uri = self.client.base_url + "/storageclusters"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def DeployNewCluster(self, data, headers=None, query_params=None, content_type="application/json"):\n        """\n        Deploy new cluster\n        It is method for POST /storageclusters\n        """\n        uri = self.client.base_url + "/storageclusters"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'955,class StorageclustersService:\n    def __init__(self, client):\n        self.client = client\n\n\n\n    def KillCluster(self, label, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kill cluster\n        It is method for DELETE /storageclusters/{label}\n        """\n        uri = self.client.base_url + "/storageclusters/"+label\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetClusterInfo(self, label, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get full information about specific cluster\n        It is method for GET /storageclusters/{label}\n        """\n        uri = self.client.base_url + "/storageclusters/"+label\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListAllClusters(self, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all running clusters\n        It is method for GET /storageclusters\n        """\n        uri = self.client.base_url + "/storageclusters"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def DeployNewCluster(self, data, headers=None, query_params=None, content_type="application/json"):\n        """\n        Deploy new cluster\n        It is method for POST /storageclusters\n        """\n        uri = self.client.base_url + "/storageclusters"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'956,    def __init__(self, client):\n        self.client = client\n'
u'957,    def KillCluster(self, label, headers=None, query_params=None, content_type="application/json"):\n        """\n        Kill cluster\n        It is method for DELETE /storageclusters/{label}\n        """\n        uri = self.client.base_url + "/storageclusters/"+label\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'958,    def GetClusterInfo(self, label, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get full information about specific cluster\n        It is method for GET /storageclusters/{label}\n        """\n        uri = self.client.base_url + "/storageclusters/"+label\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'959,    def ListAllClusters(self, headers=None, query_params=None, content_type="application/json"):\n        """\n        List all running clusters\n        It is method for GET /storageclusters\n        """\n        uri = self.client.base_url + "/storageclusters"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'960,    def DeployNewCluster(self, data, headers=None, query_params=None, content_type="application/json"):\n        """\n        Deploy new cluster\n        It is method for POST /storageclusters\n        """\n        uri = self.client.base_url + "/storageclusters"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'961,class VdisksService:\n    def __init__(self, client):\n        self.client = client\n\n\n\n    def ResizeVdisk(self, data, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Resize vdisk\n        It is method for POST /vdisks/{vdiskid}/resize\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid+"/resize"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def RollbackVdisk(self, data, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Rollback a vdisk to a previous state\n        It is method for POST /vdisks/{vdiskid}/rollback\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid+"/rollback"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteVdisk(self, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete Vdisk\n        It is method for DELETE /vdisks/{vdiskid}\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetVdiskInfo(self, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get vdisk information\n        It is method for GET /vdisks/{vdiskid}\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListVdisks(self, headers=None, query_params=None, content_type="application/json"):\n        """\n        List vdisks\n        It is method for GET /vdisks\n        """\n        uri = self.client.base_url + "/vdisks"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateNewVdisk(self, data, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new vdisk, can be a copy from an existing vdisk\n        It is method for POST /vdisks\n        """\n        uri = self.client.base_url + "/vdisks"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'962,class VdisksService:\n    def __init__(self, client):\n        self.client = client\n\n\n\n    def ResizeVdisk(self, data, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Resize vdisk\n        It is method for POST /vdisks/{vdiskid}/resize\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid+"/resize"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def RollbackVdisk(self, data, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Rollback a vdisk to a previous state\n        It is method for POST /vdisks/{vdiskid}/rollback\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid+"/rollback"\n        return self.client.post(uri, data, headers, query_params, content_type)\n\n\n    def DeleteVdisk(self, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete Vdisk\n        It is method for DELETE /vdisks/{vdiskid}\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n\n\n    def GetVdiskInfo(self, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get vdisk information\n        It is method for GET /vdisks/{vdiskid}\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def ListVdisks(self, headers=None, query_params=None, content_type="application/json"):\n        """\n        List vdisks\n        It is method for GET /vdisks\n        """\n        uri = self.client.base_url + "/vdisks"\n        return self.client.get(uri, None, headers, query_params, content_type)\n\n\n    def CreateNewVdisk(self, data, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new vdisk, can be a copy from an existing vdisk\n        It is method for POST /vdisks\n        """\n        uri = self.client.base_url + "/vdisks"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'963,    def __init__(self, client):\n        self.client = client\n'
u'964,    def ResizeVdisk(self, data, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Resize vdisk\n        It is method for POST /vdisks/{vdiskid}/resize\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid+"/resize"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'965,    def RollbackVdisk(self, data, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Rollback a vdisk to a previous state\n        It is method for POST /vdisks/{vdiskid}/rollback\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid+"/rollback"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'966,    def DeleteVdisk(self, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Delete Vdisk\n        It is method for DELETE /vdisks/{vdiskid}\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid\n        return self.client.delete(uri, None, headers, query_params, content_type)\n'
u'967,    def GetVdiskInfo(self, vdiskid, headers=None, query_params=None, content_type="application/json"):\n        """\n        Get vdisk information\n        It is method for GET /vdisks/{vdiskid}\n        """\n        uri = self.client.base_url + "/vdisks/"+vdiskid\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'968,    def ListVdisks(self, headers=None, query_params=None, content_type="application/json"):\n        """\n        List vdisks\n        It is method for GET /vdisks\n        """\n        uri = self.client.base_url + "/vdisks"\n        return self.client.get(uri, None, headers, query_params, content_type)\n'
u'969,    def CreateNewVdisk(self, data, headers=None, query_params=None, content_type="application/json"):\n        """\n        Create a new vdisk, can be a copy from an existing vdisk\n        It is method for POST /vdisks\n        """\n        uri = self.client.base_url + "/vdisks"\n        return self.client.post(uri, data, headers, query_params, content_type)\n'
u'970,from ..abstracts import AYSable\nfrom js9 import j\n\n\nclass StoragePoolAys(AYSable):\n\n    def __init__(self, storagepool):\n        self._obj = storagepool\n        self.actor = \'storagepool\'\n\n    def create(self, aysrepo):\n        try:\n            service = aysrepo.serviceGet(role=\'storagepool\', instance=self._obj.name)\n        except j.exceptions.NotFound:\n            service = None\n\n        device_map, pool_status = self._obj.get_devices_and_status()\n\n        if service is None:\n            # create new service\n            actor = aysrepo.actorGet(self.actor)\n\n            args = {\n                \'metadataProfile\': self._obj.fsinfo[\'metadata\'][\'profile\'],\n                \'dataProfile\': self._obj.fsinfo[\'data\'][\'profile\'],\n                \'devices\': device_map,\n                \'node\': self._node_name,\n                \'status\': pool_status,\n            }\n            service = actor.serviceCreate(instance=self._obj.name, args=args)\n        else:\n            # update model on exists service\n            service.model.data.init(\'devices\', len(device_map))\n            for i, device in enumerate(device_map):\n                service.model.data.devices[i] = device\n\n            service.model.data.status = pool_status\n            service.saveAll()\n\n        return service\n\n    @property\n    def _node_name(self):\n        def is_valid_nic(nic):\n            for exclude in [\'zt\', \'core\', \'kvm\', \'lo\']:\n                if nic[\'name\'].startswith(exclude):\n                    return False\n            return True\n\n        for nic in filter(is_valid_nic, self._obj.node.client.info.nic()):\n            if len(nic[\'addrs\']) > 0 and nic[\'addrs\'][0][\'addr\'] != \'\':\n                return nic[\'hardwareaddr\'].replace(\':\', \'\')\n        raise AttributeError("name not find for node {}".format(self._obj.node))\n\n\nclass FileSystemAys(AYSable):\n\n    def __init__(self, filesystem):\n        self._obj = filesystem\n        self.actor = \'filesystem\'\n\n    def create(self, aysrepo):\n        actor = aysrepo.actorGet(self.actor)\n        args = {\n            \'storagePool\': self._obj.pool.name,\n            \'name\': self._obj.name,\n            # \'readOnly\': ,FIXME\n            # \'quota\': ,FIXME\n        }\n        return actor.serviceCreate(instance=self._obj.name, args=args)\n'
u'971,class StoragePoolAys(AYSable):\n\n    def __init__(self, storagepool):\n        self._obj = storagepool\n        self.actor = \'storagepool\'\n\n    def create(self, aysrepo):\n        try:\n            service = aysrepo.serviceGet(role=\'storagepool\', instance=self._obj.name)\n        except j.exceptions.NotFound:\n            service = None\n\n        device_map, pool_status = self._obj.get_devices_and_status()\n\n        if service is None:\n            # create new service\n            actor = aysrepo.actorGet(self.actor)\n\n            args = {\n                \'metadataProfile\': self._obj.fsinfo[\'metadata\'][\'profile\'],\n                \'dataProfile\': self._obj.fsinfo[\'data\'][\'profile\'],\n                \'devices\': device_map,\n                \'node\': self._node_name,\n                \'status\': pool_status,\n            }\n            service = actor.serviceCreate(instance=self._obj.name, args=args)\n        else:\n            # update model on exists service\n            service.model.data.init(\'devices\', len(device_map))\n            for i, device in enumerate(device_map):\n                service.model.data.devices[i] = device\n\n            service.model.data.status = pool_status\n            service.saveAll()\n\n        return service\n\n    @property\n    def _node_name(self):\n        def is_valid_nic(nic):\n            for exclude in [\'zt\', \'core\', \'kvm\', \'lo\']:\n                if nic[\'name\'].startswith(exclude):\n                    return False\n            return True\n\n        for nic in filter(is_valid_nic, self._obj.node.client.info.nic()):\n            if len(nic[\'addrs\']) > 0 and nic[\'addrs\'][0][\'addr\'] != \'\':\n                return nic[\'hardwareaddr\'].replace(\':\', \'\')\n        raise AttributeError("name not find for node {}".format(self._obj.node))\n'
u"972,class FileSystemAys(AYSable):\n\n    def __init__(self, filesystem):\n        self._obj = filesystem\n        self.actor = 'filesystem'\n\n    def create(self, aysrepo):\n        actor = aysrepo.actorGet(self.actor)\n        args = {\n            'storagePool': self._obj.pool.name,\n            'name': self._obj.name,\n            # 'readOnly': ,FIXME\n            # 'quota': ,FIXME\n        }\n        return actor.serviceCreate(instance=self._obj.name, args=args)\n"
u"973,    def __init__(self, storagepool):\n        self._obj = storagepool\n        self.actor = 'storagepool'\n"
u"974,    def create(self, aysrepo):\n        try:\n            service = aysrepo.serviceGet(role='storagepool', instance=self._obj.name)\n        except j.exceptions.NotFound:\n            service = None\n\n        device_map, pool_status = self._obj.get_devices_and_status()\n\n        if service is None:\n            # create new service\n            actor = aysrepo.actorGet(self.actor)\n\n            args = {\n                'metadataProfile': self._obj.fsinfo['metadata']['profile'],\n                'dataProfile': self._obj.fsinfo['data']['profile'],\n                'devices': device_map,\n                'node': self._node_name,\n                'status': pool_status,\n            }\n            service = actor.serviceCreate(instance=self._obj.name, args=args)\n        else:\n            # update model on exists service\n            service.model.data.init('devices', len(device_map))\n            for i, device in enumerate(device_map):\n                service.model.data.devices[i] = device\n\n            service.model.data.status = pool_status\n            service.saveAll()\n\n        return service\n"
u'975,    @property\n    def _node_name(self):\n        def is_valid_nic(nic):\n            for exclude in [\'zt\', \'core\', \'kvm\', \'lo\']:\n                if nic[\'name\'].startswith(exclude):\n                    return False\n            return True\n\n        for nic in filter(is_valid_nic, self._obj.node.client.info.nic()):\n            if len(nic[\'addrs\']) > 0 and nic[\'addrs\'][0][\'addr\'] != \'\':\n                return nic[\'hardwareaddr\'].replace(\':\', \'\')\n        raise AttributeError("name not find for node {}".format(self._obj.node))\n'
u"976,    def __init__(self, filesystem):\n        self._obj = filesystem\n        self.actor = 'filesystem'\n"
u"977,    def create(self, aysrepo):\n        actor = aysrepo.actorGet(self.actor)\n        args = {\n            'storagePool': self._obj.pool.name,\n            'name': self._obj.name,\n            # 'readOnly': ,FIXME\n            # 'quota': ,FIXME\n        }\n        return actor.serviceCreate(instance=self._obj.name, args=args)\n"
u"978,        def is_valid_nic(nic):\n            for exclude in ['zt', 'core', 'kvm', 'lo']:\n                if nic['name'].startswith(exclude):\n                    return False\n            return True\n"
u'979,import time\n\n\nclass CloudInit:\n    def __init__(self, container, config):\n        self.container = container\n        self.config = config\n        self.CONFIGPATH = "/etc/cloud-init"\n\n    def apply_config(self):\n        self.cleanup(self.config.keys())\n\n        for key, value in self.config.items():\n            fpath = "%s/%s" % (self.CONFIGPATH, key)\n            self.container.upload_content(fpath, value)\n        if not self.is_running():\n            self.start()\n\n    def cleanup(self, macaddresses):\n        configs = self.container.client.filesystem.list(self.CONFIGPATH)\n        for config in configs:\n            if config["name"] not in macaddresses:\n                self.container.client.filesystem.remove("%s/%s" % (self.CONFIGPATH, config["name"]))\n\n    def start(self):\n        if not self.is_running():\n            self.container.client.system(\n                \'cloud-init-server \\\n                -bind 127.0.0.1:8080 \\\n                -config {config}\'\n                .format(config=self.CONFIGPATH)\n            )\n\n        start = time.time()\n        while time.time() + 10 > start:\n            if self.is_running():\n                return\n            time.sleep(0.5)\n        raise RuntimeError(\'Failed to start cloudinit server\')\n\n    def is_running(self):\n        for port in self.container.client.info.port():\n            if port[\'network\'] == \'tcp\' and port[\'port\'] == 8080 and port[\'ip\'] == \'127.0.0.1\':\n                return True\n        return False\n'
u'980,class CloudInit:\n    def __init__(self, container, config):\n        self.container = container\n        self.config = config\n        self.CONFIGPATH = "/etc/cloud-init"\n\n    def apply_config(self):\n        self.cleanup(self.config.keys())\n\n        for key, value in self.config.items():\n            fpath = "%s/%s" % (self.CONFIGPATH, key)\n            self.container.upload_content(fpath, value)\n        if not self.is_running():\n            self.start()\n\n    def cleanup(self, macaddresses):\n        configs = self.container.client.filesystem.list(self.CONFIGPATH)\n        for config in configs:\n            if config["name"] not in macaddresses:\n                self.container.client.filesystem.remove("%s/%s" % (self.CONFIGPATH, config["name"]))\n\n    def start(self):\n        if not self.is_running():\n            self.container.client.system(\n                \'cloud-init-server \\\n                -bind 127.0.0.1:8080 \\\n                -config {config}\'\n                .format(config=self.CONFIGPATH)\n            )\n\n        start = time.time()\n        while time.time() + 10 > start:\n            if self.is_running():\n                return\n            time.sleep(0.5)\n        raise RuntimeError(\'Failed to start cloudinit server\')\n\n    def is_running(self):\n        for port in self.container.client.info.port():\n            if port[\'network\'] == \'tcp\' and port[\'port\'] == 8080 and port[\'ip\'] == \'127.0.0.1\':\n                return True\n        return False\n'
u'981,    def __init__(self, container, config):\n        self.container = container\n        self.config = config\n        self.CONFIGPATH = "/etc/cloud-init"\n'
u'982,    def apply_config(self):\n        self.cleanup(self.config.keys())\n\n        for key, value in self.config.items():\n            fpath = "%s/%s" % (self.CONFIGPATH, key)\n            self.container.upload_content(fpath, value)\n        if not self.is_running():\n            self.start()\n'
u'983,    def cleanup(self, macaddresses):\n        configs = self.container.client.filesystem.list(self.CONFIGPATH)\n        for config in configs:\n            if config["name"] not in macaddresses:\n                self.container.client.filesystem.remove("%s/%s" % (self.CONFIGPATH, config["name"]))\n'
u"984,    def start(self):\n        if not self.is_running():\n            self.container.client.system(\n                'cloud-init-server \\\n                -bind 127.0.0.1:8080 \\\n                -config {config}'\n                .format(config=self.CONFIGPATH)\n            )\n\n        start = time.time()\n        while time.time() + 10 > start:\n            if self.is_running():\n                return\n            time.sleep(0.5)\n        raise RuntimeError('Failed to start cloudinit server')\n"
u"985,    def is_running(self):\n        for port in self.container.client.info.port():\n            if port['network'] == 'tcp' and port['port'] == 8080 and port['ip'] == '127.0.0.1':\n                return True\n        return False\n"
u"986,import signal\nimport time\n\nfrom zeroos.orchestrator.sal import templates\n\nDNSMASQ = '/bin/dnsmasq --conf-file=/etc/dnsmasq.conf -d'\n\n\nclass DHCP:\n    def __init__(self, container, domain, dhcps):\n        self.container = container\n        self.domain = domain\n        self.dhcps = dhcps\n\n    def apply_config(self):\n        dnsmasq = templates.render('dnsmasq.conf', domain=self.domain, dhcps=self.dhcps)\n        self.container.upload_content('/etc/dnsmasq.conf', dnsmasq)\n\n        dhcp = templates.render('dhcp', dhcps=self.dhcps)\n        self.container.upload_content('/etc/dhcp', dhcp)\n\n        for process in self.container.client.process.list():\n            if 'dnsmasq' in process['cmdline']:\n                self.container.client.process.kill(process['pid'], signal.SIGTERM)\n                start = time.time()\n                while start + 10 > time.time():\n                    if not self.is_running():\n                        break\n                    time.sleep(0.2)\n                break\n\n        self.container.client.system(DNSMASQ)\n        # check if command is listening for dhcp\n        start = time.time()\n        while start + 10 > time.time():\n            if self.is_running():\n                break\n            time.sleep(0.2)\n        else:\n            raise RuntimeError('Failed to run dnsmasq')\n\n    def is_running(self):\n        for port in self.container.client.info.port():\n            if port['network'] == 'udp' and port['port'] == 53:\n                return True\n"
u"987,class DHCP:\n    def __init__(self, container, domain, dhcps):\n        self.container = container\n        self.domain = domain\n        self.dhcps = dhcps\n\n    def apply_config(self):\n        dnsmasq = templates.render('dnsmasq.conf', domain=self.domain, dhcps=self.dhcps)\n        self.container.upload_content('/etc/dnsmasq.conf', dnsmasq)\n\n        dhcp = templates.render('dhcp', dhcps=self.dhcps)\n        self.container.upload_content('/etc/dhcp', dhcp)\n\n        for process in self.container.client.process.list():\n            if 'dnsmasq' in process['cmdline']:\n                self.container.client.process.kill(process['pid'], signal.SIGTERM)\n                start = time.time()\n                while start + 10 > time.time():\n                    if not self.is_running():\n                        break\n                    time.sleep(0.2)\n                break\n\n        self.container.client.system(DNSMASQ)\n        # check if command is listening for dhcp\n        start = time.time()\n        while start + 10 > time.time():\n            if self.is_running():\n                break\n            time.sleep(0.2)\n        else:\n            raise RuntimeError('Failed to run dnsmasq')\n\n    def is_running(self):\n        for port in self.container.client.info.port():\n            if port['network'] == 'udp' and port['port'] == 53:\n                return True\n"
u'988,    def __init__(self, container, domain, dhcps):\n        self.container = container\n        self.domain = domain\n        self.dhcps = dhcps\n'
u"989,    def apply_config(self):\n        dnsmasq = templates.render('dnsmasq.conf', domain=self.domain, dhcps=self.dhcps)\n        self.container.upload_content('/etc/dnsmasq.conf', dnsmasq)\n\n        dhcp = templates.render('dhcp', dhcps=self.dhcps)\n        self.container.upload_content('/etc/dhcp', dhcp)\n\n        for process in self.container.client.process.list():\n            if 'dnsmasq' in process['cmdline']:\n                self.container.client.process.kill(process['pid'], signal.SIGTERM)\n                start = time.time()\n                while start + 10 > time.time():\n                    if not self.is_running():\n                        break\n                    time.sleep(0.2)\n                break\n\n        self.container.client.system(DNSMASQ)\n        # check if command is listening for dhcp\n        start = time.time()\n        while start + 10 > time.time():\n            if self.is_running():\n                break\n            time.sleep(0.2)\n        else:\n            raise RuntimeError('Failed to run dnsmasq')\n"
u"990,    def is_running(self):\n        for port in self.container.client.info.port():\n            if port['network'] == 'udp' and port['port'] == 53:\n                return True\n"
u'991,from zeroos.orchestrator.sal import templates\nimport ipaddress\n\n\nclass Network:\n    def __init__(self, iface, cidr):\n        self.iface = iface\n        ipiface = ipaddress.IPv4Interface(cidr)\n        self.ipaddress = str(ipiface.ip)\n        self.subnet = str(ipiface.network)\n\n\nclass Firewall:\n    def __init__(self, container, publicnetwork, privatenetworks, forwards):\n        \'\'\'\n\n        \'\'\'\n        self.container = container\n        self.publicnetwork = publicnetwork\n        self.privatenetworks = privatenetworks\n        self.forwards = forwards\n\n    def apply_rules(self):\n        # nftables\n        nftables = templates.render(\'nftables.conf\',\n                                    privatenetworks=self.privatenetworks,\n                                    publicnetwork=self.publicnetwork,\n                                    portforwards=self.forwards)\n        self.container.upload_content(\'/etc/nftables.conf\', nftables)\n        job = self.container.client.system(\'nft -f /etc/nftables.conf\').get()\n        if job.state != \'SUCCESS\':\n            raise RuntimeError("Failed to apply nftables {} {}".format(job.stdout, job.stderr))\n'
u'992,class Network:\n    def __init__(self, iface, cidr):\n        self.iface = iface\n        ipiface = ipaddress.IPv4Interface(cidr)\n        self.ipaddress = str(ipiface.ip)\n        self.subnet = str(ipiface.network)\n'
u'993,class Firewall:\n    def __init__(self, container, publicnetwork, privatenetworks, forwards):\n        \'\'\'\n\n        \'\'\'\n        self.container = container\n        self.publicnetwork = publicnetwork\n        self.privatenetworks = privatenetworks\n        self.forwards = forwards\n\n    def apply_rules(self):\n        # nftables\n        nftables = templates.render(\'nftables.conf\',\n                                    privatenetworks=self.privatenetworks,\n                                    publicnetwork=self.publicnetwork,\n                                    portforwards=self.forwards)\n        self.container.upload_content(\'/etc/nftables.conf\', nftables)\n        job = self.container.client.system(\'nft -f /etc/nftables.conf\').get()\n        if job.state != \'SUCCESS\':\n            raise RuntimeError("Failed to apply nftables {} {}".format(job.stdout, job.stderr))\n'
u'994,    def __init__(self, iface, cidr):\n        self.iface = iface\n        ipiface = ipaddress.IPv4Interface(cidr)\n        self.ipaddress = str(ipiface.ip)\n        self.subnet = str(ipiface.network)\n'
u"995,    def __init__(self, container, publicnetwork, privatenetworks, forwards):\n        '''\n\n        '''\n        self.container = container\n        self.publicnetwork = publicnetwork\n        self.privatenetworks = privatenetworks\n        self.forwards = forwards\n"
u'996,    def apply_rules(self):\n        # nftables\n        nftables = templates.render(\'nftables.conf\',\n                                    privatenetworks=self.privatenetworks,\n                                    publicnetwork=self.publicnetwork,\n                                    portforwards=self.forwards)\n        self.container.upload_content(\'/etc/nftables.conf\', nftables)\n        job = self.container.client.system(\'nft -f /etc/nftables.conf\').get()\n        if job.state != \'SUCCESS\':\n            raise RuntimeError("Failed to apply nftables {} {}".format(job.stdout, job.stderr))\n'
u'997,from zeroos.orchestrator.sal import templates\nimport signal\nimport time\n\n\nclass HTTPServer:\n    def __init__(self, container, httpproxies):\n        self.container = container\n        self.httpproxies = httpproxies\n\n    def apply_rules(self):\n        # caddy\n        caddyconfig = templates.render(\'caddy.conf\', httpproxies=self.httpproxies)\n        self.container.upload_content(\'/etc/caddy.conf\', caddyconfig)\n        job = self.get_job()\n        if job:\n            self.container.client.job.kill(job[\'cmd\'][\'id\'], int(signal.SIGUSR1))\n        else:\n            self.container.client.system(\'caddy -agree -conf /etc/caddy.conf\', stdin=\'\\n\')\n        start = time.time()\n        while start + 10 > time.time():\n            if self.is_running():\n                return True\n            time.sleep(0.5)\n        raise RuntimeError("Failed to start caddy server")\n\n    def get_job(self):\n        for job in self.container.client.job.list():\n            cmd = job[\'cmd\']\n            if cmd[\'command\'] != \'core.system\':\n                continue\n            if cmd[\'arguments\'][\'name\'] == \'caddy\':\n                return job\n\n    def is_running(self):\n        for port in self.container.client.info.port():\n            if port[\'network\'].startswith(\'tcp\') and port[\'port\'] in [80, 443]:\n                return True\n        return False\n'
u'998,class HTTPServer:\n    def __init__(self, container, httpproxies):\n        self.container = container\n        self.httpproxies = httpproxies\n\n    def apply_rules(self):\n        # caddy\n        caddyconfig = templates.render(\'caddy.conf\', httpproxies=self.httpproxies)\n        self.container.upload_content(\'/etc/caddy.conf\', caddyconfig)\n        job = self.get_job()\n        if job:\n            self.container.client.job.kill(job[\'cmd\'][\'id\'], int(signal.SIGUSR1))\n        else:\n            self.container.client.system(\'caddy -agree -conf /etc/caddy.conf\', stdin=\'\\n\')\n        start = time.time()\n        while start + 10 > time.time():\n            if self.is_running():\n                return True\n            time.sleep(0.5)\n        raise RuntimeError("Failed to start caddy server")\n\n    def get_job(self):\n        for job in self.container.client.job.list():\n            cmd = job[\'cmd\']\n            if cmd[\'command\'] != \'core.system\':\n                continue\n            if cmd[\'arguments\'][\'name\'] == \'caddy\':\n                return job\n\n    def is_running(self):\n        for port in self.container.client.info.port():\n            if port[\'network\'].startswith(\'tcp\') and port[\'port\'] in [80, 443]:\n                return True\n        return False\n'
u'999,    def __init__(self, container, httpproxies):\n        self.container = container\n        self.httpproxies = httpproxies\n'
u'1000,    def apply_rules(self):\n        # caddy\n        caddyconfig = templates.render(\'caddy.conf\', httpproxies=self.httpproxies)\n        self.container.upload_content(\'/etc/caddy.conf\', caddyconfig)\n        job = self.get_job()\n        if job:\n            self.container.client.job.kill(job[\'cmd\'][\'id\'], int(signal.SIGUSR1))\n        else:\n            self.container.client.system(\'caddy -agree -conf /etc/caddy.conf\', stdin=\'\\n\')\n        start = time.time()\n        while start + 10 > time.time():\n            if self.is_running():\n                return True\n            time.sleep(0.5)\n        raise RuntimeError("Failed to start caddy server")\n'
u"1001,    def get_job(self):\n        for job in self.container.client.job.list():\n            cmd = job['cmd']\n            if cmd['command'] != 'core.system':\n                continue\n            if cmd['arguments']['name'] == 'caddy':\n                return job\n"
u"1002,    def is_running(self):\n        for port in self.container.client.info.port():\n            if port['network'].startswith('tcp') and port['port'] in [80, 443]:\n                return True\n        return False\n"
u"1003,import signal\nimport time\nimport requests\nfrom js9 import j\n\n\nclass Grafana:\n    def __init__(self, container, ip, port):\n        self.container = container\n        self.ip = ip\n        self.port = port\n        self.client = j.clients.grafana.get(url='http://%s:%d' % (\n            ip, port), username='admin', password='admin')\n\n    def apply_config(self):\n        f = self.container.client.filesystem.open('/opt/grafana/conf/defaults.ini')\n        try:\n            template = self.container.client.filesystem.read(f)\n        finally:\n            self.container.client.filesystem.close(f)\n\n        template = template.replace(b'3000', str(self.port).encode())\n        self.container.client.filesystem.mkdir('/etc/grafana/')\n        self.container.upload_content('/etc/grafana/grafana.ini', template)\n\n    def is_running(self):\n        for process in self.container.client.process.list():\n            if 'grafana-server' in process['cmdline']:\n                    return True, process['pid']\n        return False, None\n\n    def stop(self, timeout=30):\n        is_running, pid = self.is_running()\n        if not is_running:\n            return\n\n        self.container.client.process.kill(pid, signal.SIGTERM)\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if is_running:\n            raise RuntimeError('Failed to stop grafana.')\n\n        if self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.drop_port(self.port)\n\n    def start(self, timeout=30):\n        is_running, _ = self.is_running()\n        if is_running:\n            return\n\n        self.apply_config()\n\n        if not self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.open_port(self.port)\n\n        self.container.client.system(\n            'grafana-server -config /etc/grafana/grafana.ini -homepath /opt/grafana')\n        time.sleep(1)\n\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while not is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if not is_running:\n            if self.container.node.client.nft.rule_exists(self.port):\n                self.container.node.client.nft.drop_port(self.port)\n            raise RuntimeError('Failed to start grafana.')\n\n    def add_data_source(self, database, name, ip, port, count):\n                data = {\n                    'type': 'influxdb',\n                    'access': 'proxy',\n                    'database': database,\n                    'name': name,\n                    'url': 'http://%s:%u' % (ip, port),\n                    'user': 'admin',\n                    'password': 'passwd',\n                    'default': True,\n                }\n\n                now = time.time()\n                while time.time() - now < 10:\n                    try:\n                        self.client.addDataSource(data)\n                        if len(self.client.listDataSources()) == count + 1:\n                            continue\n                        break\n                    except requests.exceptions.ConnectionError:\n                        time.sleep(1)\n                        pass\n"
u"1004,class Grafana:\n    def __init__(self, container, ip, port):\n        self.container = container\n        self.ip = ip\n        self.port = port\n        self.client = j.clients.grafana.get(url='http://%s:%d' % (\n            ip, port), username='admin', password='admin')\n\n    def apply_config(self):\n        f = self.container.client.filesystem.open('/opt/grafana/conf/defaults.ini')\n        try:\n            template = self.container.client.filesystem.read(f)\n        finally:\n            self.container.client.filesystem.close(f)\n\n        template = template.replace(b'3000', str(self.port).encode())\n        self.container.client.filesystem.mkdir('/etc/grafana/')\n        self.container.upload_content('/etc/grafana/grafana.ini', template)\n\n    def is_running(self):\n        for process in self.container.client.process.list():\n            if 'grafana-server' in process['cmdline']:\n                    return True, process['pid']\n        return False, None\n\n    def stop(self, timeout=30):\n        is_running, pid = self.is_running()\n        if not is_running:\n            return\n\n        self.container.client.process.kill(pid, signal.SIGTERM)\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if is_running:\n            raise RuntimeError('Failed to stop grafana.')\n\n        if self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.drop_port(self.port)\n\n    def start(self, timeout=30):\n        is_running, _ = self.is_running()\n        if is_running:\n            return\n\n        self.apply_config()\n\n        if not self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.open_port(self.port)\n\n        self.container.client.system(\n            'grafana-server -config /etc/grafana/grafana.ini -homepath /opt/grafana')\n        time.sleep(1)\n\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while not is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if not is_running:\n            if self.container.node.client.nft.rule_exists(self.port):\n                self.container.node.client.nft.drop_port(self.port)\n            raise RuntimeError('Failed to start grafana.')\n\n    def add_data_source(self, database, name, ip, port, count):\n                data = {\n                    'type': 'influxdb',\n                    'access': 'proxy',\n                    'database': database,\n                    'name': name,\n                    'url': 'http://%s:%u' % (ip, port),\n                    'user': 'admin',\n                    'password': 'passwd',\n                    'default': True,\n                }\n\n                now = time.time()\n                while time.time() - now < 10:\n                    try:\n                        self.client.addDataSource(data)\n                        if len(self.client.listDataSources()) == count + 1:\n                            continue\n                        break\n                    except requests.exceptions.ConnectionError:\n                        time.sleep(1)\n                        pass\n"
u"1005,    def __init__(self, container, ip, port):\n        self.container = container\n        self.ip = ip\n        self.port = port\n        self.client = j.clients.grafana.get(url='http://%s:%d' % (\n            ip, port), username='admin', password='admin')\n"
u"1006,    def apply_config(self):\n        f = self.container.client.filesystem.open('/opt/grafana/conf/defaults.ini')\n        try:\n            template = self.container.client.filesystem.read(f)\n        finally:\n            self.container.client.filesystem.close(f)\n\n        template = template.replace(b'3000', str(self.port).encode())\n        self.container.client.filesystem.mkdir('/etc/grafana/')\n        self.container.upload_content('/etc/grafana/grafana.ini', template)\n"
u"1007,    def is_running(self):\n        for process in self.container.client.process.list():\n            if 'grafana-server' in process['cmdline']:\n                    return True, process['pid']\n        return False, None\n"
u"1008,    def stop(self, timeout=30):\n        is_running, pid = self.is_running()\n        if not is_running:\n            return\n\n        self.container.client.process.kill(pid, signal.SIGTERM)\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if is_running:\n            raise RuntimeError('Failed to stop grafana.')\n\n        if self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.drop_port(self.port)\n"
u"1009,    def start(self, timeout=30):\n        is_running, _ = self.is_running()\n        if is_running:\n            return\n\n        self.apply_config()\n\n        if not self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.open_port(self.port)\n\n        self.container.client.system(\n            'grafana-server -config /etc/grafana/grafana.ini -homepath /opt/grafana')\n        time.sleep(1)\n\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while not is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if not is_running:\n            if self.container.node.client.nft.rule_exists(self.port):\n                self.container.node.client.nft.drop_port(self.port)\n            raise RuntimeError('Failed to start grafana.')\n"
u"1010,    def add_data_source(self, database, name, ip, port, count):\n                data = {\n                    'type': 'influxdb',\n                    'access': 'proxy',\n                    'database': database,\n                    'name': name,\n                    'url': 'http://%s:%u' % (ip, port),\n                    'user': 'admin',\n                    'password': 'passwd',\n                    'default': True,\n                }\n\n                now = time.time()\n                while time.time() - now < 10:\n                    try:\n                        self.client.addDataSource(data)\n                        if len(self.client.listDataSources()) == count + 1:\n                            continue\n                        break\n                    except requests.exceptions.ConnectionError:\n                        time.sleep(1)\n                        pass\n"
u"1011,import signal\nimport time\n\nfrom zeroos.orchestrator.sal import templates\nfrom js9 import j\n\n\nclass InfluxDB:\n    def __init__(self, container, ip, port):\n        self.container = container\n        self.ip = ip\n        self.port = port\n\n    def apply_config(self):\n        influx_conf = templates.render('influxdb.conf', ip=self.ip, port=self.port)\n        self.container.upload_content('/etc/influxdb/influxdb.conf', influx_conf)\n\n    def is_running(self):\n        for process in self.container.client.process.list():\n            if 'influxd' in process['cmdline']:\n                try:\n                    self.list_databases()\n                except:\n                    return False, process['pid']\n                else:\n                    return True, process['pid']\n        return False, None\n\n    def stop(self, timeout=30):\n        is_running, pid = self.is_running()\n        if not is_running:\n            return\n\n        self.container.client.process.kill(pid, signal.SIGTERM)\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if is_running:\n            raise RuntimeError('Failed to stop influxd.')\n\n        if self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.drop_port(self.port)\n\n    def start(self, timeout=30):\n        is_running, _ = self.is_running()\n        if is_running:\n            return\n\n        self.apply_config()\n\n        if not self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.open_port(self.port)\n\n        self.container.client.system('influxd')\n        time.sleep(1)\n\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while not is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if not is_running:\n            if self.container.node.client.nft.rule_exists(self.port):\n                self.container.node.client.nft.drop_port(self.port)\n            raise RuntimeError('Failed to start influxd.')\n\n    def list_databases(self):\n        client = j.clients.influxdb.get(self.ip, port=self.port)\n        return client.get_list_database()\n\n    def create_databases(self, databases):\n        client = j.clients.influxdb.get(self.ip, port=self.port)\n\n        for database in databases:\n            client.create_database(database)\n\n    def drop_databases(self, databases):\n        client = j.clients.influxdb.get(self.ip, port=self.port)\n\n        for database in databases:\n            client.drop_database(database)\n"
u"1012,class InfluxDB:\n    def __init__(self, container, ip, port):\n        self.container = container\n        self.ip = ip\n        self.port = port\n\n    def apply_config(self):\n        influx_conf = templates.render('influxdb.conf', ip=self.ip, port=self.port)\n        self.container.upload_content('/etc/influxdb/influxdb.conf', influx_conf)\n\n    def is_running(self):\n        for process in self.container.client.process.list():\n            if 'influxd' in process['cmdline']:\n                try:\n                    self.list_databases()\n                except:\n                    return False, process['pid']\n                else:\n                    return True, process['pid']\n        return False, None\n\n    def stop(self, timeout=30):\n        is_running, pid = self.is_running()\n        if not is_running:\n            return\n\n        self.container.client.process.kill(pid, signal.SIGTERM)\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if is_running:\n            raise RuntimeError('Failed to stop influxd.')\n\n        if self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.drop_port(self.port)\n\n    def start(self, timeout=30):\n        is_running, _ = self.is_running()\n        if is_running:\n            return\n\n        self.apply_config()\n\n        if not self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.open_port(self.port)\n\n        self.container.client.system('influxd')\n        time.sleep(1)\n\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while not is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if not is_running:\n            if self.container.node.client.nft.rule_exists(self.port):\n                self.container.node.client.nft.drop_port(self.port)\n            raise RuntimeError('Failed to start influxd.')\n\n    def list_databases(self):\n        client = j.clients.influxdb.get(self.ip, port=self.port)\n        return client.get_list_database()\n\n    def create_databases(self, databases):\n        client = j.clients.influxdb.get(self.ip, port=self.port)\n\n        for database in databases:\n            client.create_database(database)\n\n    def drop_databases(self, databases):\n        client = j.clients.influxdb.get(self.ip, port=self.port)\n\n        for database in databases:\n            client.drop_database(database)\n"
u'1013,    def __init__(self, container, ip, port):\n        self.container = container\n        self.ip = ip\n        self.port = port\n'
u"1014,    def apply_config(self):\n        influx_conf = templates.render('influxdb.conf', ip=self.ip, port=self.port)\n        self.container.upload_content('/etc/influxdb/influxdb.conf', influx_conf)\n"
u"1015,    def is_running(self):\n        for process in self.container.client.process.list():\n            if 'influxd' in process['cmdline']:\n                try:\n                    self.list_databases()\n                except:\n                    return False, process['pid']\n                else:\n                    return True, process['pid']\n        return False, None\n"
u"1016,    def stop(self, timeout=30):\n        is_running, pid = self.is_running()\n        if not is_running:\n            return\n\n        self.container.client.process.kill(pid, signal.SIGTERM)\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if is_running:\n            raise RuntimeError('Failed to stop influxd.')\n\n        if self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.drop_port(self.port)\n"
u"1017,    def start(self, timeout=30):\n        is_running, _ = self.is_running()\n        if is_running:\n            return\n\n        self.apply_config()\n\n        if not self.container.node.client.nft.rule_exists(self.port):\n            self.container.node.client.nft.open_port(self.port)\n\n        self.container.client.system('influxd')\n        time.sleep(1)\n\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while not is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if not is_running:\n            if self.container.node.client.nft.rule_exists(self.port):\n                self.container.node.client.nft.drop_port(self.port)\n            raise RuntimeError('Failed to start influxd.')\n"
u'1018,    def list_databases(self):\n        client = j.clients.influxdb.get(self.ip, port=self.port)\n        return client.get_list_database()\n'
u'1019,    def create_databases(self, databases):\n        client = j.clients.influxdb.get(self.ip, port=self.port)\n\n        for database in databases:\n            client.create_database(database)\n'
u'1020,    def drop_databases(self, databases):\n        client = j.clients.influxdb.get(self.ip, port=self.port)\n\n        for database in databases:\n            client.drop_database(database)\n'
u"1021,import jinja2\nimport os\n\n\ndef get(templatename):\n    templatepath = os.path.dirname(__file__)\n    loader = jinja2.FileSystemLoader(templatepath)\n    env = jinja2.Environment(loader=loader)\n    return env.get_template(templatename)\n\n\ndef render(templatename, **kwargs):\n    env = get(templatename)\n    return env.render(**kwargs) + '\\n'\n"
u'1022,def get(templatename):\n    templatepath = os.path.dirname(__file__)\n    loader = jinja2.FileSystemLoader(templatepath)\n    env = jinja2.Environment(loader=loader)\n    return env.get_template(templatename)\n'
u"1023,def render(templatename, **kwargs):\n    env = get(templatename)\n    return env.render(**kwargs) + '\\n'\n"
u'1024,import json\nfrom io import BytesIO\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass Containers:\n    def __init__(self, node):\n        self.node = node\n\n    def list(self):\n        containers = []\n        for container in self.node.client.container.list().values():\n            try:\n                containers.append(Container.from_containerinfo(container, self.node))\n            except ValueError:\n                # skip containers withouth tags\n                pass\n        return containers\n\n    def get(self, name):\n        containers = list(self.node.client.container.find(name).values())\n        if not containers:\n            raise LookupError("Could not find container with name {}".format(name))\n        if len(containers) > 1:\n            raise LookupError("Found more than one containter with name {}".format(name))\n        return Container.from_containerinfo(containers[0], self.node)\n\n    def create(self, name, flist, hostname=None, mounts=None, nics=None,\n               host_network=False, ports=None, storage=None, init_processes=None, privileged=False):\n        logger.debug("create container %s", name)\n        container = Container(name, self.node, flist, hostname, mounts, nics,\n                              host_network, ports, storage, init_processes, privileged)\n        container.start()\n        return container\n\n\nclass Container:\n    """G8SO Container"""\n\n    def __init__(self, name, node, flist, hostname=None, mounts=None, nics=None,\n                 host_network=False, ports=None, storage=None, init_processes=None, privileged=False):\n        """\n        TODO: write doc string\n        filesystems: dict {filesystemObj: target}\n        """\n        self.name = name\n        self.node = node\n        self.mounts = mounts or {}\n        self.hostname = hostname\n        self.flist = flist\n        self.ports = ports or {}\n        self.nics = nics or []\n        self.host_network = host_network\n        self.storage = storage\n        self.init_processes = init_processes or []\n        self._client = None\n        self.privileged = privileged\n\n        self._ays = None\n        for nic in self.nics:\n            nic.pop(\'token\', None)\n\n    @classmethod\n    def from_containerinfo(cls, containerinfo, node):\n        logger.debug("create container from info")\n        arguments = containerinfo[\'container\'][\'arguments\']\n        if not arguments[\'tags\']:\n            # we don\'t deal with tagless containers\n            raise ValueError("Could not load containerinfo withouth tags")\n        return cls(arguments[\'tags\'][0],\n                   node,\n                   arguments[\'root\'],\n                   arguments[\'hostname\'],\n                   arguments[\'mount\'],\n                   arguments[\'nics\'],\n                   arguments[\'host_network\'],\n                   arguments[\'port\'],\n                   arguments[\'storage\'],\n                   arguments[\'privileged\'])\n\n    @classmethod\n    def from_ays(cls, service, password=None):\n        logger.debug("create container from service (%s)", service)\n        from .Node import Node\n        node = Node.from_ays(service.parent, password)\n        ports = {}\n        for portmap in service.model.data.ports:\n            source, dest = portmap.split(\':\')\n            ports[int(source)] = int(dest)\n        nics = [nic.to_dict() for nic in service.model.data.nics]\n        mounts = {}\n        for mount in service.model.data.mounts:\n            fs_service = service.aysrepo.serviceGet(\'filesystem\', mount.filesystem)\n            try:\n                sp = node.storagepools.get(fs_service.parent.name)\n                fs = sp.get(fs_service.name)\n            except KeyError:\n                continue\n            mounts[fs.path] = mount.target\n\n        container = cls(\n            name=service.name,\n            node=node,\n            mounts=mounts,\n            nics=nics,\n            hostname=service.model.data.hostname,\n            flist=service.model.data.flist,\n            ports=ports,\n            host_network=service.model.data.hostNetworking,\n            storage=service.model.data.storage,\n            init_processes=[p.to_dict() for p in service.model.data.initProcesses],\n            privileged=service.model.data.privileged,\n        )\n        return container\n\n    @property\n    def id(self):\n        logger.debug("get container id")\n        info = self.info\n        if info:\n            return info[\'container\'][\'id\']\n        return\n\n    @property\n    def info(self):\n        logger.debug("get container info")\n        for containerid, container in self.node.client.container.list().items():\n            if self.name in (container[\'container\'][\'arguments\'][\'tags\'] or []):\n                container[\'container\'][\'id\'] = int(containerid)\n                return container\n        return\n\n    @property\n    def client(self):\n        if self._client is None:\n            self._client = self.node.client.container.client(self.id)\n        return self._client\n\n    def upload_content(self, remote, content):\n        if isinstance(content, str):\n            content = content.encode(\'utf8\')\n        bytes = BytesIO(content)\n        self.client.filesystem.upload(remote, bytes)\n\n    def _create_container(self, timeout=60):\n        logger.debug("send create container command to g8os")\n        tags = [self.name]\n        if self.hostname and self.hostname != self.name:\n            tags.append(self.hostname)\n        job = self.node.client.container.create(\n            root_url=self.flist,\n            mount=self.mounts,\n            host_network=self.host_network,\n            nics=self.nics,\n            port=self.ports,\n            tags=tags,\n            hostname=self.hostname,\n            storage=self.storage,\n            privileged=self.privileged,\n        )\n\n        containerid = job.get(timeout)\n        self._client = self.node.client.container.client(containerid)\n\n    def start(self):\n        if not self.is_running():\n            logger.debug("start %s", self)\n            self._create_container()\n            for process in self.init_processes:\n                cmd = "{} {}".format(process[\'name\'], \' \'.join(process.get(\'args\', [])))\n                pwd = process.get(\'pwd\', \'\')\n                stdin = process.get(\'stdin\', \'\')\n                env = {}\n                for x in process.get(\'environment\', []):\n                    k, v = x.split("=")\n                    env[k] = v\n                self.client.system(command=cmd, dir=pwd, stdin=stdin, env=env)\n\n    def stop(self):\n        if not self.is_running():\n            return\n        logger.debug("stop %s", self)\n\n        self.node.client.container.terminate(self.id)\n        self._client = None\n\n    def is_running(self):\n        return self.id is not None\n\n    @property\n    def ays(self):\n        if self._ays is None:\n            from JumpScale.sal.g8os.atyourservice.StorageCluster import ContainerAYS\n            self._ays = ContainerAYS(self)\n        return self._ays\n\n    def __str__(self):\n        return "Container <{}>".format(self.name)\n\n    def __repr__(self):\n        return str(self)\n'
u'1025,class Containers:\n    def __init__(self, node):\n        self.node = node\n\n    def list(self):\n        containers = []\n        for container in self.node.client.container.list().values():\n            try:\n                containers.append(Container.from_containerinfo(container, self.node))\n            except ValueError:\n                # skip containers withouth tags\n                pass\n        return containers\n\n    def get(self, name):\n        containers = list(self.node.client.container.find(name).values())\n        if not containers:\n            raise LookupError("Could not find container with name {}".format(name))\n        if len(containers) > 1:\n            raise LookupError("Found more than one containter with name {}".format(name))\n        return Container.from_containerinfo(containers[0], self.node)\n\n    def create(self, name, flist, hostname=None, mounts=None, nics=None,\n               host_network=False, ports=None, storage=None, init_processes=None, privileged=False):\n        logger.debug("create container %s", name)\n        container = Container(name, self.node, flist, hostname, mounts, nics,\n                              host_network, ports, storage, init_processes, privileged)\n        container.start()\n        return container\n'
u'1026,class Container:\n    """G8SO Container"""\n\n    def __init__(self, name, node, flist, hostname=None, mounts=None, nics=None,\n                 host_network=False, ports=None, storage=None, init_processes=None, privileged=False):\n        """\n        TODO: write doc string\n        filesystems: dict {filesystemObj: target}\n        """\n        self.name = name\n        self.node = node\n        self.mounts = mounts or {}\n        self.hostname = hostname\n        self.flist = flist\n        self.ports = ports or {}\n        self.nics = nics or []\n        self.host_network = host_network\n        self.storage = storage\n        self.init_processes = init_processes or []\n        self._client = None\n        self.privileged = privileged\n\n        self._ays = None\n        for nic in self.nics:\n            nic.pop(\'token\', None)\n\n    @classmethod\n    def from_containerinfo(cls, containerinfo, node):\n        logger.debug("create container from info")\n        arguments = containerinfo[\'container\'][\'arguments\']\n        if not arguments[\'tags\']:\n            # we don\'t deal with tagless containers\n            raise ValueError("Could not load containerinfo withouth tags")\n        return cls(arguments[\'tags\'][0],\n                   node,\n                   arguments[\'root\'],\n                   arguments[\'hostname\'],\n                   arguments[\'mount\'],\n                   arguments[\'nics\'],\n                   arguments[\'host_network\'],\n                   arguments[\'port\'],\n                   arguments[\'storage\'],\n                   arguments[\'privileged\'])\n\n    @classmethod\n    def from_ays(cls, service, password=None):\n        logger.debug("create container from service (%s)", service)\n        from .Node import Node\n        node = Node.from_ays(service.parent, password)\n        ports = {}\n        for portmap in service.model.data.ports:\n            source, dest = portmap.split(\':\')\n            ports[int(source)] = int(dest)\n        nics = [nic.to_dict() for nic in service.model.data.nics]\n        mounts = {}\n        for mount in service.model.data.mounts:\n            fs_service = service.aysrepo.serviceGet(\'filesystem\', mount.filesystem)\n            try:\n                sp = node.storagepools.get(fs_service.parent.name)\n                fs = sp.get(fs_service.name)\n            except KeyError:\n                continue\n            mounts[fs.path] = mount.target\n\n        container = cls(\n            name=service.name,\n            node=node,\n            mounts=mounts,\n            nics=nics,\n            hostname=service.model.data.hostname,\n            flist=service.model.data.flist,\n            ports=ports,\n            host_network=service.model.data.hostNetworking,\n            storage=service.model.data.storage,\n            init_processes=[p.to_dict() for p in service.model.data.initProcesses],\n            privileged=service.model.data.privileged,\n        )\n        return container\n\n    @property\n    def id(self):\n        logger.debug("get container id")\n        info = self.info\n        if info:\n            return info[\'container\'][\'id\']\n        return\n\n    @property\n    def info(self):\n        logger.debug("get container info")\n        for containerid, container in self.node.client.container.list().items():\n            if self.name in (container[\'container\'][\'arguments\'][\'tags\'] or []):\n                container[\'container\'][\'id\'] = int(containerid)\n                return container\n        return\n\n    @property\n    def client(self):\n        if self._client is None:\n            self._client = self.node.client.container.client(self.id)\n        return self._client\n\n    def upload_content(self, remote, content):\n        if isinstance(content, str):\n            content = content.encode(\'utf8\')\n        bytes = BytesIO(content)\n        self.client.filesystem.upload(remote, bytes)\n\n    def _create_container(self, timeout=60):\n        logger.debug("send create container command to g8os")\n        tags = [self.name]\n        if self.hostname and self.hostname != self.name:\n            tags.append(self.hostname)\n        job = self.node.client.container.create(\n            root_url=self.flist,\n            mount=self.mounts,\n            host_network=self.host_network,\n            nics=self.nics,\n            port=self.ports,\n            tags=tags,\n            hostname=self.hostname,\n            storage=self.storage,\n            privileged=self.privileged,\n        )\n\n        containerid = job.get(timeout)\n        self._client = self.node.client.container.client(containerid)\n\n    def start(self):\n        if not self.is_running():\n            logger.debug("start %s", self)\n            self._create_container()\n            for process in self.init_processes:\n                cmd = "{} {}".format(process[\'name\'], \' \'.join(process.get(\'args\', [])))\n                pwd = process.get(\'pwd\', \'\')\n                stdin = process.get(\'stdin\', \'\')\n                env = {}\n                for x in process.get(\'environment\', []):\n                    k, v = x.split("=")\n                    env[k] = v\n                self.client.system(command=cmd, dir=pwd, stdin=stdin, env=env)\n\n    def stop(self):\n        if not self.is_running():\n            return\n        logger.debug("stop %s", self)\n\n        self.node.client.container.terminate(self.id)\n        self._client = None\n\n    def is_running(self):\n        return self.id is not None\n\n    @property\n    def ays(self):\n        if self._ays is None:\n            from JumpScale.sal.g8os.atyourservice.StorageCluster import ContainerAYS\n            self._ays = ContainerAYS(self)\n        return self._ays\n\n    def __str__(self):\n        return "Container <{}>".format(self.name)\n\n    def __repr__(self):\n        return str(self)\n'
u'1027,    def __init__(self, node):\n        self.node = node\n'
u'1028,    def list(self):\n        containers = []\n        for container in self.node.client.container.list().values():\n            try:\n                containers.append(Container.from_containerinfo(container, self.node))\n            except ValueError:\n                # skip containers withouth tags\n                pass\n        return containers\n'
u'1029,    def get(self, name):\n        containers = list(self.node.client.container.find(name).values())\n        if not containers:\n            raise LookupError("Could not find container with name {}".format(name))\n        if len(containers) > 1:\n            raise LookupError("Found more than one containter with name {}".format(name))\n        return Container.from_containerinfo(containers[0], self.node)\n'
u'1030,    def create(self, name, flist, hostname=None, mounts=None, nics=None,\n               host_network=False, ports=None, storage=None, init_processes=None, privileged=False):\n        logger.debug("create container %s", name)\n        container = Container(name, self.node, flist, hostname, mounts, nics,\n                              host_network, ports, storage, init_processes, privileged)\n        container.start()\n        return container\n'
u'1031,    def __init__(self, name, node, flist, hostname=None, mounts=None, nics=None,\n                 host_network=False, ports=None, storage=None, init_processes=None, privileged=False):\n        """\n        TODO: write doc string\n        filesystems: dict {filesystemObj: target}\n        """\n        self.name = name\n        self.node = node\n        self.mounts = mounts or {}\n        self.hostname = hostname\n        self.flist = flist\n        self.ports = ports or {}\n        self.nics = nics or []\n        self.host_network = host_network\n        self.storage = storage\n        self.init_processes = init_processes or []\n        self._client = None\n        self.privileged = privileged\n\n        self._ays = None\n        for nic in self.nics:\n            nic.pop(\'token\', None)\n'
u'1032,    @classmethod\n    def from_containerinfo(cls, containerinfo, node):\n        logger.debug("create container from info")\n        arguments = containerinfo[\'container\'][\'arguments\']\n        if not arguments[\'tags\']:\n            # we don\'t deal with tagless containers\n            raise ValueError("Could not load containerinfo withouth tags")\n        return cls(arguments[\'tags\'][0],\n                   node,\n                   arguments[\'root\'],\n                   arguments[\'hostname\'],\n                   arguments[\'mount\'],\n                   arguments[\'nics\'],\n                   arguments[\'host_network\'],\n                   arguments[\'port\'],\n                   arguments[\'storage\'],\n                   arguments[\'privileged\'])\n'
u'1033,    @classmethod\n    def from_ays(cls, service, password=None):\n        logger.debug("create container from service (%s)", service)\n        from .Node import Node\n        node = Node.from_ays(service.parent, password)\n        ports = {}\n        for portmap in service.model.data.ports:\n            source, dest = portmap.split(\':\')\n            ports[int(source)] = int(dest)\n        nics = [nic.to_dict() for nic in service.model.data.nics]\n        mounts = {}\n        for mount in service.model.data.mounts:\n            fs_service = service.aysrepo.serviceGet(\'filesystem\', mount.filesystem)\n            try:\n                sp = node.storagepools.get(fs_service.parent.name)\n                fs = sp.get(fs_service.name)\n            except KeyError:\n                continue\n            mounts[fs.path] = mount.target\n\n        container = cls(\n            name=service.name,\n            node=node,\n            mounts=mounts,\n            nics=nics,\n            hostname=service.model.data.hostname,\n            flist=service.model.data.flist,\n            ports=ports,\n            host_network=service.model.data.hostNetworking,\n            storage=service.model.data.storage,\n            init_processes=[p.to_dict() for p in service.model.data.initProcesses],\n            privileged=service.model.data.privileged,\n        )\n        return container\n'
u'1034,    @property\n    def id(self):\n        logger.debug("get container id")\n        info = self.info\n        if info:\n            return info[\'container\'][\'id\']\n        return\n'
u'1035,    @property\n    def info(self):\n        logger.debug("get container info")\n        for containerid, container in self.node.client.container.list().items():\n            if self.name in (container[\'container\'][\'arguments\'][\'tags\'] or []):\n                container[\'container\'][\'id\'] = int(containerid)\n                return container\n        return\n'
u'1036,    @property\n    def client(self):\n        if self._client is None:\n            self._client = self.node.client.container.client(self.id)\n        return self._client\n'
u"1037,    def upload_content(self, remote, content):\n        if isinstance(content, str):\n            content = content.encode('utf8')\n        bytes = BytesIO(content)\n        self.client.filesystem.upload(remote, bytes)\n"
u'1038,    def _create_container(self, timeout=60):\n        logger.debug("send create container command to g8os")\n        tags = [self.name]\n        if self.hostname and self.hostname != self.name:\n            tags.append(self.hostname)\n        job = self.node.client.container.create(\n            root_url=self.flist,\n            mount=self.mounts,\n            host_network=self.host_network,\n            nics=self.nics,\n            port=self.ports,\n            tags=tags,\n            hostname=self.hostname,\n            storage=self.storage,\n            privileged=self.privileged,\n        )\n\n        containerid = job.get(timeout)\n        self._client = self.node.client.container.client(containerid)\n'
u'1039,    def start(self):\n        if not self.is_running():\n            logger.debug("start %s", self)\n            self._create_container()\n            for process in self.init_processes:\n                cmd = "{} {}".format(process[\'name\'], \' \'.join(process.get(\'args\', [])))\n                pwd = process.get(\'pwd\', \'\')\n                stdin = process.get(\'stdin\', \'\')\n                env = {}\n                for x in process.get(\'environment\', []):\n                    k, v = x.split("=")\n                    env[k] = v\n                self.client.system(command=cmd, dir=pwd, stdin=stdin, env=env)\n'
u'1040,    def stop(self):\n        if not self.is_running():\n            return\n        logger.debug("stop %s", self)\n\n        self.node.client.container.terminate(self.id)\n        self._client = None\n'
u'1041,    def is_running(self):\n        return self.id is not None\n'
u'1042,    @property\n    def ays(self):\n        if self._ays is None:\n            from JumpScale.sal.g8os.atyourservice.StorageCluster import ContainerAYS\n            self._ays = ContainerAYS(self)\n        return self._ays\n'
u'1043,    def __str__(self):\n        return "Container <{}>".format(self.name)\n'
u'1044,    def __repr__(self):\n        return str(self)\n'
u'1045,from enum import Enum\nfrom .Partition import Partition\nfrom .abstracts import Mountable\n\n\nclass DiskType(Enum):\n    ssd = "ssd"\n    hdd = "hdd"\n    nvme = "nvme"\n    archive = "archive"\n    cdrom = \'cdrom\'\n\n\nclass Disks:\n\n    """Subobject to list disks"""\n    def __init__(self, node):\n        self.node = node\n        self._client = node.client\n\n    def list(self):\n        """\n        List of disks on the node\n        """\n        disks = []\n        disk_list = self._client.disk.list()\n        if \'blockdevices\' in disk_list:\n            for disk_info in self._client.disk.list()[\'blockdevices\']:\n                disks.append(Disk(\n                    node=self.node,\n                    disk_info=disk_info\n                ))\n        return disks\n\n    def get(self, name):\n        """\n        return the disk called `name`\n        @param name: name of the disk\n        """\n        for disk in self.list():\n            if disk.name == name:\n                return disk\n        return None\n\n\nclass Disk(Mountable):\n    """Disk in a G8OS"""\n\n    def __init__(self, node, disk_info):\n        """\n        disk_info: dict returned by client.disk.list()\n        """\n        # g8os client to talk to the node\n        self.node = node\n        self._client = node.client\n        self.name = None\n        self.size = None\n        self.blocksize = None\n        self.partition_table = None\n        self.mountpoint = None\n        self.model = None\n        self._filesystems = []\n        self.type = None\n        self.partitions = []\n\n        self._load(disk_info)\n\n    @property\n    def devicename(self):\n        return "/dev/{}".format(self.name)\n\n    @property\n    def filesystems(self):\n        self._populate_filesystems()\n        return self._filesystems\n\n    def _load(self, disk_info):\n        self.name = disk_info[\'name\']\n        detail = self._client.disk.getinfo(self.name)\n        self.size = int(disk_info[\'size\'])\n        self.blocksize = detail[\'blocksize\']\n        if detail[\'table\'] != \'unknown\':\n            self.partition_table = detail[\'table\']\n        self.mountpoint = disk_info[\'mountpoint\']\n        self.model = disk_info[\'model\']\n        self.type = self._disk_type(disk_info)\n        for partition_info in disk_info.get(\'children\', []) or []:\n            self.partitions.append(\n                Partition(\n                    disk=self,\n                    part_info=partition_info)\n            )\n\n    def _populate_filesystems(self):\n        """\n        look into all the btrfs filesystem and populate\n        the filesystems attribute of the class with the detail of\n        all the filesystem present on the disk\n        """\n        self._filesystems = []\n        for fs in (self._client.btrfs.list() or []):\n            for device in fs[\'devices\']:\n                if device[\'path\'] == "/dev/{}".format(self.name):\n                    self._filesystems.append(fs)\n                    break\n\n    def _disk_type(self, disk_info):\n        """\n        return the type of the disk\n        """\n        if disk_info[\'rota\'] == "1":\n            if disk_info[\'type\'] == \'rom\':\n                return DiskType.cdrom\n            # assume that if a disk is more than 7TB it\'s a SMR disk\n            elif int(disk_info[\'size\']) > (1024 * 1024 * 1024 * 1024 * 7):\n                return DiskType.archive\n            else:\n                return DiskType.hdd\n        else:\n            if "nvme" in disk_info[\'name\']:\n                return DiskType.nvme\n            else:\n                return DiskType.ssd\n\n    def mktable(self, table_type=\'gpt\', overwrite=False):\n        """\n        create a partition table on the disk\n        @param table_type: Partition table type as accepted by parted\n        @param overwrite: erase any existing partition table\n        """\n        if self.partition_table is not None and overwrite is False:\n            return\n\n        self._client.disk.mktable(\n            disk=self.name,\n            table_type=table_type\n        )\n\n    def mkpart(self, start, end, part_type="primary"):\n        """\n        @param start: partition start as accepted by parted mkpart\n        @param end: partition end as accepted by parted mkpart\n        @param part_type: partition type as accepted by parted mkpart\n        """\n        before = {p.name for p in self.partitions}\n\n        self._client.disk.mkpart(\n            self.name,\n            start=start,\n            end=end,\n            part_type=part_type,\n        )\n        after = {}\n        for disk in self._client.disk.list()[\'blockdevices\']:\n            if disk[\'name\'] != self.name:\n                continue\n            for part in disk.get(\'children\', []):\n                after[part[\'name\']] = part\n        name = set(after.keys()) - before\n\n        part_info = after[list(name)[0]]\n        partition = Partition(\n            disk=self,\n            part_info=part_info)\n        self.partitions.append(partition)\n\n        return partition\n\n    def __str__(self):\n        return "Disk <{}>".format(self.name)\n\n    def __repr__(self):\n        return str(self)\n\n    def __eq__(self, other):\n        return self.devicename == other.devicename\n'
u'1046,class DiskType(Enum):\n    ssd = "ssd"\n    hdd = "hdd"\n    nvme = "nvme"\n    archive = "archive"\n    cdrom = \'cdrom\'\n'
u'1047,class Disks:\n\n    """Subobject to list disks"""\n    def __init__(self, node):\n        self.node = node\n        self._client = node.client\n\n    def list(self):\n        """\n        List of disks on the node\n        """\n        disks = []\n        disk_list = self._client.disk.list()\n        if \'blockdevices\' in disk_list:\n            for disk_info in self._client.disk.list()[\'blockdevices\']:\n                disks.append(Disk(\n                    node=self.node,\n                    disk_info=disk_info\n                ))\n        return disks\n\n    def get(self, name):\n        """\n        return the disk called `name`\n        @param name: name of the disk\n        """\n        for disk in self.list():\n            if disk.name == name:\n                return disk\n        return None\n'
u'1048,class Disk(Mountable):\n    """Disk in a G8OS"""\n\n    def __init__(self, node, disk_info):\n        """\n        disk_info: dict returned by client.disk.list()\n        """\n        # g8os client to talk to the node\n        self.node = node\n        self._client = node.client\n        self.name = None\n        self.size = None\n        self.blocksize = None\n        self.partition_table = None\n        self.mountpoint = None\n        self.model = None\n        self._filesystems = []\n        self.type = None\n        self.partitions = []\n\n        self._load(disk_info)\n\n    @property\n    def devicename(self):\n        return "/dev/{}".format(self.name)\n\n    @property\n    def filesystems(self):\n        self._populate_filesystems()\n        return self._filesystems\n\n    def _load(self, disk_info):\n        self.name = disk_info[\'name\']\n        detail = self._client.disk.getinfo(self.name)\n        self.size = int(disk_info[\'size\'])\n        self.blocksize = detail[\'blocksize\']\n        if detail[\'table\'] != \'unknown\':\n            self.partition_table = detail[\'table\']\n        self.mountpoint = disk_info[\'mountpoint\']\n        self.model = disk_info[\'model\']\n        self.type = self._disk_type(disk_info)\n        for partition_info in disk_info.get(\'children\', []) or []:\n            self.partitions.append(\n                Partition(\n                    disk=self,\n                    part_info=partition_info)\n            )\n\n    def _populate_filesystems(self):\n        """\n        look into all the btrfs filesystem and populate\n        the filesystems attribute of the class with the detail of\n        all the filesystem present on the disk\n        """\n        self._filesystems = []\n        for fs in (self._client.btrfs.list() or []):\n            for device in fs[\'devices\']:\n                if device[\'path\'] == "/dev/{}".format(self.name):\n                    self._filesystems.append(fs)\n                    break\n\n    def _disk_type(self, disk_info):\n        """\n        return the type of the disk\n        """\n        if disk_info[\'rota\'] == "1":\n            if disk_info[\'type\'] == \'rom\':\n                return DiskType.cdrom\n            # assume that if a disk is more than 7TB it\'s a SMR disk\n            elif int(disk_info[\'size\']) > (1024 * 1024 * 1024 * 1024 * 7):\n                return DiskType.archive\n            else:\n                return DiskType.hdd\n        else:\n            if "nvme" in disk_info[\'name\']:\n                return DiskType.nvme\n            else:\n                return DiskType.ssd\n\n    def mktable(self, table_type=\'gpt\', overwrite=False):\n        """\n        create a partition table on the disk\n        @param table_type: Partition table type as accepted by parted\n        @param overwrite: erase any existing partition table\n        """\n        if self.partition_table is not None and overwrite is False:\n            return\n\n        self._client.disk.mktable(\n            disk=self.name,\n            table_type=table_type\n        )\n\n    def mkpart(self, start, end, part_type="primary"):\n        """\n        @param start: partition start as accepted by parted mkpart\n        @param end: partition end as accepted by parted mkpart\n        @param part_type: partition type as accepted by parted mkpart\n        """\n        before = {p.name for p in self.partitions}\n\n        self._client.disk.mkpart(\n            self.name,\n            start=start,\n            end=end,\n            part_type=part_type,\n        )\n        after = {}\n        for disk in self._client.disk.list()[\'blockdevices\']:\n            if disk[\'name\'] != self.name:\n                continue\n            for part in disk.get(\'children\', []):\n                after[part[\'name\']] = part\n        name = set(after.keys()) - before\n\n        part_info = after[list(name)[0]]\n        partition = Partition(\n            disk=self,\n            part_info=part_info)\n        self.partitions.append(partition)\n\n        return partition\n\n    def __str__(self):\n        return "Disk <{}>".format(self.name)\n\n    def __repr__(self):\n        return str(self)\n\n    def __eq__(self, other):\n        return self.devicename == other.devicename\n'
u'1049,    def __init__(self, node):\n        self.node = node\n        self._client = node.client\n'
u'1050,    def list(self):\n        """\n        List of disks on the node\n        """\n        disks = []\n        disk_list = self._client.disk.list()\n        if \'blockdevices\' in disk_list:\n            for disk_info in self._client.disk.list()[\'blockdevices\']:\n                disks.append(Disk(\n                    node=self.node,\n                    disk_info=disk_info\n                ))\n        return disks\n'
u'1051,    def get(self, name):\n        """\n        return the disk called `name`\n        @param name: name of the disk\n        """\n        for disk in self.list():\n            if disk.name == name:\n                return disk\n        return None\n'
u'1052,    def __init__(self, node, disk_info):\n        """\n        disk_info: dict returned by client.disk.list()\n        """\n        # g8os client to talk to the node\n        self.node = node\n        self._client = node.client\n        self.name = None\n        self.size = None\n        self.blocksize = None\n        self.partition_table = None\n        self.mountpoint = None\n        self.model = None\n        self._filesystems = []\n        self.type = None\n        self.partitions = []\n\n        self._load(disk_info)\n'
u'1053,    @property\n    def devicename(self):\n        return "/dev/{}".format(self.name)\n'
u'1054,    @property\n    def filesystems(self):\n        self._populate_filesystems()\n        return self._filesystems\n'
u"1055,    def _load(self, disk_info):\n        self.name = disk_info['name']\n        detail = self._client.disk.getinfo(self.name)\n        self.size = int(disk_info['size'])\n        self.blocksize = detail['blocksize']\n        if detail['table'] != 'unknown':\n            self.partition_table = detail['table']\n        self.mountpoint = disk_info['mountpoint']\n        self.model = disk_info['model']\n        self.type = self._disk_type(disk_info)\n        for partition_info in disk_info.get('children', []) or []:\n            self.partitions.append(\n                Partition(\n                    disk=self,\n                    part_info=partition_info)\n            )\n"
u'1056,    def _populate_filesystems(self):\n        """\n        look into all the btrfs filesystem and populate\n        the filesystems attribute of the class with the detail of\n        all the filesystem present on the disk\n        """\n        self._filesystems = []\n        for fs in (self._client.btrfs.list() or []):\n            for device in fs[\'devices\']:\n                if device[\'path\'] == "/dev/{}".format(self.name):\n                    self._filesystems.append(fs)\n                    break\n'
u'1057,    def _disk_type(self, disk_info):\n        """\n        return the type of the disk\n        """\n        if disk_info[\'rota\'] == "1":\n            if disk_info[\'type\'] == \'rom\':\n                return DiskType.cdrom\n            # assume that if a disk is more than 7TB it\'s a SMR disk\n            elif int(disk_info[\'size\']) > (1024 * 1024 * 1024 * 1024 * 7):\n                return DiskType.archive\n            else:\n                return DiskType.hdd\n        else:\n            if "nvme" in disk_info[\'name\']:\n                return DiskType.nvme\n            else:\n                return DiskType.ssd\n'
u'1058,    def mktable(self, table_type=\'gpt\', overwrite=False):\n        """\n        create a partition table on the disk\n        @param table_type: Partition table type as accepted by parted\n        @param overwrite: erase any existing partition table\n        """\n        if self.partition_table is not None and overwrite is False:\n            return\n\n        self._client.disk.mktable(\n            disk=self.name,\n            table_type=table_type\n        )\n'
u'1059,    def mkpart(self, start, end, part_type="primary"):\n        """\n        @param start: partition start as accepted by parted mkpart\n        @param end: partition end as accepted by parted mkpart\n        @param part_type: partition type as accepted by parted mkpart\n        """\n        before = {p.name for p in self.partitions}\n\n        self._client.disk.mkpart(\n            self.name,\n            start=start,\n            end=end,\n            part_type=part_type,\n        )\n        after = {}\n        for disk in self._client.disk.list()[\'blockdevices\']:\n            if disk[\'name\'] != self.name:\n                continue\n            for part in disk.get(\'children\', []):\n                after[part[\'name\']] = part\n        name = set(after.keys()) - before\n\n        part_info = after[list(name)[0]]\n        partition = Partition(\n            disk=self,\n            part_info=part_info)\n        self.partitions.append(partition)\n\n        return partition\n'
u'1060,    def __str__(self):\n        return "Disk <{}>".format(self.name)\n'
u'1061,    def __repr__(self):\n        return str(self)\n'
u'1062,    def __eq__(self, other):\n        return self.devicename == other.devicename\n'
u'1063,from JumpScale.sal.g8os.Node import Node\nfrom JumpScale.sal.g8os.StorageCluster import StorageCluster\nfrom js9 import j\n\nclass G8OSFactory(object):\n    """Factory for G8OS SAL"""\n\n    def __init__(self):\n        self.__jslocation__ = "j.sal.g8os"\n        self.logger = j.logger.get(\'j.sal.g8os\')\n\n    def get_node(self, addr, port=6379, password=None):\n        """\n        Returns a Node object that represent a G8OS node reachable\n        at addr:port\n        """\n        return Node(\n            addr=addr,\n            port=port,\n            password=password,\n        )\n\n    def create_storagecluster(self, label, nodes, disk_type, nr_server, has_slave=True):\n        """\n        @param label: string repsenting the name of the storage cluster\n        @param nodes: list of node on wich we can deploy storage server\n        @param disk_type: type of disk to be used by the storage server\n        @param nr_server: number of storage server to deploy\n        @param has_slave: boolean specifying of we need to deploy slave storage server\n        """\n        cluster = StorageCluster(label=label)\n        cluster.create(nodes=nodes, disk_type=disk_type, nr_server=nr_server, has_slave=has_slave)\n        return cluster\n\n\nif __name__ == \'__main__\':\n    from js9 import j\n    node1 = j.sal.g8os.get_node(\'172.20.0.91\')\n    node2 = j.sal.g8os.get_node(\'172.20.0.92\')\n    cluster = j.sal.g8os.create_storagecluster(\'cluster1\',[node1, node2],\'hdd\', 2, False)\n\n    from IPython import embed;embed()\n'
u'1064,class G8OSFactory(object):\n    """Factory for G8OS SAL"""\n\n    def __init__(self):\n        self.__jslocation__ = "j.sal.g8os"\n        self.logger = j.logger.get(\'j.sal.g8os\')\n\n    def get_node(self, addr, port=6379, password=None):\n        """\n        Returns a Node object that represent a G8OS node reachable\n        at addr:port\n        """\n        return Node(\n            addr=addr,\n            port=port,\n            password=password,\n        )\n\n    def create_storagecluster(self, label, nodes, disk_type, nr_server, has_slave=True):\n        """\n        @param label: string repsenting the name of the storage cluster\n        @param nodes: list of node on wich we can deploy storage server\n        @param disk_type: type of disk to be used by the storage server\n        @param nr_server: number of storage server to deploy\n        @param has_slave: boolean specifying of we need to deploy slave storage server\n        """\n        cluster = StorageCluster(label=label)\n        cluster.create(nodes=nodes, disk_type=disk_type, nr_server=nr_server, has_slave=has_slave)\n        return cluster\n'
u'1065,    def __init__(self):\n        self.__jslocation__ = "j.sal.g8os"\n        self.logger = j.logger.get(\'j.sal.g8os\')\n'
u'1066,    def get_node(self, addr, port=6379, password=None):\n        """\n        Returns a Node object that represent a G8OS node reachable\n        at addr:port\n        """\n        return Node(\n            addr=addr,\n            port=port,\n            password=password,\n        )\n'
u'1067,    def create_storagecluster(self, label, nodes, disk_type, nr_server, has_slave=True):\n        """\n        @param label: string repsenting the name of the storage cluster\n        @param nodes: list of node on wich we can deploy storage server\n        @param disk_type: type of disk to be used by the storage server\n        @param nr_server: number of storage server to deploy\n        @param has_slave: boolean specifying of we need to deploy slave storage server\n        """\n        cluster = StorageCluster(label=label)\n        cluster.create(nodes=nodes, disk_type=disk_type, nr_server=nr_server, has_slave=has_slave)\n        return cluster\n'
u'1068,import netaddr\n\n\ndef combine(ip1, ip2, mask):\n    """\n    >>> combine(\'10.0.3.11\', \'192.168.1.10\', 24)\n    \'10.0.3.10\'\n    """\n    iip1 = netaddr.IPNetwork(\'{}/{}\'.format(ip1, mask))\n    iip2 = netaddr.IPNetwork(\'{}/{}\'.format(ip2, mask))\n    ires = iip1.network + int(iip2.ip & (~ int(iip2.netmask)))\n    net = netaddr.IPNetwork(ires)\n    net.prefixlen = mask\n    return net\n\n\nclass Network:\n    def __init__(self, node):\n        self.node = node\n        self._client = node.client\n\n    def get_management_info(self):\n        import netaddr\n\n        def get_nic_ip(nics, name):\n            for nic in nics:\n                if nic[\'name\'] == name:\n                    for ip in nic[\'addrs\']:\n                        return netaddr.IPNetwork(ip[\'addr\'])\n                    return\n\n        defaultgwdev = self._client.bash("ip route | grep default | awk \'{print $5}\'").get().stdout.strip()\n        nics = self._client.info.nic()\n        mgmtaddr = None\n        if defaultgwdev:\n            ipgwdev = get_nic_ip(nics, defaultgwdev)\n            if ipgwdev:\n                mgmtaddr = str(ipgwdev.ip)\n        if not mgmtaddr:\n            mgmtaddr = self.addr\n\n        return mgmtaddr\n\n    def get_addresses(self, network):\n        mgmtaddr = self.get_management_info()\n        return {\n            \'storageaddr\': combine(str(network.ip), mgmtaddr, network.prefixlen),\n            \'vxaddr\': combine(\'10.240.0.0\', mgmtaddr, network.prefixlen),\n        }\n\n    def get_free_nics(self):\n        nics = self._client.info.nic()\n        nics.sort(key=lambda nic: nic[\'speed\'])\n        availablenics = {}\n        for nic in nics:\n            # skip all interface that have an ipv4 address\n            if any(netaddr.IPNetwork(addr[\'addr\']).version == 4 for addr in nic[\'addrs\'] if \'addr\' in addr):\n                continue\n            if nic[\'speed\'] == 0:\n                continue\n            availablenics.setdefault(nic[\'speed\'], []).append(nic[\'name\'])\n        return sorted(availablenics.items())\n'
u'1069,def combine(ip1, ip2, mask):\n    """\n    >>> combine(\'10.0.3.11\', \'192.168.1.10\', 24)\n    \'10.0.3.10\'\n    """\n    iip1 = netaddr.IPNetwork(\'{}/{}\'.format(ip1, mask))\n    iip2 = netaddr.IPNetwork(\'{}/{}\'.format(ip2, mask))\n    ires = iip1.network + int(iip2.ip & (~ int(iip2.netmask)))\n    net = netaddr.IPNetwork(ires)\n    net.prefixlen = mask\n    return net\n'
u'1070,class Network:\n    def __init__(self, node):\n        self.node = node\n        self._client = node.client\n\n    def get_management_info(self):\n        import netaddr\n\n        def get_nic_ip(nics, name):\n            for nic in nics:\n                if nic[\'name\'] == name:\n                    for ip in nic[\'addrs\']:\n                        return netaddr.IPNetwork(ip[\'addr\'])\n                    return\n\n        defaultgwdev = self._client.bash("ip route | grep default | awk \'{print $5}\'").get().stdout.strip()\n        nics = self._client.info.nic()\n        mgmtaddr = None\n        if defaultgwdev:\n            ipgwdev = get_nic_ip(nics, defaultgwdev)\n            if ipgwdev:\n                mgmtaddr = str(ipgwdev.ip)\n        if not mgmtaddr:\n            mgmtaddr = self.addr\n\n        return mgmtaddr\n\n    def get_addresses(self, network):\n        mgmtaddr = self.get_management_info()\n        return {\n            \'storageaddr\': combine(str(network.ip), mgmtaddr, network.prefixlen),\n            \'vxaddr\': combine(\'10.240.0.0\', mgmtaddr, network.prefixlen),\n        }\n\n    def get_free_nics(self):\n        nics = self._client.info.nic()\n        nics.sort(key=lambda nic: nic[\'speed\'])\n        availablenics = {}\n        for nic in nics:\n            # skip all interface that have an ipv4 address\n            if any(netaddr.IPNetwork(addr[\'addr\']).version == 4 for addr in nic[\'addrs\'] if \'addr\' in addr):\n                continue\n            if nic[\'speed\'] == 0:\n                continue\n            availablenics.setdefault(nic[\'speed\'], []).append(nic[\'name\'])\n        return sorted(availablenics.items())\n'
u'1071,    def __init__(self, node):\n        self.node = node\n        self._client = node.client\n'
u'1072,    def get_management_info(self):\n        import netaddr\n\n        def get_nic_ip(nics, name):\n            for nic in nics:\n                if nic[\'name\'] == name:\n                    for ip in nic[\'addrs\']:\n                        return netaddr.IPNetwork(ip[\'addr\'])\n                    return\n\n        defaultgwdev = self._client.bash("ip route | grep default | awk \'{print $5}\'").get().stdout.strip()\n        nics = self._client.info.nic()\n        mgmtaddr = None\n        if defaultgwdev:\n            ipgwdev = get_nic_ip(nics, defaultgwdev)\n            if ipgwdev:\n                mgmtaddr = str(ipgwdev.ip)\n        if not mgmtaddr:\n            mgmtaddr = self.addr\n\n        return mgmtaddr\n'
u"1073,    def get_addresses(self, network):\n        mgmtaddr = self.get_management_info()\n        return {\n            'storageaddr': combine(str(network.ip), mgmtaddr, network.prefixlen),\n            'vxaddr': combine('10.240.0.0', mgmtaddr, network.prefixlen),\n        }\n"
u"1074,    def get_free_nics(self):\n        nics = self._client.info.nic()\n        nics.sort(key=lambda nic: nic['speed'])\n        availablenics = {}\n        for nic in nics:\n            # skip all interface that have an ipv4 address\n            if any(netaddr.IPNetwork(addr['addr']).version == 4 for addr in nic['addrs'] if 'addr' in addr):\n                continue\n            if nic['speed'] == 0:\n                continue\n            availablenics.setdefault(nic['speed'], []).append(nic['name'])\n        return sorted(availablenics.items())\n"
u"1075,        def get_nic_ip(nics, name):\n            for nic in nics:\n                if nic['name'] == name:\n                    for ip in nic['addrs']:\n                        return netaddr.IPNetwork(ip['addr'])\n                    return\n"
u'1076,from zeroos.core0.client import Client\nfrom .Disk import Disks, DiskType\nfrom .Container import Containers\nfrom .StoragePool import StoragePools\nfrom .Network import Network\nfrom collections import namedtuple\nfrom datetime import datetime\nimport netaddr\n\nMount = namedtuple(\'Mount\', [\'device\', \'mountpoint\', \'fstype\', \'options\'])\n\n\nclass Node:\n    """Represent a G8OS Server"""\n\n    def __init__(self, addr, port=6379, password=None, timeout=120):\n        # g8os client to talk to the node\n        self._client = Client(host=addr, port=port, password=password, timeout=timeout)\n        self._storageAddr = None\n        self.addr = addr\n        self.port = port\n        self.disks = Disks(self)\n        self.storagepools = StoragePools(self)\n        self.containers = Containers(self)\n        self.network = Network(self)\n\n    @classmethod\n    def from_ays(cls, service, password=None, timeout=120):\n        return cls(\n            addr=service.model.data.redisAddr,\n            port=service.model.data.redisPort,\n            password=password,\n            timeout=timeout\n        )\n\n    @property\n    def client(self):\n        return self._client\n\n    @property\n    def name(self):\n        def get_nic_hwaddr(nics, name):\n            for nic in nics:\n                if nic[\'name\'] == name:\n                    return nic[\'hardwareaddr\']\n\n        defaultgwdev = self.client.bash("ip route | grep default | awk \'{print $5}\'").get().stdout.strip()\n        nics = self.client.info.nic()\n        if defaultgwdev:\n            macgwdev = get_nic_hwaddr(nics, defaultgwdev)\n        if not macgwdev:\n            raise AttributeError("name not find for node {}".format(self))\n        return macgwdev.replace(":", \'\')\n\n    @property\n    def storageAddr(self):\n        if not self._storageAddr:\n            nic_data = self.client.info.nic()\n            for nic in nic_data:\n                if nic[\'name\'] == \'backplane\':\n                    for ip in nic[\'addrs\']:\n                        network = netaddr.IPNetwork(ip[\'addr\'])\n                        if network.version == 4:\n                            self._storageAddr = network.ip.format()\n                            return self._storageAddr\n            self._storageAddr = self.addr\n        return self._storageAddr\n\n    def _eligible_fscache_disk(self, disks):\n        """\n        return the first disk that is eligible to be used as filesystem cache\n        First try to find a SSH disk, otherwise return a HDD\n        """\n        priorities = [DiskType.ssd, DiskType.hdd, DiskType.nvme]\n        eligible = {t: [] for t in priorities}\n        # Pick up the first ssd\n        usedisks = []\n        for pool in (self._client.btrfs.list() or []):\n            for device in pool[\'devices\']:\n                usedisks.append(device[\'path\'])\n        for disk in disks[::-1]:\n            if disk.devicename in usedisks or len(disk.partitions) > 0:\n                continue\n            if disk.type in priorities:\n                eligible[disk.type].append(disk)\n        # pick up the first disk according to priorities\n        for t in priorities:\n            if eligible[t]:\n                return eligible[t][0]\n        else:\n            raise RuntimeError("cannot find eligible disks for the fs cache")\n\n    def _mount_fscache(self, storagepool):\n        """\n        mount the fscache storage pool and copy the content of the in memmory fs inside\n        """\n        mountedpaths = [mount.mountpoint for mount in self.list_mounts()]\n        containerpath = \'/var/cache/containers\'\n        if containerpath not in mountedpaths:\n            if storagepool.exists(\'containercache\'):\n                storagepool.get(\'containercache\').delete()\n            fs = storagepool.create(\'containercache\')\n            self.client.disk.mount(storagepool.devicename, containerpath, [\'subvol={}\'.format(fs.subvolume)])\n        logpath = \'/var/log\'\n        if logpath not in mountedpaths:\n            # logs is empty filesystem which we create a snapshot on to store logs of current boot\n            snapname = \'{:%Y-%m-%d-%H-%M}\'.format(datetime.now())\n            fs = storagepool.get(\'logs\')\n            snapshot = fs.create(snapname)\n            self.client.bash(\'mkdir /tmp/log && mv /var/log/* /tmp/log/\')\n            self.client.disk.mount(storagepool.devicename, logpath, [\'subvol={}\'.format(snapshot.subvolume)])\n            self.client.bash(\'mv /tmp/log/* /var/log/\').get()\n            self.client.logger.reopen()\n            # startup syslogd and klogd\n            self.client.system(\'syslogd -n -O /var/log/messages\')\n            self.client.system(\'klogd -n\')\n\n    def freeports(self, baseport=2000, nrports=3):\n        ports = self.client.info.port()\n        usedports = set()\n        for portInfo in ports:\n            if portInfo[\'network\'] != "tcp":\n                continue\n            usedports.add(portInfo[\'port\'])\n\n        freeports = []\n        while True:\n            if baseport not in usedports:\n                freeports.append(baseport)\n                if len(freeports) >= nrports:\n                    return freeports\n            baseport += 1\n\n    def find_persistance(self, name=\'fscache\'):\n        fscache_sp = None\n        for sp in self.storagepools.list():\n            if sp.name == name:\n                fscache_sp = sp\n                break\n        return fscache_sp\n\n    def ensure_persistance(self, name=\'fscache\'):\n        """\n        look for a disk not used,\n        create a partition and mount it to be used as cache for the g8ufs\n        set the label `fs_cache` to the partition\n        """\n        disks = self.disks.list()\n        if len(disks) <= 0:\n            # if no disks, we can\'t do anything\n            return\n\n        # check if there is already a storage pool with the fs_cache label\n        fscache_sp = self.find_persistance(name)\n\n        # create the storage pool if we don\'t have one yet\n        if fscache_sp is None:\n            disk = self._eligible_fscache_disk(disks)\n            fscache_sp = self.storagepools.create(name, devices=[disk.devicename], metadata_profile=\'single\', data_profile=\'single\', overwrite=True)\n        fscache_sp.mount()\n        try:\n            fscache_sp.get(\'logs\')\n        except ValueError:\n            fscache_sp.create(\'logs\')\n\n        # mount the storage pool\n        self._mount_fscache(fscache_sp)\n        return fscache_sp\n\n    def wipedisks(self):\n        print(\'Wiping node {hostname}\'.format(**self.client.info.os()))\n        mounteddevices = {mount[\'device\']: mount for mount in self.client.info.disk()}\n\n        def getmountpoint(device):\n            for mounteddevice, mount in mounteddevices.items():\n                if mounteddevice.startswith(device):\n                    return mount\n\n        jobs = []\n        for disk in self.client.disk.list()[\'blockdevices\']:\n            devicename = \'/dev/{}\'.format(disk[\'kname\'])\n            mount = getmountpoint(devicename)\n            if not mount:\n                print(\'   * Wiping disk {kname}\'.format(**disk))\n                jobs.append(self.client.system(\'dd if=/dev/zero of={} bs=1M count=50\'.format(devicename)))\n            else:\n                print(\'   * Not wiping {device} mounted at {mountpoint}\'.format(device=devicename, mountpoint=mount[\'mountpoint\']))\n\n        # wait for wiping to complete\n        for job in jobs:\n            job.get()\n\n    def list_mounts(self):\n        allmounts = []\n        for mount in self.client.info.disk():\n            allmounts.append(Mount(mount[\'device\'],\n                                   mount[\'mountpoint\'],\n                                   mount[\'fstype\'],\n                                   mount[\'opts\']))\n        return allmounts\n\n    def __str__(self):\n        return "Node <{host}:{port}>".format(\n            host=self.addr,\n            port=self.port,\n        )\n\n    def __repr__(self):\n        return str(self)\n\n    def __eq__(self, other):\n        a = "{}:{}".format(self.addr, self.port)\n        b = "{}:{}".format(other.addr, other.port)\n        return a == b\n\n    def __hash__(self):\n        return hash((self.addr, self.port))\n'
u'1077,class Node:\n    """Represent a G8OS Server"""\n\n    def __init__(self, addr, port=6379, password=None, timeout=120):\n        # g8os client to talk to the node\n        self._client = Client(host=addr, port=port, password=password, timeout=timeout)\n        self._storageAddr = None\n        self.addr = addr\n        self.port = port\n        self.disks = Disks(self)\n        self.storagepools = StoragePools(self)\n        self.containers = Containers(self)\n        self.network = Network(self)\n\n    @classmethod\n    def from_ays(cls, service, password=None, timeout=120):\n        return cls(\n            addr=service.model.data.redisAddr,\n            port=service.model.data.redisPort,\n            password=password,\n            timeout=timeout\n        )\n\n    @property\n    def client(self):\n        return self._client\n\n    @property\n    def name(self):\n        def get_nic_hwaddr(nics, name):\n            for nic in nics:\n                if nic[\'name\'] == name:\n                    return nic[\'hardwareaddr\']\n\n        defaultgwdev = self.client.bash("ip route | grep default | awk \'{print $5}\'").get().stdout.strip()\n        nics = self.client.info.nic()\n        if defaultgwdev:\n            macgwdev = get_nic_hwaddr(nics, defaultgwdev)\n        if not macgwdev:\n            raise AttributeError("name not find for node {}".format(self))\n        return macgwdev.replace(":", \'\')\n\n    @property\n    def storageAddr(self):\n        if not self._storageAddr:\n            nic_data = self.client.info.nic()\n            for nic in nic_data:\n                if nic[\'name\'] == \'backplane\':\n                    for ip in nic[\'addrs\']:\n                        network = netaddr.IPNetwork(ip[\'addr\'])\n                        if network.version == 4:\n                            self._storageAddr = network.ip.format()\n                            return self._storageAddr\n            self._storageAddr = self.addr\n        return self._storageAddr\n\n    def _eligible_fscache_disk(self, disks):\n        """\n        return the first disk that is eligible to be used as filesystem cache\n        First try to find a SSH disk, otherwise return a HDD\n        """\n        priorities = [DiskType.ssd, DiskType.hdd, DiskType.nvme]\n        eligible = {t: [] for t in priorities}\n        # Pick up the first ssd\n        usedisks = []\n        for pool in (self._client.btrfs.list() or []):\n            for device in pool[\'devices\']:\n                usedisks.append(device[\'path\'])\n        for disk in disks[::-1]:\n            if disk.devicename in usedisks or len(disk.partitions) > 0:\n                continue\n            if disk.type in priorities:\n                eligible[disk.type].append(disk)\n        # pick up the first disk according to priorities\n        for t in priorities:\n            if eligible[t]:\n                return eligible[t][0]\n        else:\n            raise RuntimeError("cannot find eligible disks for the fs cache")\n\n    def _mount_fscache(self, storagepool):\n        """\n        mount the fscache storage pool and copy the content of the in memmory fs inside\n        """\n        mountedpaths = [mount.mountpoint for mount in self.list_mounts()]\n        containerpath = \'/var/cache/containers\'\n        if containerpath not in mountedpaths:\n            if storagepool.exists(\'containercache\'):\n                storagepool.get(\'containercache\').delete()\n            fs = storagepool.create(\'containercache\')\n            self.client.disk.mount(storagepool.devicename, containerpath, [\'subvol={}\'.format(fs.subvolume)])\n        logpath = \'/var/log\'\n        if logpath not in mountedpaths:\n            # logs is empty filesystem which we create a snapshot on to store logs of current boot\n            snapname = \'{:%Y-%m-%d-%H-%M}\'.format(datetime.now())\n            fs = storagepool.get(\'logs\')\n            snapshot = fs.create(snapname)\n            self.client.bash(\'mkdir /tmp/log && mv /var/log/* /tmp/log/\')\n            self.client.disk.mount(storagepool.devicename, logpath, [\'subvol={}\'.format(snapshot.subvolume)])\n            self.client.bash(\'mv /tmp/log/* /var/log/\').get()\n            self.client.logger.reopen()\n            # startup syslogd and klogd\n            self.client.system(\'syslogd -n -O /var/log/messages\')\n            self.client.system(\'klogd -n\')\n\n    def freeports(self, baseport=2000, nrports=3):\n        ports = self.client.info.port()\n        usedports = set()\n        for portInfo in ports:\n            if portInfo[\'network\'] != "tcp":\n                continue\n            usedports.add(portInfo[\'port\'])\n\n        freeports = []\n        while True:\n            if baseport not in usedports:\n                freeports.append(baseport)\n                if len(freeports) >= nrports:\n                    return freeports\n            baseport += 1\n\n    def find_persistance(self, name=\'fscache\'):\n        fscache_sp = None\n        for sp in self.storagepools.list():\n            if sp.name == name:\n                fscache_sp = sp\n                break\n        return fscache_sp\n\n    def ensure_persistance(self, name=\'fscache\'):\n        """\n        look for a disk not used,\n        create a partition and mount it to be used as cache for the g8ufs\n        set the label `fs_cache` to the partition\n        """\n        disks = self.disks.list()\n        if len(disks) <= 0:\n            # if no disks, we can\'t do anything\n            return\n\n        # check if there is already a storage pool with the fs_cache label\n        fscache_sp = self.find_persistance(name)\n\n        # create the storage pool if we don\'t have one yet\n        if fscache_sp is None:\n            disk = self._eligible_fscache_disk(disks)\n            fscache_sp = self.storagepools.create(name, devices=[disk.devicename], metadata_profile=\'single\', data_profile=\'single\', overwrite=True)\n        fscache_sp.mount()\n        try:\n            fscache_sp.get(\'logs\')\n        except ValueError:\n            fscache_sp.create(\'logs\')\n\n        # mount the storage pool\n        self._mount_fscache(fscache_sp)\n        return fscache_sp\n\n    def wipedisks(self):\n        print(\'Wiping node {hostname}\'.format(**self.client.info.os()))\n        mounteddevices = {mount[\'device\']: mount for mount in self.client.info.disk()}\n\n        def getmountpoint(device):\n            for mounteddevice, mount in mounteddevices.items():\n                if mounteddevice.startswith(device):\n                    return mount\n\n        jobs = []\n        for disk in self.client.disk.list()[\'blockdevices\']:\n            devicename = \'/dev/{}\'.format(disk[\'kname\'])\n            mount = getmountpoint(devicename)\n            if not mount:\n                print(\'   * Wiping disk {kname}\'.format(**disk))\n                jobs.append(self.client.system(\'dd if=/dev/zero of={} bs=1M count=50\'.format(devicename)))\n            else:\n                print(\'   * Not wiping {device} mounted at {mountpoint}\'.format(device=devicename, mountpoint=mount[\'mountpoint\']))\n\n        # wait for wiping to complete\n        for job in jobs:\n            job.get()\n\n    def list_mounts(self):\n        allmounts = []\n        for mount in self.client.info.disk():\n            allmounts.append(Mount(mount[\'device\'],\n                                   mount[\'mountpoint\'],\n                                   mount[\'fstype\'],\n                                   mount[\'opts\']))\n        return allmounts\n\n    def __str__(self):\n        return "Node <{host}:{port}>".format(\n            host=self.addr,\n            port=self.port,\n        )\n\n    def __repr__(self):\n        return str(self)\n\n    def __eq__(self, other):\n        a = "{}:{}".format(self.addr, self.port)\n        b = "{}:{}".format(other.addr, other.port)\n        return a == b\n\n    def __hash__(self):\n        return hash((self.addr, self.port))\n'
u'1078,    def __init__(self, addr, port=6379, password=None, timeout=120):\n        # g8os client to talk to the node\n        self._client = Client(host=addr, port=port, password=password, timeout=timeout)\n        self._storageAddr = None\n        self.addr = addr\n        self.port = port\n        self.disks = Disks(self)\n        self.storagepools = StoragePools(self)\n        self.containers = Containers(self)\n        self.network = Network(self)\n'
u'1079,    @classmethod\n    def from_ays(cls, service, password=None, timeout=120):\n        return cls(\n            addr=service.model.data.redisAddr,\n            port=service.model.data.redisPort,\n            password=password,\n            timeout=timeout\n        )\n'
u'1080,    @property\n    def client(self):\n        return self._client\n'
u'1081,    @property\n    def name(self):\n        def get_nic_hwaddr(nics, name):\n            for nic in nics:\n                if nic[\'name\'] == name:\n                    return nic[\'hardwareaddr\']\n\n        defaultgwdev = self.client.bash("ip route | grep default | awk \'{print $5}\'").get().stdout.strip()\n        nics = self.client.info.nic()\n        if defaultgwdev:\n            macgwdev = get_nic_hwaddr(nics, defaultgwdev)\n        if not macgwdev:\n            raise AttributeError("name not find for node {}".format(self))\n        return macgwdev.replace(":", \'\')\n'
u"1082,    @property\n    def storageAddr(self):\n        if not self._storageAddr:\n            nic_data = self.client.info.nic()\n            for nic in nic_data:\n                if nic['name'] == 'backplane':\n                    for ip in nic['addrs']:\n                        network = netaddr.IPNetwork(ip['addr'])\n                        if network.version == 4:\n                            self._storageAddr = network.ip.format()\n                            return self._storageAddr\n            self._storageAddr = self.addr\n        return self._storageAddr\n"
u'1083,    def _eligible_fscache_disk(self, disks):\n        """\n        return the first disk that is eligible to be used as filesystem cache\n        First try to find a SSH disk, otherwise return a HDD\n        """\n        priorities = [DiskType.ssd, DiskType.hdd, DiskType.nvme]\n        eligible = {t: [] for t in priorities}\n        # Pick up the first ssd\n        usedisks = []\n        for pool in (self._client.btrfs.list() or []):\n            for device in pool[\'devices\']:\n                usedisks.append(device[\'path\'])\n        for disk in disks[::-1]:\n            if disk.devicename in usedisks or len(disk.partitions) > 0:\n                continue\n            if disk.type in priorities:\n                eligible[disk.type].append(disk)\n        # pick up the first disk according to priorities\n        for t in priorities:\n            if eligible[t]:\n                return eligible[t][0]\n        else:\n            raise RuntimeError("cannot find eligible disks for the fs cache")\n'
u'1084,    def _mount_fscache(self, storagepool):\n        """\n        mount the fscache storage pool and copy the content of the in memmory fs inside\n        """\n        mountedpaths = [mount.mountpoint for mount in self.list_mounts()]\n        containerpath = \'/var/cache/containers\'\n        if containerpath not in mountedpaths:\n            if storagepool.exists(\'containercache\'):\n                storagepool.get(\'containercache\').delete()\n            fs = storagepool.create(\'containercache\')\n            self.client.disk.mount(storagepool.devicename, containerpath, [\'subvol={}\'.format(fs.subvolume)])\n        logpath = \'/var/log\'\n        if logpath not in mountedpaths:\n            # logs is empty filesystem which we create a snapshot on to store logs of current boot\n            snapname = \'{:%Y-%m-%d-%H-%M}\'.format(datetime.now())\n            fs = storagepool.get(\'logs\')\n            snapshot = fs.create(snapname)\n            self.client.bash(\'mkdir /tmp/log && mv /var/log/* /tmp/log/\')\n            self.client.disk.mount(storagepool.devicename, logpath, [\'subvol={}\'.format(snapshot.subvolume)])\n            self.client.bash(\'mv /tmp/log/* /var/log/\').get()\n            self.client.logger.reopen()\n            # startup syslogd and klogd\n            self.client.system(\'syslogd -n -O /var/log/messages\')\n            self.client.system(\'klogd -n\')\n'
u'1085,    def freeports(self, baseport=2000, nrports=3):\n        ports = self.client.info.port()\n        usedports = set()\n        for portInfo in ports:\n            if portInfo[\'network\'] != "tcp":\n                continue\n            usedports.add(portInfo[\'port\'])\n\n        freeports = []\n        while True:\n            if baseport not in usedports:\n                freeports.append(baseport)\n                if len(freeports) >= nrports:\n                    return freeports\n            baseport += 1\n'
u"1086,    def find_persistance(self, name='fscache'):\n        fscache_sp = None\n        for sp in self.storagepools.list():\n            if sp.name == name:\n                fscache_sp = sp\n                break\n        return fscache_sp\n"
u'1087,    def ensure_persistance(self, name=\'fscache\'):\n        """\n        look for a disk not used,\n        create a partition and mount it to be used as cache for the g8ufs\n        set the label `fs_cache` to the partition\n        """\n        disks = self.disks.list()\n        if len(disks) <= 0:\n            # if no disks, we can\'t do anything\n            return\n\n        # check if there is already a storage pool with the fs_cache label\n        fscache_sp = self.find_persistance(name)\n\n        # create the storage pool if we don\'t have one yet\n        if fscache_sp is None:\n            disk = self._eligible_fscache_disk(disks)\n            fscache_sp = self.storagepools.create(name, devices=[disk.devicename], metadata_profile=\'single\', data_profile=\'single\', overwrite=True)\n        fscache_sp.mount()\n        try:\n            fscache_sp.get(\'logs\')\n        except ValueError:\n            fscache_sp.create(\'logs\')\n\n        # mount the storage pool\n        self._mount_fscache(fscache_sp)\n        return fscache_sp\n'
u"1088,    def wipedisks(self):\n        print('Wiping node {hostname}'.format(**self.client.info.os()))\n        mounteddevices = {mount['device']: mount for mount in self.client.info.disk()}\n\n        def getmountpoint(device):\n            for mounteddevice, mount in mounteddevices.items():\n                if mounteddevice.startswith(device):\n                    return mount\n\n        jobs = []\n        for disk in self.client.disk.list()['blockdevices']:\n            devicename = '/dev/{}'.format(disk['kname'])\n            mount = getmountpoint(devicename)\n            if not mount:\n                print('   * Wiping disk {kname}'.format(**disk))\n                jobs.append(self.client.system('dd if=/dev/zero of={} bs=1M count=50'.format(devicename)))\n            else:\n                print('   * Not wiping {device} mounted at {mountpoint}'.format(device=devicename, mountpoint=mount['mountpoint']))\n\n        # wait for wiping to complete\n        for job in jobs:\n            job.get()\n"
u"1089,    def list_mounts(self):\n        allmounts = []\n        for mount in self.client.info.disk():\n            allmounts.append(Mount(mount['device'],\n                                   mount['mountpoint'],\n                                   mount['fstype'],\n                                   mount['opts']))\n        return allmounts\n"
u'1090,    def __str__(self):\n        return "Node <{host}:{port}>".format(\n            host=self.addr,\n            port=self.port,\n        )\n'
u'1091,    def __repr__(self):\n        return str(self)\n'
u'1092,    def __eq__(self, other):\n        a = "{}:{}".format(self.addr, self.port)\n        b = "{}:{}".format(other.addr, other.port)\n        return a == b\n'
u'1093,    def __hash__(self):\n        return hash((self.addr, self.port))\n'
u"1094,        def get_nic_hwaddr(nics, name):\n            for nic in nics:\n                if nic['name'] == name:\n                    return nic['hardwareaddr']\n"
u'1095,        def getmountpoint(device):\n            for mounteddevice, mount in mounteddevices.items():\n                if mounteddevice.startswith(device):\n                    return mount\n'
u'1096,from .abstracts import Mountable\n\n\nclass Partition(Mountable):\n    """Partition of a disk in a G8OS"""\n\n    def __init__(self, disk, part_info):\n        """\n        part_info: dict returned by client.disk.list()\n        """\n        # g8os client to talk to the node\n        self.disk = disk\n        self._client = disk.node.client\n        self.name = None\n        self.size = None\n        self.blocksize = None\n        self.mountpoint = None\n        self.uuid = None\n        self._filesystems = []\n\n        self._load(part_info)\n\n    @property\n    def filesystems(self):\n        self._populate_filesystems()\n        return self._filesystems\n\n    @property\n    def devicename(self):\n        return "/dev/{}".format(self.name)\n\n    def _load(self, part_info):\n        self.name = part_info[\'name\']\n        self.size = int(part_info[\'size\'])\n        self.blocksize = self.disk.blocksize\n        self.mountpoint = part_info[\'mountpoint\']\n        self.uuid = part_info[\'partuuid\']\n\n    def _populate_filesystems(self):\n        """\n        look into all the btrfs filesystem and populate\n        the filesystems attribute of the class with the detail of\n        all the filesystem present on the disk\n        """\n        self._filesystems = []\n        for fs in (self._client.btrfs.list() or []):\n            for device in fs[\'devices\']:\n                if device[\'path\'] == "/dev/{}".format(self.name):\n                    self._filesystems.append(fs)\n                    break\n\n    def __str__(self):\n        return "Partition <{}>".format(self.name)\n\n    def __repr__(self):\n        return str(self)\n'
u'1097,class Partition(Mountable):\n    """Partition of a disk in a G8OS"""\n\n    def __init__(self, disk, part_info):\n        """\n        part_info: dict returned by client.disk.list()\n        """\n        # g8os client to talk to the node\n        self.disk = disk\n        self._client = disk.node.client\n        self.name = None\n        self.size = None\n        self.blocksize = None\n        self.mountpoint = None\n        self.uuid = None\n        self._filesystems = []\n\n        self._load(part_info)\n\n    @property\n    def filesystems(self):\n        self._populate_filesystems()\n        return self._filesystems\n\n    @property\n    def devicename(self):\n        return "/dev/{}".format(self.name)\n\n    def _load(self, part_info):\n        self.name = part_info[\'name\']\n        self.size = int(part_info[\'size\'])\n        self.blocksize = self.disk.blocksize\n        self.mountpoint = part_info[\'mountpoint\']\n        self.uuid = part_info[\'partuuid\']\n\n    def _populate_filesystems(self):\n        """\n        look into all the btrfs filesystem and populate\n        the filesystems attribute of the class with the detail of\n        all the filesystem present on the disk\n        """\n        self._filesystems = []\n        for fs in (self._client.btrfs.list() or []):\n            for device in fs[\'devices\']:\n                if device[\'path\'] == "/dev/{}".format(self.name):\n                    self._filesystems.append(fs)\n                    break\n\n    def __str__(self):\n        return "Partition <{}>".format(self.name)\n\n    def __repr__(self):\n        return str(self)\n'
u'1098,    def __init__(self, disk, part_info):\n        """\n        part_info: dict returned by client.disk.list()\n        """\n        # g8os client to talk to the node\n        self.disk = disk\n        self._client = disk.node.client\n        self.name = None\n        self.size = None\n        self.blocksize = None\n        self.mountpoint = None\n        self.uuid = None\n        self._filesystems = []\n\n        self._load(part_info)\n'
u'1099,    @property\n    def filesystems(self):\n        self._populate_filesystems()\n        return self._filesystems\n'
u'1100,    @property\n    def devicename(self):\n        return "/dev/{}".format(self.name)\n'
u"1101,    def _load(self, part_info):\n        self.name = part_info['name']\n        self.size = int(part_info['size'])\n        self.blocksize = self.disk.blocksize\n        self.mountpoint = part_info['mountpoint']\n        self.uuid = part_info['partuuid']\n"
u'1102,    def _populate_filesystems(self):\n        """\n        look into all the btrfs filesystem and populate\n        the filesystems attribute of the class with the detail of\n        all the filesystem present on the disk\n        """\n        self._filesystems = []\n        for fs in (self._client.btrfs.list() or []):\n            for device in fs[\'devices\']:\n                if device[\'path\'] == "/dev/{}".format(self.name):\n                    self._filesystems.append(fs)\n                    break\n'
u'1103,    def __str__(self):\n        return "Partition <{}>".format(self.name)\n'
u'1104,    def __repr__(self):\n        return str(self)\n'
u'1105,import json\n\nfrom js9 import j\nfrom .StorageEngine import StorageEngine\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass StorageCluster:\n    """StorageCluster is a cluster of StorageEngine servers"""\n\n    def __init__(self, label, nodes=None, disk_type=None):\n        """\n        @param label: string repsenting the name of the storage cluster\n        """\n        self.label = label\n        self.name = label\n        self.nodes = nodes or []\n        self.filesystems = []\n        self.storage_servers = []\n        self.disk_type = disk_type\n        self.k = 0\n        self.m = 0\n        self._ays = None\n\n    @classmethod\n    def from_ays(cls, service, password):\n        logger.debug("load cluster storage cluster from service (%s)", service)\n        disk_type = str(service.model.data.diskType)\n\n        nodes = []\n        storage_servers = []\n        for storageEngine_service in service.producers.get(\'storage_engine\', []):\n            storages_server = StorageServer.from_ays(storageEngine_service, password)\n            storage_servers.append(storages_server)\n            if storages_server.node not in nodes:\n                nodes.append(storages_server.node)\n\n        cluster = cls(label=service.name, nodes=nodes, disk_type=disk_type)\n        cluster.storage_servers = storage_servers\n        cluster.k = service.model.data.k\n        cluster.m = service.model.data.m\n        return cluster\n\n    @property\n    def dashboard(self):\n        board = StorageDashboard(self)\n        return board.template\n\n    def get_config(self):\n        data = {\'dataStorage\': [],\n                \'metadataStorage\': None,\n                \'label\': self.name,\n                \'status\': \'ready\' if self.is_running() else \'error\',\n                \'nodes\': [node.name for node in self.nodes]}\n        for storageserver in self.storage_servers:\n            if \'metadata\' in storageserver.name:\n                data[\'metadataStorage\'] = {\'address\': storageserver.storageEngine.bind}\n            else:\n                data[\'dataStorage\'].append({\'address\': storageserver.storageEngine.bind})\n        return data\n\n    @property\n    def nr_server(self):\n        """\n        Number of storage server part of this cluster\n        """\n        return len(self.storage_servers)\n\n    def find_disks(self):\n        """\n        return a list of disk that are not used by storage pool\n        or has a different type as the one required for this cluster\n        """\n        logger.debug("find available_disks")\n        cluster_name = \'sp_cluster_{}\'.format(self.label)\n        available_disks = {}\n\n        def check_partition(disk):\n            for partition in disk.partitions:\n                for filesystem in partition.filesystems:\n                    if filesystem[\'label\'].startswith(cluster_name):\n                        return True\n\n        for node in self.nodes:\n            for disk in node.disks.list():\n                # skip disks of wrong type\n                if disk.type.name != self.disk_type:\n                    continue\n                # skip devices which have filesystems on the device\n                if len(disk.filesystems) > 0:\n                    continue\n\n                # include devices which have partitions\n                if len(disk.partitions) == 0:\n                    available_disks.setdefault(node.name, []).append(disk)\n                else:\n                    if check_partition(disk):\n                        # devices that have partitions with correct label will be in the beginning\n                        available_disks.setdefault(node.name, []).insert(0, disk)\n        return available_disks\n\n    def start(self):\n        logger.debug("start %s", self)\n        for server in self.storage_servers:\n            server.start()\n\n    def stop(self):\n        logger.debug("stop %s", self)\n        for server in self.storage_servers:\n            server.stop()\n\n    def is_running(self):\n        # TODO: Improve this, what about part of server running and part stopped\n        for server in self.storage_servers:\n            if not server.is_running():\n                return False\n        return True\n\n    def health(self):\n        """\n        Return a view of the state all storage server running in this cluster\n        example :\n        {\n        \'cluster1_1\': {\'storageEngine\': True, \'container\': True},\n        \'cluster1_2\': {\'storageEngine\': True, \'container\': True},\n        }\n        """\n        health = {}\n        for server in self.storage_servers:\n            running, _ = server.storageEngine.is_running()\n            health[server.name] = {\n                \'storageEngine\': running,\n                \'container\': server.container.is_running(),\n            }\n        return health\n\n    def __str__(self):\n        return "StorageCluster <{}>".format(self.label)\n\n    def __repr__(self):\n        return str(self)\n\n\nclass StorageServer:\n    """StorageEngine servers"""\n\n    def __init__(self, cluster):\n        self.cluster = cluster\n        self.container = None\n        self.storageEngine = None\n\n    @classmethod\n    def from_ays(cls, storageEngine_services, password=None):\n        storageEngine = StorageEngine.from_ays(storageEngine_services, password)\n        storage_server = cls(None)\n        storage_server.container = storageEngine.container\n        storage_server.storageEngine = storageEngine\n        return storage_server\n\n    @property\n    def name(self):\n        if self.storageEngine:\n            return self.storageEngine.name\n        return None\n\n    @property\n    def node(self):\n        if self.container:\n            return self.container.node\n        return None\n\n    def _find_port(self, start_port=2000):\n        while True:\n            if j.sal.nettools.tcpPortConnectionTest(self.node.addr, start_port, timeout=2):\n                start_port += 1\n                continue\n            return start_port\n\n    def start(self, timeout=30):\n        logger.debug("start %s", self)\n        if not self.container.is_running():\n            self.container.start()\n\n        ip, port = self.storageEngine.bind.split(":")\n        self.storageEngine.bind = \'{}:{}\'.format(ip, self._find_port(port))\n        self.storageEngine.start(timeout=timeout)\n\n    def stop(self, timeout=30):\n        logger.debug("stop %s", self)\n        self.storageEngine.stop(timeout=timeout)\n        self.container.stop()\n\n    def is_running(self):\n        container = self.container.is_running()\n        storageEngine, _ = self.storageEngine.is_running()\n        return (container and storageEngine)\n\n    def __str__(self):\n        return "StorageServer <{}>".format(self.container.name)\n\n    def __repr__(self):\n        return str(self)\n\n\nclass StorageDashboard:\n    def __init__(self, cluster):\n        self.cluster = cluster\n        self.store = \'statsdb\'\n\n    def build_templating(self):\n        templating = {\n            "list": [],\n            "rows": []\n        }\n        return templating\n\n    def dashboard_template(self):\n        return {\n            "annotations": {\n                "list": []\n            },\n            "editable": True,\n            "gnetId": None,\n            "graphTooltip": 0,\n            "hideControls": False,\n            "id": None,\n            "links": [],\n            "rows": [],\n            "schemaVersion": 14,\n            "style": "dark",\n            "tags": [],\n            "time": {\n                "from": "now/d",\n                "to": "now"\n            },\n            "timepicker": {\n                "refresh_intervals": [\n                    "5s",\n                    "10s",\n                    "30s",\n                    "1m",\n                    "5m",\n                    "15m",\n                    "30m",\n                    "1h",\n                    "2h",\n                    "1d"\n                ],\n                "time_options": [\n                    "5m",\n                    "15m",\n                    "1h",\n                    "6h",\n                    "12h",\n                    "24h",\n                    "2d",\n                    "7d",\n                    "30d"\n                ]\n            },\n            "timezone": "",\n            "title": self.cluster.name,\n            "version": 8\n        }\n\n    def build_row(self, panel):\n        template = {\n            "collapse": False,\n            "height": 295,\n            "panels": [],\n            "repeat": None,\n            "repeatIteration": None,\n            "repeatRowId": None,\n            "showTitle": False,\n            "title": "Dashboard Row",\n            "titleSize": "h6"\n        }\n        template["panels"] += panel\n        return template\n\n    def build_panel(self, title, target, panel_id, unit):\n        template = {\n            "aliasColors": {},\n            "bars": False,\n            "dashLength": 10,\n            "dashes": False,\n            "datasource": self.store,\n            "fill": 1,\n            "id": panel_id,\n            "legend": {\n                "avg": False,\n                "current": False,\n                "max": False,\n                "min": False,\n                "show": True,\n                "total": False,\n                "values": False\n            },\n            "lines": True,\n            "linewidth": 1,\n            "links": [],\n            "nullPointMode": "null",\n            "percentage": False,\n            "pointradius": 5,\n            "points": False,\n            "renderer": "flot",\n            "seriesOverrides": [],\n            "spaceLength": 10,\n            "span": 6,\n            "stack": True,\n            "steppedLine": False,\n            "targets": [],\n            "thresholds": [],\n            "timeFrom": None,\n            "timeShift": None,\n            "tooltip": {\n                "shared": True,\n                "sort": 0,\n                "value_type": "individual"\n            },\n            "type": "graph",\n            "xaxis": {\n                "buckets": None,\n                "mode": "time",\n                "name": None,\n                "show": True,\n                "values": []\n            },\n            "yaxes": [\n                {\n                    "format": unit,\n                    "label": None,\n                    "logBase": 1,\n                    "max": None,\n                    "min": None,\n                    "show": True\n                },\n                {\n                    "format": "short",\n                    "label": None,\n                    "logBase": 1,\n                    "max": None,\n                    "min": None,\n                    "show": True\n                }\n            ]\n        }\n        template["title"] = title\n        template["targets"].append(target)\n        return template\n\n    def build_target(self, measurement, disks):\n        template = {\n            "alias": "$tag_node/$tag_id",\n            "dsType": "influxdb",\n            "groupBy": [\n                {\n                    "params": [\n                        "$__interval"\n                    ],\n                    "type": "time"\n                },\n                {\n                    "params": [\n                        "node"\n                    ],\n                    "type": "tag"\n                },\n                {\n                    "params": [\n                        "id"\n                    ],\n                    "type": "tag"\n                },\n                {\n                    "params": [\n                        "none"\n                    ],\n                    "type": "fill"\n                }\n            ],\n            "orderByTime": "ASC",\n            "policy": "default",\n            "rawQuery": False,\n            "refId": "A",\n            "resultFormat": "time_series",\n            "select": [\n                [\n                    {\n                        "params": [\n                            "value"\n                        ],\n                        "type": "field"\n                    },\n                    {\n                        "params": [],\n                        "type": "mean"\n                    }\n                ]\n            ],\n            "tags": [\n                {\n                    "key": "type",\n                    "operator": "=",\n                    "value": "phys"\n                }\n            ]\n        }\n        template["measurement"] = measurement\n\n        for idx, disk in enumerate(disks):\n            tag = [\n                {\n                    "key": "node",\n                    "operator": "=",\n                    "value": disk.split("_")[0]\n                },\n                {\n                    "condition": "AND",\n                    "key": "id",\n                    "operator": "=",\n                    "value": disk.split("_")[1]\n                }\n            ]\n            if idx == 0:\n                tag[0]["condition"] = "AND"\n            else:\n                tag[0]["condition"] = "OR"\n            template["tags"] += tag\n        return template\n\n    @property\n    def template(self):\n        AGGREGATED_CONFIG = {\n            "Aggregated read IOPs": "disk.iops.read|m",\n            "Aggregated write IOPs": "disk.iops.write|m",\n            "Aggregated free size": "disk.size.free|m",\n        }\n        panel_id = 1\n        disks = set()\n        for server in self.cluster.storage_servers:\n            server = server.name.split("_")\n            disks.add("{}_{}".format(server[1], server[-3]))\n        disks = list(disks)\n        panels = []\n        for title, measurement in AGGREGATED_CONFIG.items():\n            if \'size\' in title:\n                partitions = [disk+\'1\' for disk in disks]\n                target = self.build_target(measurement, partitions)\n                panels.append(self.build_panel(title, target, panel_id, "decbytes"))\n            else:\n                target = self.build_target(measurement, disks)\n                panels.append(self.build_panel(title, target, panel_id, "iops"))\n            panel_id += 1\n\n        for disk in disks:\n            target = self.build_target("disk.iops.read|m", [disk])\n            panels.append(self.build_panel("Read IOPs", target, panel_id, "iops"))\n            panel_id += 1\n            target = self.build_target("disk.iops.write|m", [disk])\n            panels.append(self.build_panel("Write IOPs", target, panel_id, "iops"))\n            panel_id += 1\n            target = self.build_target("disk.size.free|m", [disk+\'1\'])\n            panels.append(self.build_panel("Free size", target, panel_id, "decbytes"))\n            panel_id += 1\n\n        template = self.dashboard_template()\n        for idx, panel in enumerate(panels):\n            if idx % 2 == 0:\n                row = self.build_row(panels[idx:idx+2])\n                template["rows"].append(row)\n        template = json.dumps(template)\n        return template\n'
u'1106,class StorageCluster:\n    """StorageCluster is a cluster of StorageEngine servers"""\n\n    def __init__(self, label, nodes=None, disk_type=None):\n        """\n        @param label: string repsenting the name of the storage cluster\n        """\n        self.label = label\n        self.name = label\n        self.nodes = nodes or []\n        self.filesystems = []\n        self.storage_servers = []\n        self.disk_type = disk_type\n        self.k = 0\n        self.m = 0\n        self._ays = None\n\n    @classmethod\n    def from_ays(cls, service, password):\n        logger.debug("load cluster storage cluster from service (%s)", service)\n        disk_type = str(service.model.data.diskType)\n\n        nodes = []\n        storage_servers = []\n        for storageEngine_service in service.producers.get(\'storage_engine\', []):\n            storages_server = StorageServer.from_ays(storageEngine_service, password)\n            storage_servers.append(storages_server)\n            if storages_server.node not in nodes:\n                nodes.append(storages_server.node)\n\n        cluster = cls(label=service.name, nodes=nodes, disk_type=disk_type)\n        cluster.storage_servers = storage_servers\n        cluster.k = service.model.data.k\n        cluster.m = service.model.data.m\n        return cluster\n\n    @property\n    def dashboard(self):\n        board = StorageDashboard(self)\n        return board.template\n\n    def get_config(self):\n        data = {\'dataStorage\': [],\n                \'metadataStorage\': None,\n                \'label\': self.name,\n                \'status\': \'ready\' if self.is_running() else \'error\',\n                \'nodes\': [node.name for node in self.nodes]}\n        for storageserver in self.storage_servers:\n            if \'metadata\' in storageserver.name:\n                data[\'metadataStorage\'] = {\'address\': storageserver.storageEngine.bind}\n            else:\n                data[\'dataStorage\'].append({\'address\': storageserver.storageEngine.bind})\n        return data\n\n    @property\n    def nr_server(self):\n        """\n        Number of storage server part of this cluster\n        """\n        return len(self.storage_servers)\n\n    def find_disks(self):\n        """\n        return a list of disk that are not used by storage pool\n        or has a different type as the one required for this cluster\n        """\n        logger.debug("find available_disks")\n        cluster_name = \'sp_cluster_{}\'.format(self.label)\n        available_disks = {}\n\n        def check_partition(disk):\n            for partition in disk.partitions:\n                for filesystem in partition.filesystems:\n                    if filesystem[\'label\'].startswith(cluster_name):\n                        return True\n\n        for node in self.nodes:\n            for disk in node.disks.list():\n                # skip disks of wrong type\n                if disk.type.name != self.disk_type:\n                    continue\n                # skip devices which have filesystems on the device\n                if len(disk.filesystems) > 0:\n                    continue\n\n                # include devices which have partitions\n                if len(disk.partitions) == 0:\n                    available_disks.setdefault(node.name, []).append(disk)\n                else:\n                    if check_partition(disk):\n                        # devices that have partitions with correct label will be in the beginning\n                        available_disks.setdefault(node.name, []).insert(0, disk)\n        return available_disks\n\n    def start(self):\n        logger.debug("start %s", self)\n        for server in self.storage_servers:\n            server.start()\n\n    def stop(self):\n        logger.debug("stop %s", self)\n        for server in self.storage_servers:\n            server.stop()\n\n    def is_running(self):\n        # TODO: Improve this, what about part of server running and part stopped\n        for server in self.storage_servers:\n            if not server.is_running():\n                return False\n        return True\n\n    def health(self):\n        """\n        Return a view of the state all storage server running in this cluster\n        example :\n        {\n        \'cluster1_1\': {\'storageEngine\': True, \'container\': True},\n        \'cluster1_2\': {\'storageEngine\': True, \'container\': True},\n        }\n        """\n        health = {}\n        for server in self.storage_servers:\n            running, _ = server.storageEngine.is_running()\n            health[server.name] = {\n                \'storageEngine\': running,\n                \'container\': server.container.is_running(),\n            }\n        return health\n\n    def __str__(self):\n        return "StorageCluster <{}>".format(self.label)\n\n    def __repr__(self):\n        return str(self)\n'
u'1107,class StorageServer:\n    """StorageEngine servers"""\n\n    def __init__(self, cluster):\n        self.cluster = cluster\n        self.container = None\n        self.storageEngine = None\n\n    @classmethod\n    def from_ays(cls, storageEngine_services, password=None):\n        storageEngine = StorageEngine.from_ays(storageEngine_services, password)\n        storage_server = cls(None)\n        storage_server.container = storageEngine.container\n        storage_server.storageEngine = storageEngine\n        return storage_server\n\n    @property\n    def name(self):\n        if self.storageEngine:\n            return self.storageEngine.name\n        return None\n\n    @property\n    def node(self):\n        if self.container:\n            return self.container.node\n        return None\n\n    def _find_port(self, start_port=2000):\n        while True:\n            if j.sal.nettools.tcpPortConnectionTest(self.node.addr, start_port, timeout=2):\n                start_port += 1\n                continue\n            return start_port\n\n    def start(self, timeout=30):\n        logger.debug("start %s", self)\n        if not self.container.is_running():\n            self.container.start()\n\n        ip, port = self.storageEngine.bind.split(":")\n        self.storageEngine.bind = \'{}:{}\'.format(ip, self._find_port(port))\n        self.storageEngine.start(timeout=timeout)\n\n    def stop(self, timeout=30):\n        logger.debug("stop %s", self)\n        self.storageEngine.stop(timeout=timeout)\n        self.container.stop()\n\n    def is_running(self):\n        container = self.container.is_running()\n        storageEngine, _ = self.storageEngine.is_running()\n        return (container and storageEngine)\n\n    def __str__(self):\n        return "StorageServer <{}>".format(self.container.name)\n\n    def __repr__(self):\n        return str(self)\n'
u'1108,class StorageDashboard:\n    def __init__(self, cluster):\n        self.cluster = cluster\n        self.store = \'statsdb\'\n\n    def build_templating(self):\n        templating = {\n            "list": [],\n            "rows": []\n        }\n        return templating\n\n    def dashboard_template(self):\n        return {\n            "annotations": {\n                "list": []\n            },\n            "editable": True,\n            "gnetId": None,\n            "graphTooltip": 0,\n            "hideControls": False,\n            "id": None,\n            "links": [],\n            "rows": [],\n            "schemaVersion": 14,\n            "style": "dark",\n            "tags": [],\n            "time": {\n                "from": "now/d",\n                "to": "now"\n            },\n            "timepicker": {\n                "refresh_intervals": [\n                    "5s",\n                    "10s",\n                    "30s",\n                    "1m",\n                    "5m",\n                    "15m",\n                    "30m",\n                    "1h",\n                    "2h",\n                    "1d"\n                ],\n                "time_options": [\n                    "5m",\n                    "15m",\n                    "1h",\n                    "6h",\n                    "12h",\n                    "24h",\n                    "2d",\n                    "7d",\n                    "30d"\n                ]\n            },\n            "timezone": "",\n            "title": self.cluster.name,\n            "version": 8\n        }\n\n    def build_row(self, panel):\n        template = {\n            "collapse": False,\n            "height": 295,\n            "panels": [],\n            "repeat": None,\n            "repeatIteration": None,\n            "repeatRowId": None,\n            "showTitle": False,\n            "title": "Dashboard Row",\n            "titleSize": "h6"\n        }\n        template["panels"] += panel\n        return template\n\n    def build_panel(self, title, target, panel_id, unit):\n        template = {\n            "aliasColors": {},\n            "bars": False,\n            "dashLength": 10,\n            "dashes": False,\n            "datasource": self.store,\n            "fill": 1,\n            "id": panel_id,\n            "legend": {\n                "avg": False,\n                "current": False,\n                "max": False,\n                "min": False,\n                "show": True,\n                "total": False,\n                "values": False\n            },\n            "lines": True,\n            "linewidth": 1,\n            "links": [],\n            "nullPointMode": "null",\n            "percentage": False,\n            "pointradius": 5,\n            "points": False,\n            "renderer": "flot",\n            "seriesOverrides": [],\n            "spaceLength": 10,\n            "span": 6,\n            "stack": True,\n            "steppedLine": False,\n            "targets": [],\n            "thresholds": [],\n            "timeFrom": None,\n            "timeShift": None,\n            "tooltip": {\n                "shared": True,\n                "sort": 0,\n                "value_type": "individual"\n            },\n            "type": "graph",\n            "xaxis": {\n                "buckets": None,\n                "mode": "time",\n                "name": None,\n                "show": True,\n                "values": []\n            },\n            "yaxes": [\n                {\n                    "format": unit,\n                    "label": None,\n                    "logBase": 1,\n                    "max": None,\n                    "min": None,\n                    "show": True\n                },\n                {\n                    "format": "short",\n                    "label": None,\n                    "logBase": 1,\n                    "max": None,\n                    "min": None,\n                    "show": True\n                }\n            ]\n        }\n        template["title"] = title\n        template["targets"].append(target)\n        return template\n\n    def build_target(self, measurement, disks):\n        template = {\n            "alias": "$tag_node/$tag_id",\n            "dsType": "influxdb",\n            "groupBy": [\n                {\n                    "params": [\n                        "$__interval"\n                    ],\n                    "type": "time"\n                },\n                {\n                    "params": [\n                        "node"\n                    ],\n                    "type": "tag"\n                },\n                {\n                    "params": [\n                        "id"\n                    ],\n                    "type": "tag"\n                },\n                {\n                    "params": [\n                        "none"\n                    ],\n                    "type": "fill"\n                }\n            ],\n            "orderByTime": "ASC",\n            "policy": "default",\n            "rawQuery": False,\n            "refId": "A",\n            "resultFormat": "time_series",\n            "select": [\n                [\n                    {\n                        "params": [\n                            "value"\n                        ],\n                        "type": "field"\n                    },\n                    {\n                        "params": [],\n                        "type": "mean"\n                    }\n                ]\n            ],\n            "tags": [\n                {\n                    "key": "type",\n                    "operator": "=",\n                    "value": "phys"\n                }\n            ]\n        }\n        template["measurement"] = measurement\n\n        for idx, disk in enumerate(disks):\n            tag = [\n                {\n                    "key": "node",\n                    "operator": "=",\n                    "value": disk.split("_")[0]\n                },\n                {\n                    "condition": "AND",\n                    "key": "id",\n                    "operator": "=",\n                    "value": disk.split("_")[1]\n                }\n            ]\n            if idx == 0:\n                tag[0]["condition"] = "AND"\n            else:\n                tag[0]["condition"] = "OR"\n            template["tags"] += tag\n        return template\n\n    @property\n    def template(self):\n        AGGREGATED_CONFIG = {\n            "Aggregated read IOPs": "disk.iops.read|m",\n            "Aggregated write IOPs": "disk.iops.write|m",\n            "Aggregated free size": "disk.size.free|m",\n        }\n        panel_id = 1\n        disks = set()\n        for server in self.cluster.storage_servers:\n            server = server.name.split("_")\n            disks.add("{}_{}".format(server[1], server[-3]))\n        disks = list(disks)\n        panels = []\n        for title, measurement in AGGREGATED_CONFIG.items():\n            if \'size\' in title:\n                partitions = [disk+\'1\' for disk in disks]\n                target = self.build_target(measurement, partitions)\n                panels.append(self.build_panel(title, target, panel_id, "decbytes"))\n            else:\n                target = self.build_target(measurement, disks)\n                panels.append(self.build_panel(title, target, panel_id, "iops"))\n            panel_id += 1\n\n        for disk in disks:\n            target = self.build_target("disk.iops.read|m", [disk])\n            panels.append(self.build_panel("Read IOPs", target, panel_id, "iops"))\n            panel_id += 1\n            target = self.build_target("disk.iops.write|m", [disk])\n            panels.append(self.build_panel("Write IOPs", target, panel_id, "iops"))\n            panel_id += 1\n            target = self.build_target("disk.size.free|m", [disk+\'1\'])\n            panels.append(self.build_panel("Free size", target, panel_id, "decbytes"))\n            panel_id += 1\n\n        template = self.dashboard_template()\n        for idx, panel in enumerate(panels):\n            if idx % 2 == 0:\n                row = self.build_row(panels[idx:idx+2])\n                template["rows"].append(row)\n        template = json.dumps(template)\n        return template\n'
u'1109,    def __init__(self, label, nodes=None, disk_type=None):\n        """\n        @param label: string repsenting the name of the storage cluster\n        """\n        self.label = label\n        self.name = label\n        self.nodes = nodes or []\n        self.filesystems = []\n        self.storage_servers = []\n        self.disk_type = disk_type\n        self.k = 0\n        self.m = 0\n        self._ays = None\n'
u'1110,    @classmethod\n    def from_ays(cls, service, password):\n        logger.debug("load cluster storage cluster from service (%s)", service)\n        disk_type = str(service.model.data.diskType)\n\n        nodes = []\n        storage_servers = []\n        for storageEngine_service in service.producers.get(\'storage_engine\', []):\n            storages_server = StorageServer.from_ays(storageEngine_service, password)\n            storage_servers.append(storages_server)\n            if storages_server.node not in nodes:\n                nodes.append(storages_server.node)\n\n        cluster = cls(label=service.name, nodes=nodes, disk_type=disk_type)\n        cluster.storage_servers = storage_servers\n        cluster.k = service.model.data.k\n        cluster.m = service.model.data.m\n        return cluster\n'
u'1111,    @property\n    def dashboard(self):\n        board = StorageDashboard(self)\n        return board.template\n'
u"1112,    def get_config(self):\n        data = {'dataStorage': [],\n                'metadataStorage': None,\n                'label': self.name,\n                'status': 'ready' if self.is_running() else 'error',\n                'nodes': [node.name for node in self.nodes]}\n        for storageserver in self.storage_servers:\n            if 'metadata' in storageserver.name:\n                data['metadataStorage'] = {'address': storageserver.storageEngine.bind}\n            else:\n                data['dataStorage'].append({'address': storageserver.storageEngine.bind})\n        return data\n"
u'1113,    @property\n    def nr_server(self):\n        """\n        Number of storage server part of this cluster\n        """\n        return len(self.storage_servers)\n'
u'1114,    def find_disks(self):\n        """\n        return a list of disk that are not used by storage pool\n        or has a different type as the one required for this cluster\n        """\n        logger.debug("find available_disks")\n        cluster_name = \'sp_cluster_{}\'.format(self.label)\n        available_disks = {}\n\n        def check_partition(disk):\n            for partition in disk.partitions:\n                for filesystem in partition.filesystems:\n                    if filesystem[\'label\'].startswith(cluster_name):\n                        return True\n\n        for node in self.nodes:\n            for disk in node.disks.list():\n                # skip disks of wrong type\n                if disk.type.name != self.disk_type:\n                    continue\n                # skip devices which have filesystems on the device\n                if len(disk.filesystems) > 0:\n                    continue\n\n                # include devices which have partitions\n                if len(disk.partitions) == 0:\n                    available_disks.setdefault(node.name, []).append(disk)\n                else:\n                    if check_partition(disk):\n                        # devices that have partitions with correct label will be in the beginning\n                        available_disks.setdefault(node.name, []).insert(0, disk)\n        return available_disks\n'
u'1115,    def start(self):\n        logger.debug("start %s", self)\n        for server in self.storage_servers:\n            server.start()\n'
u'1116,    def stop(self):\n        logger.debug("stop %s", self)\n        for server in self.storage_servers:\n            server.stop()\n'
u'1117,    def is_running(self):\n        # TODO: Improve this, what about part of server running and part stopped\n        for server in self.storage_servers:\n            if not server.is_running():\n                return False\n        return True\n'
u'1118,    def health(self):\n        """\n        Return a view of the state all storage server running in this cluster\n        example :\n        {\n        \'cluster1_1\': {\'storageEngine\': True, \'container\': True},\n        \'cluster1_2\': {\'storageEngine\': True, \'container\': True},\n        }\n        """\n        health = {}\n        for server in self.storage_servers:\n            running, _ = server.storageEngine.is_running()\n            health[server.name] = {\n                \'storageEngine\': running,\n                \'container\': server.container.is_running(),\n            }\n        return health\n'
u'1119,    def __str__(self):\n        return "StorageCluster <{}>".format(self.label)\n'
u'1120,    def __repr__(self):\n        return str(self)\n'
u'1121,    def __init__(self, cluster):\n        self.cluster = cluster\n        self.container = None\n        self.storageEngine = None\n'
u'1122,    @classmethod\n    def from_ays(cls, storageEngine_services, password=None):\n        storageEngine = StorageEngine.from_ays(storageEngine_services, password)\n        storage_server = cls(None)\n        storage_server.container = storageEngine.container\n        storage_server.storageEngine = storageEngine\n        return storage_server\n'
u'1123,    @property\n    def name(self):\n        if self.storageEngine:\n            return self.storageEngine.name\n        return None\n'
u'1124,    @property\n    def node(self):\n        if self.container:\n            return self.container.node\n        return None\n'
u'1125,    def _find_port(self, start_port=2000):\n        while True:\n            if j.sal.nettools.tcpPortConnectionTest(self.node.addr, start_port, timeout=2):\n                start_port += 1\n                continue\n            return start_port\n'
u'1126,    def start(self, timeout=30):\n        logger.debug("start %s", self)\n        if not self.container.is_running():\n            self.container.start()\n\n        ip, port = self.storageEngine.bind.split(":")\n        self.storageEngine.bind = \'{}:{}\'.format(ip, self._find_port(port))\n        self.storageEngine.start(timeout=timeout)\n'
u'1127,    def stop(self, timeout=30):\n        logger.debug("stop %s", self)\n        self.storageEngine.stop(timeout=timeout)\n        self.container.stop()\n'
u'1128,    def is_running(self):\n        container = self.container.is_running()\n        storageEngine, _ = self.storageEngine.is_running()\n        return (container and storageEngine)\n'
u'1129,    def __str__(self):\n        return "StorageServer <{}>".format(self.container.name)\n'
u'1130,    def __repr__(self):\n        return str(self)\n'
u"1131,    def __init__(self, cluster):\n        self.cluster = cluster\n        self.store = 'statsdb'\n"
u'1132,    def build_templating(self):\n        templating = {\n            "list": [],\n            "rows": []\n        }\n        return templating\n'
u'1133,    def dashboard_template(self):\n        return {\n            "annotations": {\n                "list": []\n            },\n            "editable": True,\n            "gnetId": None,\n            "graphTooltip": 0,\n            "hideControls": False,\n            "id": None,\n            "links": [],\n            "rows": [],\n            "schemaVersion": 14,\n            "style": "dark",\n            "tags": [],\n            "time": {\n                "from": "now/d",\n                "to": "now"\n            },\n            "timepicker": {\n                "refresh_intervals": [\n                    "5s",\n                    "10s",\n                    "30s",\n                    "1m",\n                    "5m",\n                    "15m",\n                    "30m",\n                    "1h",\n                    "2h",\n                    "1d"\n                ],\n                "time_options": [\n                    "5m",\n                    "15m",\n                    "1h",\n                    "6h",\n                    "12h",\n                    "24h",\n                    "2d",\n                    "7d",\n                    "30d"\n                ]\n            },\n            "timezone": "",\n            "title": self.cluster.name,\n            "version": 8\n        }\n'
u'1134,    def build_row(self, panel):\n        template = {\n            "collapse": False,\n            "height": 295,\n            "panels": [],\n            "repeat": None,\n            "repeatIteration": None,\n            "repeatRowId": None,\n            "showTitle": False,\n            "title": "Dashboard Row",\n            "titleSize": "h6"\n        }\n        template["panels"] += panel\n        return template\n'
u'1135,    def build_panel(self, title, target, panel_id, unit):\n        template = {\n            "aliasColors": {},\n            "bars": False,\n            "dashLength": 10,\n            "dashes": False,\n            "datasource": self.store,\n            "fill": 1,\n            "id": panel_id,\n            "legend": {\n                "avg": False,\n                "current": False,\n                "max": False,\n                "min": False,\n                "show": True,\n                "total": False,\n                "values": False\n            },\n            "lines": True,\n            "linewidth": 1,\n            "links": [],\n            "nullPointMode": "null",\n            "percentage": False,\n            "pointradius": 5,\n            "points": False,\n            "renderer": "flot",\n            "seriesOverrides": [],\n            "spaceLength": 10,\n            "span": 6,\n            "stack": True,\n            "steppedLine": False,\n            "targets": [],\n            "thresholds": [],\n            "timeFrom": None,\n            "timeShift": None,\n            "tooltip": {\n                "shared": True,\n                "sort": 0,\n                "value_type": "individual"\n            },\n            "type": "graph",\n            "xaxis": {\n                "buckets": None,\n                "mode": "time",\n                "name": None,\n                "show": True,\n                "values": []\n            },\n            "yaxes": [\n                {\n                    "format": unit,\n                    "label": None,\n                    "logBase": 1,\n                    "max": None,\n                    "min": None,\n                    "show": True\n                },\n                {\n                    "format": "short",\n                    "label": None,\n                    "logBase": 1,\n                    "max": None,\n                    "min": None,\n                    "show": True\n                }\n            ]\n        }\n        template["title"] = title\n        template["targets"].append(target)\n        return template\n'
u'1136,    def build_target(self, measurement, disks):\n        template = {\n            "alias": "$tag_node/$tag_id",\n            "dsType": "influxdb",\n            "groupBy": [\n                {\n                    "params": [\n                        "$__interval"\n                    ],\n                    "type": "time"\n                },\n                {\n                    "params": [\n                        "node"\n                    ],\n                    "type": "tag"\n                },\n                {\n                    "params": [\n                        "id"\n                    ],\n                    "type": "tag"\n                },\n                {\n                    "params": [\n                        "none"\n                    ],\n                    "type": "fill"\n                }\n            ],\n            "orderByTime": "ASC",\n            "policy": "default",\n            "rawQuery": False,\n            "refId": "A",\n            "resultFormat": "time_series",\n            "select": [\n                [\n                    {\n                        "params": [\n                            "value"\n                        ],\n                        "type": "field"\n                    },\n                    {\n                        "params": [],\n                        "type": "mean"\n                    }\n                ]\n            ],\n            "tags": [\n                {\n                    "key": "type",\n                    "operator": "=",\n                    "value": "phys"\n                }\n            ]\n        }\n        template["measurement"] = measurement\n\n        for idx, disk in enumerate(disks):\n            tag = [\n                {\n                    "key": "node",\n                    "operator": "=",\n                    "value": disk.split("_")[0]\n                },\n                {\n                    "condition": "AND",\n                    "key": "id",\n                    "operator": "=",\n                    "value": disk.split("_")[1]\n                }\n            ]\n            if idx == 0:\n                tag[0]["condition"] = "AND"\n            else:\n                tag[0]["condition"] = "OR"\n            template["tags"] += tag\n        return template\n'
u'1137,    @property\n    def template(self):\n        AGGREGATED_CONFIG = {\n            "Aggregated read IOPs": "disk.iops.read|m",\n            "Aggregated write IOPs": "disk.iops.write|m",\n            "Aggregated free size": "disk.size.free|m",\n        }\n        panel_id = 1\n        disks = set()\n        for server in self.cluster.storage_servers:\n            server = server.name.split("_")\n            disks.add("{}_{}".format(server[1], server[-3]))\n        disks = list(disks)\n        panels = []\n        for title, measurement in AGGREGATED_CONFIG.items():\n            if \'size\' in title:\n                partitions = [disk+\'1\' for disk in disks]\n                target = self.build_target(measurement, partitions)\n                panels.append(self.build_panel(title, target, panel_id, "decbytes"))\n            else:\n                target = self.build_target(measurement, disks)\n                panels.append(self.build_panel(title, target, panel_id, "iops"))\n            panel_id += 1\n\n        for disk in disks:\n            target = self.build_target("disk.iops.read|m", [disk])\n            panels.append(self.build_panel("Read IOPs", target, panel_id, "iops"))\n            panel_id += 1\n            target = self.build_target("disk.iops.write|m", [disk])\n            panels.append(self.build_panel("Write IOPs", target, panel_id, "iops"))\n            panel_id += 1\n            target = self.build_target("disk.size.free|m", [disk+\'1\'])\n            panels.append(self.build_panel("Free size", target, panel_id, "decbytes"))\n            panel_id += 1\n\n        template = self.dashboard_template()\n        for idx, panel in enumerate(panels):\n            if idx % 2 == 0:\n                row = self.build_row(panels[idx:idx+2])\n                template["rows"].append(row)\n        template = json.dumps(template)\n        return template\n'
u"1138,        def check_partition(disk):\n            for partition in disk.partitions:\n                for filesystem in partition.filesystems:\n                    if filesystem['label'].startswith(cluster_name):\n                        return True\n"
u'1139,import io\nimport time\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass StorageEngine:\n    """storageEngine server"""\n\n    def __init__(self, name, container, bind=\'0.0.0.0:16379\', data_dir=\'/mnt/data\', master=None):\n        """\n        TODO: write doc string\n        """\n        self.name = name\n        self.master = master\n        self.container = container\n        self.bind = bind\n        self.port = int(bind.split(\':\')[1])\n        self.data_dir = data_dir\n        self.master = master\n        self._ays = None\n\n    @classmethod\n    def from_ays(cls, service, password=None):\n        logger.debug("create storageEngine from service (%s)", service)\n        from .Container import Container\n\n        container = Container.from_ays(service.parent, password)\n        if service.model.data.master != \'\':\n            master_service = service.aysrepo.serviceGet(\'storage_engine\', service.model.data.master)\n            master = StorageEngine.from_ays(master_service, password)\n        else:\n            master = None\n\n        return cls(\n            name=service.name,\n            container=container,\n            bind=service.model.data.bind,\n            data_dir=service.model.data.homeDir,\n            master=master,\n        )\n\n    def _configure(self):\n        logger.debug("configure storageEngine")\n        buff = io.BytesIO()\n        self.container.client.filesystem.download(\'/etc/ardb.conf\', buff)\n        content = buff.getvalue().decode()\n\n        # update config\n        content = content.replace(\'/mnt/data\', self.data_dir)\n        content = content.replace(\'0.0.0.0:16379\', self.bind)\n\n        if self.master is not None:\n            _, port = self.master.bind.split(":")\n            content = content.replace(\'#slaveof 127.0.0.1:6379\', \'slaveof {}:{}\'.format(self.master.container.node.addr, port))\n\n        # make sure home directory exists\n        self.container.client.filesystem.mkdir(self.data_dir)\n\n        # upload new config\n        self.container.client.filesystem.upload(\'/etc/ardb.conf.used\', io.BytesIO(initial_bytes=content.encode()))\n\n    def start(self, timeout=100):\n        if not self.container.is_running():\n            self.container.start()\n\n        running, _ = self.is_running()\n        if running:\n            return\n        logger.debug(\'start %s\', self)\n\n        self._configure()\n        self.container.client.system(\'/bin/ardb-server /etc/ardb.conf.used\')\n\n        # wait for storageEngine to start\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while not is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if not is_running:\n            raise RuntimeError("storage server {} didn\'t started".format(self.name))\n\n    def stop(self, timeout=30):\n        if not self.container.is_running():\n            return\n\n        is_running, job = self.is_running()\n        if not is_running:\n            return\n\n        logger.debug(\'stop %s\', self)\n\n        self.container.client.job.kill(job[\'cmd\'][\'id\'])\n\n        # wait for StorageEngine to stop\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if is_running:\n            raise RuntimeError("storage server {} didn\'t stopped")\n\n    def is_running(self):\n        try:\n            if self.port not in self.container.node.freeports(self.port, 1):\n                for job in self.container.client.job.list():\n                    if \'name\' in job[\'cmd\'][\'arguments\'] and job[\'cmd\'][\'arguments\'][\'name\'] == \'/bin/ardb-server\':\n                        return (True, job)\n            return (False, None)\n        except Exception as err:\n            if str(err).find("invalid container id"):\n                return (False, None)\n            raise\n\n    @property\n    def ays(self):\n        if self._ays is None:\n            from JumpScale.sal.g8os.atyourservice.StorageCluster import storageEngineAys\n            self._ays = storageEngineAys(self)\n        return self._ays\n\n    def __str__(self):\n        return "storageEngine <{}>".format(self.name)\n\n    def __repr__(self):\n        return str(self)\n'
u'1140,class StorageEngine:\n    """storageEngine server"""\n\n    def __init__(self, name, container, bind=\'0.0.0.0:16379\', data_dir=\'/mnt/data\', master=None):\n        """\n        TODO: write doc string\n        """\n        self.name = name\n        self.master = master\n        self.container = container\n        self.bind = bind\n        self.port = int(bind.split(\':\')[1])\n        self.data_dir = data_dir\n        self.master = master\n        self._ays = None\n\n    @classmethod\n    def from_ays(cls, service, password=None):\n        logger.debug("create storageEngine from service (%s)", service)\n        from .Container import Container\n\n        container = Container.from_ays(service.parent, password)\n        if service.model.data.master != \'\':\n            master_service = service.aysrepo.serviceGet(\'storage_engine\', service.model.data.master)\n            master = StorageEngine.from_ays(master_service, password)\n        else:\n            master = None\n\n        return cls(\n            name=service.name,\n            container=container,\n            bind=service.model.data.bind,\n            data_dir=service.model.data.homeDir,\n            master=master,\n        )\n\n    def _configure(self):\n        logger.debug("configure storageEngine")\n        buff = io.BytesIO()\n        self.container.client.filesystem.download(\'/etc/ardb.conf\', buff)\n        content = buff.getvalue().decode()\n\n        # update config\n        content = content.replace(\'/mnt/data\', self.data_dir)\n        content = content.replace(\'0.0.0.0:16379\', self.bind)\n\n        if self.master is not None:\n            _, port = self.master.bind.split(":")\n            content = content.replace(\'#slaveof 127.0.0.1:6379\', \'slaveof {}:{}\'.format(self.master.container.node.addr, port))\n\n        # make sure home directory exists\n        self.container.client.filesystem.mkdir(self.data_dir)\n\n        # upload new config\n        self.container.client.filesystem.upload(\'/etc/ardb.conf.used\', io.BytesIO(initial_bytes=content.encode()))\n\n    def start(self, timeout=100):\n        if not self.container.is_running():\n            self.container.start()\n\n        running, _ = self.is_running()\n        if running:\n            return\n        logger.debug(\'start %s\', self)\n\n        self._configure()\n        self.container.client.system(\'/bin/ardb-server /etc/ardb.conf.used\')\n\n        # wait for storageEngine to start\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while not is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if not is_running:\n            raise RuntimeError("storage server {} didn\'t started".format(self.name))\n\n    def stop(self, timeout=30):\n        if not self.container.is_running():\n            return\n\n        is_running, job = self.is_running()\n        if not is_running:\n            return\n\n        logger.debug(\'stop %s\', self)\n\n        self.container.client.job.kill(job[\'cmd\'][\'id\'])\n\n        # wait for StorageEngine to stop\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if is_running:\n            raise RuntimeError("storage server {} didn\'t stopped")\n\n    def is_running(self):\n        try:\n            if self.port not in self.container.node.freeports(self.port, 1):\n                for job in self.container.client.job.list():\n                    if \'name\' in job[\'cmd\'][\'arguments\'] and job[\'cmd\'][\'arguments\'][\'name\'] == \'/bin/ardb-server\':\n                        return (True, job)\n            return (False, None)\n        except Exception as err:\n            if str(err).find("invalid container id"):\n                return (False, None)\n            raise\n\n    @property\n    def ays(self):\n        if self._ays is None:\n            from JumpScale.sal.g8os.atyourservice.StorageCluster import storageEngineAys\n            self._ays = storageEngineAys(self)\n        return self._ays\n\n    def __str__(self):\n        return "storageEngine <{}>".format(self.name)\n\n    def __repr__(self):\n        return str(self)\n'
u'1141,    def __init__(self, name, container, bind=\'0.0.0.0:16379\', data_dir=\'/mnt/data\', master=None):\n        """\n        TODO: write doc string\n        """\n        self.name = name\n        self.master = master\n        self.container = container\n        self.bind = bind\n        self.port = int(bind.split(\':\')[1])\n        self.data_dir = data_dir\n        self.master = master\n        self._ays = None\n'
u'1142,    @classmethod\n    def from_ays(cls, service, password=None):\n        logger.debug("create storageEngine from service (%s)", service)\n        from .Container import Container\n\n        container = Container.from_ays(service.parent, password)\n        if service.model.data.master != \'\':\n            master_service = service.aysrepo.serviceGet(\'storage_engine\', service.model.data.master)\n            master = StorageEngine.from_ays(master_service, password)\n        else:\n            master = None\n\n        return cls(\n            name=service.name,\n            container=container,\n            bind=service.model.data.bind,\n            data_dir=service.model.data.homeDir,\n            master=master,\n        )\n'
u'1143,    def _configure(self):\n        logger.debug("configure storageEngine")\n        buff = io.BytesIO()\n        self.container.client.filesystem.download(\'/etc/ardb.conf\', buff)\n        content = buff.getvalue().decode()\n\n        # update config\n        content = content.replace(\'/mnt/data\', self.data_dir)\n        content = content.replace(\'0.0.0.0:16379\', self.bind)\n\n        if self.master is not None:\n            _, port = self.master.bind.split(":")\n            content = content.replace(\'#slaveof 127.0.0.1:6379\', \'slaveof {}:{}\'.format(self.master.container.node.addr, port))\n\n        # make sure home directory exists\n        self.container.client.filesystem.mkdir(self.data_dir)\n\n        # upload new config\n        self.container.client.filesystem.upload(\'/etc/ardb.conf.used\', io.BytesIO(initial_bytes=content.encode()))\n'
u'1144,    def start(self, timeout=100):\n        if not self.container.is_running():\n            self.container.start()\n\n        running, _ = self.is_running()\n        if running:\n            return\n        logger.debug(\'start %s\', self)\n\n        self._configure()\n        self.container.client.system(\'/bin/ardb-server /etc/ardb.conf.used\')\n\n        # wait for storageEngine to start\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while not is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if not is_running:\n            raise RuntimeError("storage server {} didn\'t started".format(self.name))\n'
u'1145,    def stop(self, timeout=30):\n        if not self.container.is_running():\n            return\n\n        is_running, job = self.is_running()\n        if not is_running:\n            return\n\n        logger.debug(\'stop %s\', self)\n\n        self.container.client.job.kill(job[\'cmd\'][\'id\'])\n\n        # wait for StorageEngine to stop\n        start = time.time()\n        end = start + timeout\n        is_running, _ = self.is_running()\n        while is_running and time.time() < end:\n            time.sleep(1)\n            is_running, _ = self.is_running()\n\n        if is_running:\n            raise RuntimeError("storage server {} didn\'t stopped")\n'
u'1146,    def is_running(self):\n        try:\n            if self.port not in self.container.node.freeports(self.port, 1):\n                for job in self.container.client.job.list():\n                    if \'name\' in job[\'cmd\'][\'arguments\'] and job[\'cmd\'][\'arguments\'][\'name\'] == \'/bin/ardb-server\':\n                        return (True, job)\n            return (False, None)\n        except Exception as err:\n            if str(err).find("invalid container id"):\n                return (False, None)\n            raise\n'
u'1147,    @property\n    def ays(self):\n        if self._ays is None:\n            from JumpScale.sal.g8os.atyourservice.StorageCluster import storageEngineAys\n            self._ays = storageEngineAys(self)\n        return self._ays\n'
u'1148,    def __str__(self):\n        return "storageEngine <{}>".format(self.name)\n'
u'1149,    def __repr__(self):\n        return str(self)\n'
u'1150,from .abstracts import Mountable\nimport os\nimport time\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\ndef _prepare_device(node, devicename):\n    logger.debug("prepare device %s", devicename)\n    ss = devicename.split(\'/\')\n    if len(ss) < 3:\n        raise RuntimeError("bad device name: {}".format(devicename))\n    name = ss[2]\n\n    disk = node.disks.get(name)\n    if disk is None:\n        raise ValueError("device {} not found".format(name))\n\n    node.client.system(\'parted -s /dev/{} mklabel gpt mkpart primary 1m 100%\'.format(name)).get()\n    now = time.time()\n    # check partitions is ready and writable\n    while now + 60 > time.time():\n        try:\n            disk = node.disks.get(name)\n            if len(disk.partitions) > 0:\n                partition = disk.partitions[0]\n                resp = node.client.bash(\'test -b {0} && dd if={0} of=/dev/null bs=4k count=1024\'.format(partition.devicename)).get()\n                if resp.state == \'SUCCESS\':\n                    return partition\n        except:\n            time.sleep(1)\n            continue\n    else:\n        raise RuntimeError("Failed to create partition")\n\n\nclass StoragePools:\n    def __init__(self, node):\n        self.node = node\n        self._client = node._client\n\n    def list(self):\n        storagepools = []\n        btrfs_list = self._client.btrfs.list()\n        if btrfs_list:\n            for btrfs in self._client.btrfs.list():\n                if btrfs[\'label\'].startswith(\'sp_\'):\n                    name = btrfs[\'label\'].split(\'_\', 1)[1]\n                    devicenames = [device[\'path\'] for device in btrfs[\'devices\']]\n                    storagepools.append(StoragePool(self.node, name, devicenames))\n        return storagepools\n\n    def get(self, name):\n        for pool in self.list():\n            if pool.name == name:\n                return pool\n        raise ValueError("Could not find StoragePool with name {}".format(name))\n\n    def create(self, name, devices, metadata_profile, data_profile, overwrite=False):\n        label = \'sp_{}\'.format(name)\n        logger.debug("create storagepool %s", label)\n\n        device_names = []\n        for device in devices:\n            part = _prepare_device(self.node, device)\n            device_names.append(part.devicename)\n\n        self._client.btrfs.create(label, device_names, metadata_profile, data_profile, overwrite=overwrite)\n        pool = StoragePool(self.node, name, device_names)\n        return pool\n\n\nclass StoragePool(Mountable):\n\n    def __init__(self, node, name, devices):\n        self.node = node\n        self._client = node._client\n        self.devices = devices\n        self.name = name\n        self._mountpoint = None\n        self._ays = None\n\n    @property\n    def devicename(self):\n        return \'UUID={}\'.format(self.uuid)\n\n    def mount(self, target=None):\n        if target is None:\n            target = os.path.join(\'/mnt/storagepools/{}\'.format(self.name))\n        return super().mount(target)\n\n    def delete(self, zero=True):\n        """\n        Destroy storage pool\n        param zero: write zeros (nulls) to the first 500MB of each disk in this storagepool\n        """\n\n        if self.mountpoint:\n            self.umount()\n        partitionmap = {}\n        for disk in self.node.disks.list():\n            for partition in disk.partitions:\n                partitionmap[partition.name] = partition\n        for device in self.devices:\n            diskpath = os.path.basename(device)\n            partition = partitionmap.get(diskpath)\n            if partition:\n                disk = partition.disk\n                self._client.disk.rmpart(disk.name, 1)\n                if zero:\n                    self._client.bash(\'test -b /dev/{0} && dd if=/dev/zero bs=1M count=500 of=/dev/{0}\'.format(diskpath)).get()\n                return True\n        return False\n\n    @property\n    def mountpoint(self):\n        mounts = self.node.list_mounts()\n        for device in self.devices:\n            for mount in mounts:\n                if mount.device == device:\n                    options = mount.options.split(\',\')\n                    if \'subvol=/\' in options:\n                        return mount.mountpoint\n\n    def is_device_used(self, device):\n        """\n        check if the device passed as argument is already part of this storagepool\n        @param device: str e.g: /dev/sda\n        """\n        for d in self.devices:\n            if d.startswith(device):\n                return True\n        return False\n\n    def device_add(self, *devices):\n        to_add = []\n        for device in devices:\n            if self.is_device_used(device):\n                continue\n            part = _prepare_device(self.node, device)\n            logger.debug("add device %s to %s", device, self)\n            to_add.append(part.devicename)\n\n        self._client.btrfs.device_add(self._get_mountpoint(), *to_add)\n        self.devices.extend(to_add)\n\n    def device_remove(self, *devices):\n        self._client.btrfs.device_remove(self._get_mountpoint(), *devices)\n        for device in devices:\n            if device in self.devices:\n                logger.debug("remove device %s to %s", device, self)\n                self.devices.remove(device)\n\n    @property\n    def fsinfo(self):\n        if self.mountpoint is None:\n            raise ValueError("can\'t get fsinfo if storagepool is not mounted")\n        return self._client.btrfs.info(self.mountpoint)\n\n    @mountpoint.setter\n    def mountpoint(self, value):\n        # do not do anything mountpoint is dynamic\n        return\n\n    def _get_mountpoint(self):\n        mountpoint = self.mountpoint\n        if not mountpoint:\n            raise RuntimeError("Can not perform action when filesystem is not mounted")\n        return mountpoint\n\n    @property\n    def info(self):\n        for fs in self._client.btrfs.list():\n            if fs[\'label\'] == \'sp_{}\'.format(self.name):\n                return fs\n        return None\n\n    def raw_list(self):\n        mountpoint = self._get_mountpoint()\n        return self._client.btrfs.subvol_list(mountpoint) or []\n\n    def get_devices_and_status(self):\n        device_map = []\n        disks = self._client.disk.list()[\'blockdevices\']\n        pool_status = \'healthy\'\n        for device in self.devices:\n            info = None\n            for disk in disks:\n                disk_name = "/dev/%s" % disk[\'kname\']\n                if device == disk_name and disk[\'mountpoint\']:\n                    info = disk\n                    break\n                for part in disk.get(\'children\', []) or []:\n                    if device == "/dev/%s" % part[\'kname\']:\n                        info = part\n                        break\n                if info:\n                    break\n\n            status = \'healthy\'\n            if info[\'subsystems\'] != \'block:virtio:pci\':\n                result = self._client.bash("smartctl -H %s > /dev/null ;echo $?" % disk_name).get()\n                exit_status = int(result.stdout)\n\n                if exit_status & 1 << 0:\n                    status = "unknown"\n                    pool_status = \'degraded\'\n                if (exit_status & 1 << 2) or (exit_status & 1 << 3):\n                    status = \'degraded\'\n                    pool_status = \'degraded\'\n\n            device_map.append({\n                \'device\': device,\n                \'partUUID\': info[\'partuuid\'] or \'\' if info else \'\',\n                \'status\': status,\n            })\n\n        return device_map, pool_status\n\n    def list(self):\n        subvolumes = []\n        for subvol in self.raw_list():\n            path = subvol[\'Path\']\n            type_, _, name = path.partition(\'/\')\n            if type_ == \'filesystems\':\n                subvolumes.append(FileSystem(name, self))\n        return subvolumes\n\n    def get(self, name):\n        """\n        Get Filesystem\n        """\n        for filesystem in self.list():\n            if filesystem.name == name:\n                return filesystem\n        raise ValueError("Could not find filesystem with name {}".format(name))\n\n    def exists(self, name):\n        """\n        Check if filesystem with name exists\n        """\n        for subvolume in self.list():\n            if subvolume.name == name:\n                return True\n        return False\n\n    def create(self, name, quota=None):\n        """\n        Create filesystem\n        """\n        logger.debug("Create filesystem %s on %s", name, self)\n        mountpoint = self._get_mountpoint()\n        fspath = os.path.join(mountpoint, \'filesystems\')\n        self._client.filesystem.mkdir(fspath)\n        subvolpath = os.path.join(fspath, name)\n        self._client.btrfs.subvol_create(subvolpath)\n        if quota:\n            pass\n        return FileSystem(name, self)\n\n    @property\n    def size(self):\n        total = 0\n        fs = self.info\n        if fs:\n            for device in fs[\'devices\']:\n                total += device[\'size\']\n        return total\n\n    @property\n    def uuid(self):\n        fs = self.info\n        if fs:\n            return fs[\'uuid\']\n        return None\n\n    @property\n    def used(self):\n        total = 0\n        fs = self.info\n        if fs:\n            for device in fs[\'devices\']:\n                total += device[\'used\']\n        return total\n\n    @property\n    def ays(self):\n        if self._ays is None:\n            from zeroos.orchestrator.sal.atyourservice.StoragePool import StoragePoolAys\n            self._ays = StoragePoolAys(self)\n        return self._ays\n\n    def __repr__(self):\n        return "StoragePool <{}>".format(self.name)\n\n\nclass FileSystem:\n    def __init__(self, name, pool):\n        self.name = name\n        self.pool = pool\n        self._client = pool.node.client\n        self.subvolume = "filesystems/{}".format(name)\n        self.path = os.path.join(self.pool.mountpoint, self.subvolume)\n        self.snapshotspath = os.path.join(self.pool.mountpoint, \'snapshots\', self.name)\n        self._ays = None\n\n    def delete(self, includesnapshots=True):\n        """\n        Delete filesystem\n        """\n        paths = [fs[\'Path\'] for fs in self._client.btrfs.subvol_list(self.path)]\n        paths.sort(reverse=True)\n        for path in paths:\n            rpath = os.path.join(self.path, os.path.relpath(path, self.subvolume))\n            self._client.btrfs.subvol_delete(rpath)\n        self._client.btrfs.subvol_delete(self.path)\n        if includesnapshots:\n            for snapshot in self.list():\n                snapshot.delete()\n            self._client.filesystem.remove(self.snapshotspath)\n\n    def get(self, name):\n        """\n        Get snapshot\n        """\n        for snap in self.list():\n            if snap.name == name:\n                return snap\n        raise ValueError("Could not find snapshot {}".format(name))\n\n    def list(self):\n        """\n        List snapshots\n        """\n        snapshots = []\n        if self._client.filesystem.exists(self.snapshotspath):\n            for fileentry in self._client.filesystem.list(self.snapshotspath):\n                if fileentry[\'is_dir\']:\n                    snapshots.append(Snapshot(fileentry[\'name\'], self))\n        return snapshots\n\n    def exists(self, name):\n        """\n        Check if a snapshot exists\n        """\n        return name in self.list()\n\n    def create(self, name):\n        """\n        Create snapshot\n        """\n        logger.debug("create snapshot %s on %s", name, self.pool)\n        snapshot = Snapshot(name, self)\n        if self.exists(name):\n            raise RuntimeError("Snapshot path {} exists.")\n        self._client.filesystem.mkdir(self.snapshotspath)\n        self._client.btrfs.subvol_snapshot(self.path, snapshot.path)\n        return snapshot\n\n    @property\n    def ays(self):\n        if self._ays is None:\n            from JumpScale.sal.g8os.atyourservice.StoragePool import FileSystemAys\n            self._ays = FileSystemAys(self)\n        return self._ays\n\n    def __repr__(self):\n        return "FileSystem <{}: {!r}>".format(self.name, self.pool)\n\n\nclass Snapshot:\n    def __init__(self, name, filesystem):\n        self.filesystem = filesystem\n        self._client = filesystem.pool.node.client\n        self.name = name\n        self.path = os.path.join(self.filesystem.snapshotspath, name)\n        self.subvolume = "snapshots/{}/{}".format(self.filesystem.name, name)\n\n    def rollback(self):\n        self.filesystem.delete(False)\n        self._client.btrfs.subvol_snapshot(self.path, self.filesystem.path)\n\n    def delete(self):\n        self._client.btrfs.subvol_delete(self.path)\n\n    def __repr__(self):\n        return "Snapshot <{}: {!r}>".format(self.name, self.filesystem)\n'
u'1151,def _prepare_device(node, devicename):\n    logger.debug("prepare device %s", devicename)\n    ss = devicename.split(\'/\')\n    if len(ss) < 3:\n        raise RuntimeError("bad device name: {}".format(devicename))\n    name = ss[2]\n\n    disk = node.disks.get(name)\n    if disk is None:\n        raise ValueError("device {} not found".format(name))\n\n    node.client.system(\'parted -s /dev/{} mklabel gpt mkpart primary 1m 100%\'.format(name)).get()\n    now = time.time()\n    # check partitions is ready and writable\n    while now + 60 > time.time():\n        try:\n            disk = node.disks.get(name)\n            if len(disk.partitions) > 0:\n                partition = disk.partitions[0]\n                resp = node.client.bash(\'test -b {0} && dd if={0} of=/dev/null bs=4k count=1024\'.format(partition.devicename)).get()\n                if resp.state == \'SUCCESS\':\n                    return partition\n        except:\n            time.sleep(1)\n            continue\n    else:\n        raise RuntimeError("Failed to create partition")\n'
u'1152,class StoragePools:\n    def __init__(self, node):\n        self.node = node\n        self._client = node._client\n\n    def list(self):\n        storagepools = []\n        btrfs_list = self._client.btrfs.list()\n        if btrfs_list:\n            for btrfs in self._client.btrfs.list():\n                if btrfs[\'label\'].startswith(\'sp_\'):\n                    name = btrfs[\'label\'].split(\'_\', 1)[1]\n                    devicenames = [device[\'path\'] for device in btrfs[\'devices\']]\n                    storagepools.append(StoragePool(self.node, name, devicenames))\n        return storagepools\n\n    def get(self, name):\n        for pool in self.list():\n            if pool.name == name:\n                return pool\n        raise ValueError("Could not find StoragePool with name {}".format(name))\n\n    def create(self, name, devices, metadata_profile, data_profile, overwrite=False):\n        label = \'sp_{}\'.format(name)\n        logger.debug("create storagepool %s", label)\n\n        device_names = []\n        for device in devices:\n            part = _prepare_device(self.node, device)\n            device_names.append(part.devicename)\n\n        self._client.btrfs.create(label, device_names, metadata_profile, data_profile, overwrite=overwrite)\n        pool = StoragePool(self.node, name, device_names)\n        return pool\n'
u'1153,class StoragePool(Mountable):\n\n    def __init__(self, node, name, devices):\n        self.node = node\n        self._client = node._client\n        self.devices = devices\n        self.name = name\n        self._mountpoint = None\n        self._ays = None\n\n    @property\n    def devicename(self):\n        return \'UUID={}\'.format(self.uuid)\n\n    def mount(self, target=None):\n        if target is None:\n            target = os.path.join(\'/mnt/storagepools/{}\'.format(self.name))\n        return super().mount(target)\n\n    def delete(self, zero=True):\n        """\n        Destroy storage pool\n        param zero: write zeros (nulls) to the first 500MB of each disk in this storagepool\n        """\n\n        if self.mountpoint:\n            self.umount()\n        partitionmap = {}\n        for disk in self.node.disks.list():\n            for partition in disk.partitions:\n                partitionmap[partition.name] = partition\n        for device in self.devices:\n            diskpath = os.path.basename(device)\n            partition = partitionmap.get(diskpath)\n            if partition:\n                disk = partition.disk\n                self._client.disk.rmpart(disk.name, 1)\n                if zero:\n                    self._client.bash(\'test -b /dev/{0} && dd if=/dev/zero bs=1M count=500 of=/dev/{0}\'.format(diskpath)).get()\n                return True\n        return False\n\n    @property\n    def mountpoint(self):\n        mounts = self.node.list_mounts()\n        for device in self.devices:\n            for mount in mounts:\n                if mount.device == device:\n                    options = mount.options.split(\',\')\n                    if \'subvol=/\' in options:\n                        return mount.mountpoint\n\n    def is_device_used(self, device):\n        """\n        check if the device passed as argument is already part of this storagepool\n        @param device: str e.g: /dev/sda\n        """\n        for d in self.devices:\n            if d.startswith(device):\n                return True\n        return False\n\n    def device_add(self, *devices):\n        to_add = []\n        for device in devices:\n            if self.is_device_used(device):\n                continue\n            part = _prepare_device(self.node, device)\n            logger.debug("add device %s to %s", device, self)\n            to_add.append(part.devicename)\n\n        self._client.btrfs.device_add(self._get_mountpoint(), *to_add)\n        self.devices.extend(to_add)\n\n    def device_remove(self, *devices):\n        self._client.btrfs.device_remove(self._get_mountpoint(), *devices)\n        for device in devices:\n            if device in self.devices:\n                logger.debug("remove device %s to %s", device, self)\n                self.devices.remove(device)\n\n    @property\n    def fsinfo(self):\n        if self.mountpoint is None:\n            raise ValueError("can\'t get fsinfo if storagepool is not mounted")\n        return self._client.btrfs.info(self.mountpoint)\n\n    @mountpoint.setter\n    def mountpoint(self, value):\n        # do not do anything mountpoint is dynamic\n        return\n\n    def _get_mountpoint(self):\n        mountpoint = self.mountpoint\n        if not mountpoint:\n            raise RuntimeError("Can not perform action when filesystem is not mounted")\n        return mountpoint\n\n    @property\n    def info(self):\n        for fs in self._client.btrfs.list():\n            if fs[\'label\'] == \'sp_{}\'.format(self.name):\n                return fs\n        return None\n\n    def raw_list(self):\n        mountpoint = self._get_mountpoint()\n        return self._client.btrfs.subvol_list(mountpoint) or []\n\n    def get_devices_and_status(self):\n        device_map = []\n        disks = self._client.disk.list()[\'blockdevices\']\n        pool_status = \'healthy\'\n        for device in self.devices:\n            info = None\n            for disk in disks:\n                disk_name = "/dev/%s" % disk[\'kname\']\n                if device == disk_name and disk[\'mountpoint\']:\n                    info = disk\n                    break\n                for part in disk.get(\'children\', []) or []:\n                    if device == "/dev/%s" % part[\'kname\']:\n                        info = part\n                        break\n                if info:\n                    break\n\n            status = \'healthy\'\n            if info[\'subsystems\'] != \'block:virtio:pci\':\n                result = self._client.bash("smartctl -H %s > /dev/null ;echo $?" % disk_name).get()\n                exit_status = int(result.stdout)\n\n                if exit_status & 1 << 0:\n                    status = "unknown"\n                    pool_status = \'degraded\'\n                if (exit_status & 1 << 2) or (exit_status & 1 << 3):\n                    status = \'degraded\'\n                    pool_status = \'degraded\'\n\n            device_map.append({\n                \'device\': device,\n                \'partUUID\': info[\'partuuid\'] or \'\' if info else \'\',\n                \'status\': status,\n            })\n\n        return device_map, pool_status\n\n    def list(self):\n        subvolumes = []\n        for subvol in self.raw_list():\n            path = subvol[\'Path\']\n            type_, _, name = path.partition(\'/\')\n            if type_ == \'filesystems\':\n                subvolumes.append(FileSystem(name, self))\n        return subvolumes\n\n    def get(self, name):\n        """\n        Get Filesystem\n        """\n        for filesystem in self.list():\n            if filesystem.name == name:\n                return filesystem\n        raise ValueError("Could not find filesystem with name {}".format(name))\n\n    def exists(self, name):\n        """\n        Check if filesystem with name exists\n        """\n        for subvolume in self.list():\n            if subvolume.name == name:\n                return True\n        return False\n\n    def create(self, name, quota=None):\n        """\n        Create filesystem\n        """\n        logger.debug("Create filesystem %s on %s", name, self)\n        mountpoint = self._get_mountpoint()\n        fspath = os.path.join(mountpoint, \'filesystems\')\n        self._client.filesystem.mkdir(fspath)\n        subvolpath = os.path.join(fspath, name)\n        self._client.btrfs.subvol_create(subvolpath)\n        if quota:\n            pass\n        return FileSystem(name, self)\n\n    @property\n    def size(self):\n        total = 0\n        fs = self.info\n        if fs:\n            for device in fs[\'devices\']:\n                total += device[\'size\']\n        return total\n\n    @property\n    def uuid(self):\n        fs = self.info\n        if fs:\n            return fs[\'uuid\']\n        return None\n\n    @property\n    def used(self):\n        total = 0\n        fs = self.info\n        if fs:\n            for device in fs[\'devices\']:\n                total += device[\'used\']\n        return total\n\n    @property\n    def ays(self):\n        if self._ays is None:\n            from zeroos.orchestrator.sal.atyourservice.StoragePool import StoragePoolAys\n            self._ays = StoragePoolAys(self)\n        return self._ays\n\n    def __repr__(self):\n        return "StoragePool <{}>".format(self.name)\n'
u'1154,class FileSystem:\n    def __init__(self, name, pool):\n        self.name = name\n        self.pool = pool\n        self._client = pool.node.client\n        self.subvolume = "filesystems/{}".format(name)\n        self.path = os.path.join(self.pool.mountpoint, self.subvolume)\n        self.snapshotspath = os.path.join(self.pool.mountpoint, \'snapshots\', self.name)\n        self._ays = None\n\n    def delete(self, includesnapshots=True):\n        """\n        Delete filesystem\n        """\n        paths = [fs[\'Path\'] for fs in self._client.btrfs.subvol_list(self.path)]\n        paths.sort(reverse=True)\n        for path in paths:\n            rpath = os.path.join(self.path, os.path.relpath(path, self.subvolume))\n            self._client.btrfs.subvol_delete(rpath)\n        self._client.btrfs.subvol_delete(self.path)\n        if includesnapshots:\n            for snapshot in self.list():\n                snapshot.delete()\n            self._client.filesystem.remove(self.snapshotspath)\n\n    def get(self, name):\n        """\n        Get snapshot\n        """\n        for snap in self.list():\n            if snap.name == name:\n                return snap\n        raise ValueError("Could not find snapshot {}".format(name))\n\n    def list(self):\n        """\n        List snapshots\n        """\n        snapshots = []\n        if self._client.filesystem.exists(self.snapshotspath):\n            for fileentry in self._client.filesystem.list(self.snapshotspath):\n                if fileentry[\'is_dir\']:\n                    snapshots.append(Snapshot(fileentry[\'name\'], self))\n        return snapshots\n\n    def exists(self, name):\n        """\n        Check if a snapshot exists\n        """\n        return name in self.list()\n\n    def create(self, name):\n        """\n        Create snapshot\n        """\n        logger.debug("create snapshot %s on %s", name, self.pool)\n        snapshot = Snapshot(name, self)\n        if self.exists(name):\n            raise RuntimeError("Snapshot path {} exists.")\n        self._client.filesystem.mkdir(self.snapshotspath)\n        self._client.btrfs.subvol_snapshot(self.path, snapshot.path)\n        return snapshot\n\n    @property\n    def ays(self):\n        if self._ays is None:\n            from JumpScale.sal.g8os.atyourservice.StoragePool import FileSystemAys\n            self._ays = FileSystemAys(self)\n        return self._ays\n\n    def __repr__(self):\n        return "FileSystem <{}: {!r}>".format(self.name, self.pool)\n'
u'1155,class Snapshot:\n    def __init__(self, name, filesystem):\n        self.filesystem = filesystem\n        self._client = filesystem.pool.node.client\n        self.name = name\n        self.path = os.path.join(self.filesystem.snapshotspath, name)\n        self.subvolume = "snapshots/{}/{}".format(self.filesystem.name, name)\n\n    def rollback(self):\n        self.filesystem.delete(False)\n        self._client.btrfs.subvol_snapshot(self.path, self.filesystem.path)\n\n    def delete(self):\n        self._client.btrfs.subvol_delete(self.path)\n\n    def __repr__(self):\n        return "Snapshot <{}: {!r}>".format(self.name, self.filesystem)\n'
u'1156,    def __init__(self, node):\n        self.node = node\n        self._client = node._client\n'
u"1157,    def list(self):\n        storagepools = []\n        btrfs_list = self._client.btrfs.list()\n        if btrfs_list:\n            for btrfs in self._client.btrfs.list():\n                if btrfs['label'].startswith('sp_'):\n                    name = btrfs['label'].split('_', 1)[1]\n                    devicenames = [device['path'] for device in btrfs['devices']]\n                    storagepools.append(StoragePool(self.node, name, devicenames))\n        return storagepools\n"
u'1158,    def get(self, name):\n        for pool in self.list():\n            if pool.name == name:\n                return pool\n        raise ValueError("Could not find StoragePool with name {}".format(name))\n'
u'1159,    def create(self, name, devices, metadata_profile, data_profile, overwrite=False):\n        label = \'sp_{}\'.format(name)\n        logger.debug("create storagepool %s", label)\n\n        device_names = []\n        for device in devices:\n            part = _prepare_device(self.node, device)\n            device_names.append(part.devicename)\n\n        self._client.btrfs.create(label, device_names, metadata_profile, data_profile, overwrite=overwrite)\n        pool = StoragePool(self.node, name, device_names)\n        return pool\n'
u'1160,    def __init__(self, node, name, devices):\n        self.node = node\n        self._client = node._client\n        self.devices = devices\n        self.name = name\n        self._mountpoint = None\n        self._ays = None\n'
u"1161,    @property\n    def devicename(self):\n        return 'UUID={}'.format(self.uuid)\n"
u"1162,    def mount(self, target=None):\n        if target is None:\n            target = os.path.join('/mnt/storagepools/{}'.format(self.name))\n        return super().mount(target)\n"
u'1163,    def delete(self, zero=True):\n        """\n        Destroy storage pool\n        param zero: write zeros (nulls) to the first 500MB of each disk in this storagepool\n        """\n\n        if self.mountpoint:\n            self.umount()\n        partitionmap = {}\n        for disk in self.node.disks.list():\n            for partition in disk.partitions:\n                partitionmap[partition.name] = partition\n        for device in self.devices:\n            diskpath = os.path.basename(device)\n            partition = partitionmap.get(diskpath)\n            if partition:\n                disk = partition.disk\n                self._client.disk.rmpart(disk.name, 1)\n                if zero:\n                    self._client.bash(\'test -b /dev/{0} && dd if=/dev/zero bs=1M count=500 of=/dev/{0}\'.format(diskpath)).get()\n                return True\n        return False\n'
u"1164,    @property\n    def mountpoint(self):\n        mounts = self.node.list_mounts()\n        for device in self.devices:\n            for mount in mounts:\n                if mount.device == device:\n                    options = mount.options.split(',')\n                    if 'subvol=/' in options:\n                        return mount.mountpoint\n"
u'1165,    def is_device_used(self, device):\n        """\n        check if the device passed as argument is already part of this storagepool\n        @param device: str e.g: /dev/sda\n        """\n        for d in self.devices:\n            if d.startswith(device):\n                return True\n        return False\n'
u'1166,    def device_add(self, *devices):\n        to_add = []\n        for device in devices:\n            if self.is_device_used(device):\n                continue\n            part = _prepare_device(self.node, device)\n            logger.debug("add device %s to %s", device, self)\n            to_add.append(part.devicename)\n\n        self._client.btrfs.device_add(self._get_mountpoint(), *to_add)\n        self.devices.extend(to_add)\n'
u'1167,    def device_remove(self, *devices):\n        self._client.btrfs.device_remove(self._get_mountpoint(), *devices)\n        for device in devices:\n            if device in self.devices:\n                logger.debug("remove device %s to %s", device, self)\n                self.devices.remove(device)\n'
u'1168,    @property\n    def fsinfo(self):\n        if self.mountpoint is None:\n            raise ValueError("can\'t get fsinfo if storagepool is not mounted")\n        return self._client.btrfs.info(self.mountpoint)\n'
u'1169,    @mountpoint.setter\n    def mountpoint(self, value):\n        # do not do anything mountpoint is dynamic\n        return\n'
u'1170,    def _get_mountpoint(self):\n        mountpoint = self.mountpoint\n        if not mountpoint:\n            raise RuntimeError("Can not perform action when filesystem is not mounted")\n        return mountpoint\n'
u"1171,    @property\n    def info(self):\n        for fs in self._client.btrfs.list():\n            if fs['label'] == 'sp_{}'.format(self.name):\n                return fs\n        return None\n"
u'1172,    def raw_list(self):\n        mountpoint = self._get_mountpoint()\n        return self._client.btrfs.subvol_list(mountpoint) or []\n'
u'1173,    def get_devices_and_status(self):\n        device_map = []\n        disks = self._client.disk.list()[\'blockdevices\']\n        pool_status = \'healthy\'\n        for device in self.devices:\n            info = None\n            for disk in disks:\n                disk_name = "/dev/%s" % disk[\'kname\']\n                if device == disk_name and disk[\'mountpoint\']:\n                    info = disk\n                    break\n                for part in disk.get(\'children\', []) or []:\n                    if device == "/dev/%s" % part[\'kname\']:\n                        info = part\n                        break\n                if info:\n                    break\n\n            status = \'healthy\'\n            if info[\'subsystems\'] != \'block:virtio:pci\':\n                result = self._client.bash("smartctl -H %s > /dev/null ;echo $?" % disk_name).get()\n                exit_status = int(result.stdout)\n\n                if exit_status & 1 << 0:\n                    status = "unknown"\n                    pool_status = \'degraded\'\n                if (exit_status & 1 << 2) or (exit_status & 1 << 3):\n                    status = \'degraded\'\n                    pool_status = \'degraded\'\n\n            device_map.append({\n                \'device\': device,\n                \'partUUID\': info[\'partuuid\'] or \'\' if info else \'\',\n                \'status\': status,\n            })\n\n        return device_map, pool_status\n'
u"1174,    def list(self):\n        subvolumes = []\n        for subvol in self.raw_list():\n            path = subvol['Path']\n            type_, _, name = path.partition('/')\n            if type_ == 'filesystems':\n                subvolumes.append(FileSystem(name, self))\n        return subvolumes\n"
u'1175,    def get(self, name):\n        """\n        Get Filesystem\n        """\n        for filesystem in self.list():\n            if filesystem.name == name:\n                return filesystem\n        raise ValueError("Could not find filesystem with name {}".format(name))\n'
u'1176,    def exists(self, name):\n        """\n        Check if filesystem with name exists\n        """\n        for subvolume in self.list():\n            if subvolume.name == name:\n                return True\n        return False\n'
u'1177,    def create(self, name, quota=None):\n        """\n        Create filesystem\n        """\n        logger.debug("Create filesystem %s on %s", name, self)\n        mountpoint = self._get_mountpoint()\n        fspath = os.path.join(mountpoint, \'filesystems\')\n        self._client.filesystem.mkdir(fspath)\n        subvolpath = os.path.join(fspath, name)\n        self._client.btrfs.subvol_create(subvolpath)\n        if quota:\n            pass\n        return FileSystem(name, self)\n'
u"1178,    @property\n    def size(self):\n        total = 0\n        fs = self.info\n        if fs:\n            for device in fs['devices']:\n                total += device['size']\n        return total\n"
u"1179,    @property\n    def uuid(self):\n        fs = self.info\n        if fs:\n            return fs['uuid']\n        return None\n"
u"1180,    @property\n    def used(self):\n        total = 0\n        fs = self.info\n        if fs:\n            for device in fs['devices']:\n                total += device['used']\n        return total\n"
u'1181,    @property\n    def ays(self):\n        if self._ays is None:\n            from zeroos.orchestrator.sal.atyourservice.StoragePool import StoragePoolAys\n            self._ays = StoragePoolAys(self)\n        return self._ays\n'
u'1182,    def __repr__(self):\n        return "StoragePool <{}>".format(self.name)\n'
u'1183,    def __init__(self, name, pool):\n        self.name = name\n        self.pool = pool\n        self._client = pool.node.client\n        self.subvolume = "filesystems/{}".format(name)\n        self.path = os.path.join(self.pool.mountpoint, self.subvolume)\n        self.snapshotspath = os.path.join(self.pool.mountpoint, \'snapshots\', self.name)\n        self._ays = None\n'
u'1184,    def delete(self, includesnapshots=True):\n        """\n        Delete filesystem\n        """\n        paths = [fs[\'Path\'] for fs in self._client.btrfs.subvol_list(self.path)]\n        paths.sort(reverse=True)\n        for path in paths:\n            rpath = os.path.join(self.path, os.path.relpath(path, self.subvolume))\n            self._client.btrfs.subvol_delete(rpath)\n        self._client.btrfs.subvol_delete(self.path)\n        if includesnapshots:\n            for snapshot in self.list():\n                snapshot.delete()\n            self._client.filesystem.remove(self.snapshotspath)\n'
u'1185,    def get(self, name):\n        """\n        Get snapshot\n        """\n        for snap in self.list():\n            if snap.name == name:\n                return snap\n        raise ValueError("Could not find snapshot {}".format(name))\n'
u'1186,    def list(self):\n        """\n        List snapshots\n        """\n        snapshots = []\n        if self._client.filesystem.exists(self.snapshotspath):\n            for fileentry in self._client.filesystem.list(self.snapshotspath):\n                if fileentry[\'is_dir\']:\n                    snapshots.append(Snapshot(fileentry[\'name\'], self))\n        return snapshots\n'
u'1187,    def exists(self, name):\n        """\n        Check if a snapshot exists\n        """\n        return name in self.list()\n'
u'1188,    def create(self, name):\n        """\n        Create snapshot\n        """\n        logger.debug("create snapshot %s on %s", name, self.pool)\n        snapshot = Snapshot(name, self)\n        if self.exists(name):\n            raise RuntimeError("Snapshot path {} exists.")\n        self._client.filesystem.mkdir(self.snapshotspath)\n        self._client.btrfs.subvol_snapshot(self.path, snapshot.path)\n        return snapshot\n'
u'1189,    @property\n    def ays(self):\n        if self._ays is None:\n            from JumpScale.sal.g8os.atyourservice.StoragePool import FileSystemAys\n            self._ays = FileSystemAys(self)\n        return self._ays\n'
u'1190,    def __repr__(self):\n        return "FileSystem <{}: {!r}>".format(self.name, self.pool)\n'
u'1191,    def __init__(self, name, filesystem):\n        self.filesystem = filesystem\n        self._client = filesystem.pool.node.client\n        self.name = name\n        self.path = os.path.join(self.filesystem.snapshotspath, name)\n        self.subvolume = "snapshots/{}/{}".format(self.filesystem.name, name)\n'
u'1192,    def rollback(self):\n        self.filesystem.delete(False)\n        self._client.btrfs.subvol_snapshot(self.path, self.filesystem.path)\n'
u'1193,    def delete(self):\n        self._client.btrfs.subvol_delete(self.path)\n'
u'1194,    def __repr__(self):\n        return "Snapshot <{}: {!r}>".format(self.name, self.filesystem)\n'
u'1195,from zerotier.client import Client\nimport netaddr\n\n\nclass ZTBootstrap:\n\n    def __init__(self, token, bootstap_id, grid_id, cidr):\n        self.bootstap_nwid = bootstap_id\n        self.grid_nwid = grid_id\n        self._cidr = cidr  # TODO validate format\n        # create client and set the authentication header\n        self._zt = Client()\n        self._zt.set_auth_header("Bearer " + token)\n\n    def configure_routes(self):\n        for nwid in [self.bootstap_nwid, self.grid_nwid]:\n            resp = self._zt.network.getNetwork(nwid)\n            resp.raise_for_status()\n            nw = resp.json()\n            nw[\'config\'][\'routes\'] = [{\'target\': self._cidr, \'via\': None}]\n            self._zt.network.updateNetwork(nw, nwid).raise_for_status()\n\n    def list_join_request(self):\n        """\n        return a list of member that try to access the bootstap network\n        """\n        resp = self._zt.network.listMembers(id=self.bootstap_nwid)\n        resp.raise_for_status()\n\n        requests = []\n        for member in resp.json():\n            if not member[\'online\'] or member[\'config\'][\'authorized\']:\n                continue\n            requests.append(member)\n\n        return requests\n\n    def assign_ip(self, nwid, member, ip=None):\n        """\n        Assign an Ip address to a member in a certain network\n        @nwid : id of the network\n        @member : member object\n        @ip: ip address to assing to the member, if None take the next free IP in the range\n        """\n        if ip is None:\n            ip = self._find_free_ip(nwid)\n        member[\'config\'][\'authorized\'] = True\n        member[\'config\'][\'ipAssignments\'] = [ip]\n        resp = self._zt.network.updateMember(member, member[\'nodeId\'], nwid)\n        resp.raise_for_status()\n        return ip\n\n    def unauthorize_member(self, nwid, member):\n        member[\'config\'][\'authorized\'] = False\n        member[\'config\'][\'ipAssignments\'] = []\n        resp = self._zt.network.updateMember(member, member[\'nodeId\'], nwid)\n        resp.raise_for_status()\n\n\n    def _find_free_ip(self, nwid):\n\n        resp = self._zt.network.listMembers(nwid)\n        resp.raise_for_status()\n\n        all_ips = list(netaddr.IPNetwork(self._cidr))\n        for member in resp.json():\n            for addr in member[\'config\'][\'ipAssignments\']:\n                all_ips.remove(netaddr.IPAddress(addr))\n        if len(all_ips) <= 0:\n            raise RuntimeError("No more free ip in the range %s" % self._cidr)\n        return str(all_ips[0])\n\n\nif __name__ == \'__main__\':\n    token = \'4gE9Cfqw2vFFzCPC1BYaj2mbSpNScxJx\'\n    bootstap_nwid = \'17d709436c993670\'\n    grid_nwid = \'a09acf02336ce8b5\'\n\n    zt = ZTBootstrap(token, bootstap_nwid, grid_nwid, \'192.168.10.0/24\')\n    from IPython import embed; embed()\n'
u'1196,class ZTBootstrap:\n\n    def __init__(self, token, bootstap_id, grid_id, cidr):\n        self.bootstap_nwid = bootstap_id\n        self.grid_nwid = grid_id\n        self._cidr = cidr  # TODO validate format\n        # create client and set the authentication header\n        self._zt = Client()\n        self._zt.set_auth_header("Bearer " + token)\n\n    def configure_routes(self):\n        for nwid in [self.bootstap_nwid, self.grid_nwid]:\n            resp = self._zt.network.getNetwork(nwid)\n            resp.raise_for_status()\n            nw = resp.json()\n            nw[\'config\'][\'routes\'] = [{\'target\': self._cidr, \'via\': None}]\n            self._zt.network.updateNetwork(nw, nwid).raise_for_status()\n\n    def list_join_request(self):\n        """\n        return a list of member that try to access the bootstap network\n        """\n        resp = self._zt.network.listMembers(id=self.bootstap_nwid)\n        resp.raise_for_status()\n\n        requests = []\n        for member in resp.json():\n            if not member[\'online\'] or member[\'config\'][\'authorized\']:\n                continue\n            requests.append(member)\n\n        return requests\n\n    def assign_ip(self, nwid, member, ip=None):\n        """\n        Assign an Ip address to a member in a certain network\n        @nwid : id of the network\n        @member : member object\n        @ip: ip address to assing to the member, if None take the next free IP in the range\n        """\n        if ip is None:\n            ip = self._find_free_ip(nwid)\n        member[\'config\'][\'authorized\'] = True\n        member[\'config\'][\'ipAssignments\'] = [ip]\n        resp = self._zt.network.updateMember(member, member[\'nodeId\'], nwid)\n        resp.raise_for_status()\n        return ip\n\n    def unauthorize_member(self, nwid, member):\n        member[\'config\'][\'authorized\'] = False\n        member[\'config\'][\'ipAssignments\'] = []\n        resp = self._zt.network.updateMember(member, member[\'nodeId\'], nwid)\n        resp.raise_for_status()\n\n\n    def _find_free_ip(self, nwid):\n\n        resp = self._zt.network.listMembers(nwid)\n        resp.raise_for_status()\n\n        all_ips = list(netaddr.IPNetwork(self._cidr))\n        for member in resp.json():\n            for addr in member[\'config\'][\'ipAssignments\']:\n                all_ips.remove(netaddr.IPAddress(addr))\n        if len(all_ips) <= 0:\n            raise RuntimeError("No more free ip in the range %s" % self._cidr)\n        return str(all_ips[0])\n'
u'1197,    def __init__(self, token, bootstap_id, grid_id, cidr):\n        self.bootstap_nwid = bootstap_id\n        self.grid_nwid = grid_id\n        self._cidr = cidr  # TODO validate format\n        # create client and set the authentication header\n        self._zt = Client()\n        self._zt.set_auth_header("Bearer " + token)\n'
u"1198,    def configure_routes(self):\n        for nwid in [self.bootstap_nwid, self.grid_nwid]:\n            resp = self._zt.network.getNetwork(nwid)\n            resp.raise_for_status()\n            nw = resp.json()\n            nw['config']['routes'] = [{'target': self._cidr, 'via': None}]\n            self._zt.network.updateNetwork(nw, nwid).raise_for_status()\n"
u'1199,    def list_join_request(self):\n        """\n        return a list of member that try to access the bootstap network\n        """\n        resp = self._zt.network.listMembers(id=self.bootstap_nwid)\n        resp.raise_for_status()\n\n        requests = []\n        for member in resp.json():\n            if not member[\'online\'] or member[\'config\'][\'authorized\']:\n                continue\n            requests.append(member)\n\n        return requests\n'
u'1200,    def assign_ip(self, nwid, member, ip=None):\n        """\n        Assign an Ip address to a member in a certain network\n        @nwid : id of the network\n        @member : member object\n        @ip: ip address to assing to the member, if None take the next free IP in the range\n        """\n        if ip is None:\n            ip = self._find_free_ip(nwid)\n        member[\'config\'][\'authorized\'] = True\n        member[\'config\'][\'ipAssignments\'] = [ip]\n        resp = self._zt.network.updateMember(member, member[\'nodeId\'], nwid)\n        resp.raise_for_status()\n        return ip\n'
u"1201,    def unauthorize_member(self, nwid, member):\n        member['config']['authorized'] = False\n        member['config']['ipAssignments'] = []\n        resp = self._zt.network.updateMember(member, member['nodeId'], nwid)\n        resp.raise_for_status()\n"
u'1202,    def _find_free_ip(self, nwid):\n\n        resp = self._zt.network.listMembers(nwid)\n        resp.raise_for_status()\n\n        all_ips = list(netaddr.IPNetwork(self._cidr))\n        for member in resp.json():\n            for addr in member[\'config\'][\'ipAssignments\']:\n                all_ips.remove(netaddr.IPAddress(addr))\n        if len(all_ips) <= 0:\n            raise RuntimeError("No more free ip in the range %s" % self._cidr)\n        return str(all_ips[0])\n'
u'1203,\n\n'
u'1204,from js9 import j\n\n\nclass Mountable:\n    """\n    Abstract implementation for devices that are mountable.\n    Device should have attributes devicename and mountpoint\n    """\n\n    def mount(self, target, options=[\'defaults\']):\n        """\n        @param target: Mount point\n        @param options: Optional mount options\n        """\n        if self.mountpoint == target:\n            return\n\n        self._client.bash(\'mkdir -p {}\'.format(target))\n\n        self._client.disk.mount(\n            source=self.devicename,\n            target=target,\n            options=options,\n        )\n\n        self.mountpoint = target\n\n    def umount(self):\n        """\n        Unmount disk\n        """\n        if self.mountpoint:\n            self._client.disk.umount(\n                source=self.mountpoint,\n            )\n        self.mountpoint = None\n\n\nclass AYSable:\n    """\n    Abstract implementation for class that reflect an AYS service.\n    class should have a name and actor attributes\n\n    This provide common method to CRUD AYS service from the python classes\n    """\n    @property\n    def name(self):\n        return self._obj.name\n\n    @property\n    def role(self):\n        return self.actor.split(\'.\')[0]\n\n    def create(self, aysrepo):\n        """\n        create the AYS Service\n        """\n        raise NotImplementedError()\n\n    def get(self, aysrepo):\n        """\n        get the AYS service\n        """\n        try:\n            return aysrepo.serviceGet(role=self.role, instance=self.name)\n        except j.exceptions.NotFound:\n            raise ValueError("Could not find {} with name {}".format(self.role, self.name))\n'
u'1205,class Mountable:\n    """\n    Abstract implementation for devices that are mountable.\n    Device should have attributes devicename and mountpoint\n    """\n\n    def mount(self, target, options=[\'defaults\']):\n        """\n        @param target: Mount point\n        @param options: Optional mount options\n        """\n        if self.mountpoint == target:\n            return\n\n        self._client.bash(\'mkdir -p {}\'.format(target))\n\n        self._client.disk.mount(\n            source=self.devicename,\n            target=target,\n            options=options,\n        )\n\n        self.mountpoint = target\n\n    def umount(self):\n        """\n        Unmount disk\n        """\n        if self.mountpoint:\n            self._client.disk.umount(\n                source=self.mountpoint,\n            )\n        self.mountpoint = None\n'
u'1206,class AYSable:\n    """\n    Abstract implementation for class that reflect an AYS service.\n    class should have a name and actor attributes\n\n    This provide common method to CRUD AYS service from the python classes\n    """\n    @property\n    def name(self):\n        return self._obj.name\n\n    @property\n    def role(self):\n        return self.actor.split(\'.\')[0]\n\n    def create(self, aysrepo):\n        """\n        create the AYS Service\n        """\n        raise NotImplementedError()\n\n    def get(self, aysrepo):\n        """\n        get the AYS service\n        """\n        try:\n            return aysrepo.serviceGet(role=self.role, instance=self.name)\n        except j.exceptions.NotFound:\n            raise ValueError("Could not find {} with name {}".format(self.role, self.name))\n'
u'1207,    def mount(self, target, options=[\'defaults\']):\n        """\n        @param target: Mount point\n        @param options: Optional mount options\n        """\n        if self.mountpoint == target:\n            return\n\n        self._client.bash(\'mkdir -p {}\'.format(target))\n\n        self._client.disk.mount(\n            source=self.devicename,\n            target=target,\n            options=options,\n        )\n\n        self.mountpoint = target\n'
u'1208,    def umount(self):\n        """\n        Unmount disk\n        """\n        if self.mountpoint:\n            self._client.disk.umount(\n                source=self.mountpoint,\n            )\n        self.mountpoint = None\n'
u'1209,    @property\n    def name(self):\n        return self._obj.name\n'
u"1210,    @property\n    def role(self):\n        return self.actor.split('.')[0]\n"
u'1211,    def create(self, aysrepo):\n        """\n        create the AYS Service\n        """\n        raise NotImplementedError()\n'
u'1212,    def get(self, aysrepo):\n        """\n        get the AYS service\n        """\n        try:\n            return aysrepo.serviceGet(role=self.role, instance=self.name)\n        except j.exceptions.NotFound:\n            raise ValueError("Could not find {} with name {}".format(self.role, self.name))\n'
u"1213,def get_configuration_and_service(ays_repo):\n    services = ays_repo.servicesFind(actor='configuration')\n    if len(services) > 1:\n        raise RuntimeError('Multiple configuration services found')\n\n    service = services[0] if services else None\n    configuration = service.model.data.to_dict()['configurations'] if service else []\n\n    return {conf['key']: conf['value'] for conf in configuration}, service\n\n\ndef get_configuration(ays_repo):\n    configs, _ = get_configuration_and_service(ays_repo)\n    return configs\n\n\ndef refresh_jwt_token(token):\n    import requests\n    import time\n    headers = {'Authorization': 'bearer %s' % token}\n    params = {'validity': '3600'}\n    resp = requests.get('https://itsyou.online/v1/oauth/jwt/refresh', headers=headers, params=params)\n    resp.raise_for_status()\n    return resp.content.decode()\n\n\ndef get_jwt_token(ays_repo):\n    import jose\n    import jose.jwt\n    import requests\n    import time\n    configs, service = get_configuration_and_service(ays_repo)\n    jwt_token = configs.get('jwt-token', '')\n    jwt_key = configs.get('jwt-key')\n    if not jwt_token:\n        return jwt_token\n\n    try:\n        token = jose.jwt.decode(jwt_token, jwt_key)\n        if token['exp'] < time.time() - 240:\n            jwt_token = refresh_jwt_token(jwt_token)\n\n        if token['exp'] > time.time() + 3600:\n            raise RuntimeError('Invalid jwt-token expiration time is too long should be less than 3600 sec')\n\n    except jose.exceptions.ExpiredSignatureError:\n        jwt_token = refresh_jwt_token(jwt_token)\n    except Exception:\n        raise RuntimeError('Invalid jwt-token and jwt-key combination')\n\n    for config in service.model.data.configurations:\n        if config.key == 'jwt-token':\n            config.value = jwt_token\n            break\n\n    service.saveAll()\n    return jwt_token\n\n\ndef get_jwt_token_from_job(job):\n    if 'token' in job.context:\n        return job.context['token']\n\n    return get_jwt_token(job.service.aysrepo)\n"
u"1214,def get_configuration_and_service(ays_repo):\n    services = ays_repo.servicesFind(actor='configuration')\n    if len(services) > 1:\n        raise RuntimeError('Multiple configuration services found')\n\n    service = services[0] if services else None\n    configuration = service.model.data.to_dict()['configurations'] if service else []\n\n    return {conf['key']: conf['value'] for conf in configuration}, service\n"
u'1215,def get_configuration(ays_repo):\n    configs, _ = get_configuration_and_service(ays_repo)\n    return configs\n'
u"1216,def refresh_jwt_token(token):\n    import requests\n    import time\n    headers = {'Authorization': 'bearer %s' % token}\n    params = {'validity': '3600'}\n    resp = requests.get('https://itsyou.online/v1/oauth/jwt/refresh', headers=headers, params=params)\n    resp.raise_for_status()\n    return resp.content.decode()\n"
u"1217,def get_jwt_token(ays_repo):\n    import jose\n    import jose.jwt\n    import requests\n    import time\n    configs, service = get_configuration_and_service(ays_repo)\n    jwt_token = configs.get('jwt-token', '')\n    jwt_key = configs.get('jwt-key')\n    if not jwt_token:\n        return jwt_token\n\n    try:\n        token = jose.jwt.decode(jwt_token, jwt_key)\n        if token['exp'] < time.time() - 240:\n            jwt_token = refresh_jwt_token(jwt_token)\n\n        if token['exp'] > time.time() + 3600:\n            raise RuntimeError('Invalid jwt-token expiration time is too long should be less than 3600 sec')\n\n    except jose.exceptions.ExpiredSignatureError:\n        jwt_token = refresh_jwt_token(jwt_token)\n    except Exception:\n        raise RuntimeError('Invalid jwt-token and jwt-key combination')\n\n    for config in service.model.data.configurations:\n        if config.key == 'jwt-token':\n            config.value = jwt_token\n            break\n\n    service.saveAll()\n    return jwt_token\n"
u"1218,def get_jwt_token_from_job(job):\n    if 'token' in job.context:\n        return job.context['token']\n\n    return get_jwt_token(job.service.aysrepo)\n"
u"1219,__import__('pkg_resources').declare_namespace(__name__)\n"
u"1220,from setuptools import setup, find_packages\n# To use a consistent encoding\nfrom codecs import open\nfrom os import path\n\nhere = path.abspath(path.dirname(__file__))\n\n# Get the long description from the README file\nwith open(path.join(here, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nsetup(\n    name='0-orchestrator',\n    version='1.1.0.a5',\n    description='Zero-OS Orchestrator',\n    long_description=long_description,\n    url='https://github.com/g8os/grid',\n    author='Christophe de Carvalho',\n    author_email='christophe@gig.tech',\n    license='Apache 2.0',\n    packages=find_packages(),\n    include_package_data=True,\n    package_data={\n        'zeroos.orchestrator.sal.templates': ['*', 'dashboards/*']\n    },\n    namespace_packages=['zeroos'],\n    install_requires=['python-dateutil', 'Jinja2'],\n)\n"
u"1221,from distutils.core import setup\n\nsetup(\n\tname\t\t= '02exercicio',\n\tversion\t\t= '1.0.0',\n\tpy_modules\t= ['02'],\n\tauthor\t\t= 'fernando',\n\tauthor_email\t= 'fernando.bzx@gamail.com',\n\turl\t\t= '***********************',\n\tdescription\t= 'Um simples programa dee teste da fun\xe7\xe3o def e loop for',\n)\n"
u'1222,from setuptools import find_packages, setup\nfrom setuptools.command.install import install\n\n\nclass CustomInstallCommand(install):\n    """Customized setuptools install command - prints a friendly greeting."""\n    def run(self):\n        print "Hello, developer, how are you? :)"\n        install.run(self)\n\n\nsetup(\n  name = \'0wdg9nbmpm\',\n  packages=find_packages(),\n  version = \'0.1\',\n  description = \'\',\n  author = \'\',\n  cmdclass={\n    \'install\': CustomInstallCommand,\n  },\n  author_email = \'\',\n  url = \'\',\n  keywords = [],\n  classifiers = [],\n)\n'
u'1223,class CustomInstallCommand(install):\n    """Customized setuptools install command - prints a friendly greeting."""\n    def run(self):\n        print "Hello, developer, how are you? :)"\n        install.run(self)\n'
u'1224,    def run(self):\n        print "Hello, developer, how are you? :)"\n        install.run(self)\n'
u"1225,#!/usr/bin/env python\n\nimport re\nimport argparse\nimport sys\nimport struct\n\nopcodes = [\n    'SET', 'ADD', 'SUB', 'MUL', 'DIV', 'MOD', 'SHL', 'SHR', 'AND', 'BOR',\n    'XOR', 'IFE', 'IFN', 'IFG', 'IFB',\n]\nnonbasic_opcodes = [\n    'JSR'\n]\npointers = [\n    'A', 'B', 'C', 'X', 'Y', 'Z', 'I', 'J',\n    'POP', 'PEEK', 'PUSH', 'SP', 'PC', 'O',\n]\n\noc = '|'.join(opcodes)  # (SET|ADD|SUB|...)\nnoc = '|'.join(nonbasic_opcodes)\nderef_pattern = '\\[\\s*%s\\s*\\]'  # [ ? ]\nhexa = '0x[0-9a-d]{1,4}'  # 0xbaba1\nhexa_deref = deref_pattern % hexa  # [ 0xbaba1 ]\nreg_pointers = '|'.join(pointers)  # A|B|C\nreg_deref = '|'.join(deref_pattern % reg for reg in pointers[:8])  # [A]|[B]\nhexa_plus_reg = '(%s)\\s*\\+\\s*(%s)' % (hexa, '|'.join(pointers[:8]))  # 0xb1 + I\noffset = deref_pattern % hexa_plus_reg  # [ 0xb1 + I ]\nlabel = '\\w+'\ndec = '\\d+'\nop = '|'.join(\n    '(%s)' % x for x in\n    [hexa, hexa_deref, reg_pointers, reg_deref, offset, dec, label]\n)\nl_def = ':\\w+'\nrow_pattern = '^\\s*(%s)?\\s*(((%s)\\s+(%s)\\s*,\\s*(%s))|((%s)\\s+(%s)))?\\s*(;.*)?$'\n\nre_row = re.compile(row_pattern % (l_def, oc, op, op, noc, op))\n\n\ndef emit_from_str(code):\n    for line in code.split('\\n'):\n        parsed_line = re_row.match(line)\n        if parsed_line is None:\n            print 'error found on line: %s' % line\n            exit(1)\n        for token in emit_from_line(parsed_line.groups()):\n            yield token\n\n\ndef emit_from_line(line):\n    if line[0]:\n        yield ('LABEL_DEF', line[0][1:])\n    if line[3]:\n        yield ('OPCODE', line[3])\n        for token in emit_from_op(line[4:14]):\n            yield token\n        for token in emit_from_op(line[14:24]):\n            yield token\n    if line[24]:\n        yield ('OPCODE_NB', line[25])\n        for token in emit_from_op(line[26:36]):\n            yield token\n    if line[36]:\n        yield ('COMMENT', line[36][1:])\n\n\ndef emit_from_op(op):\n    if op[1]:\n        yield ('CONST', int(op[1], 0))\n    elif op[2]:\n        yield ('CONST_DEREF', int(op[2][1:-1], 0))\n    elif op[3]:\n        yield ('REGISTRY', op[3])\n    elif op[4]:\n        yield ('REGISTRY_DEREF', op[4][1:-1])\n    elif op[5]:\n        yield ('OFFSET', (int(op[6], 0), op[7]))\n    elif op[8]:\n        yield ('CONST', int(op[8]))\n    elif op[9]:\n        yield ('LABEL_USE', op[9])\n\n\ndef compile(source):\n    result = []\n    emitter = emit_from_str(source)\n    labels = {}\n    labels_to_update = {}\n    to_append = []\n\n    def get_i(o_ttype, o_token):\n        if o_ttype == 'CONST':\n            i = o_token + 0x20\n            if o_token > 0x1f:\n                i = 0x1f\n                to_append.append(o_token)\n        elif o_ttype == 'CONST_DEREF':\n            i = 0x1e\n            to_append.append(o_token)\n        elif o_ttype == 'REGISTRY':\n            i = pointers.index(o_token)\n            if i >= 8:\n                i += 0x10\n        elif o_ttype == 'REGISTRY_DEREF':\n            i = pointers.index(o_token) + 0x08\n        elif o_ttype == 'OFFSET':\n            offset, reg = o_token\n            i = pointers.index(reg) + 0x10\n            to_append.append(offset)\n        elif o_ttype == 'LABEL_USE':\n            i = 0x1f\n            addr = labels.get(o_token)\n            if addr is None:\n                pos = len(result) + 1\n                labels_to_update.setdefault(o_token, []).append(pos)\n            to_append.append(addr)\n        return i\n\n    for ttype, token in emitter:\n        to_append[:] = []\n        if ttype == 'LABEL_DEF':\n            addr = labels[token] = len(result)\n            for pos in labels_to_update.get(token, []):\n                result[pos] = addr\n        elif ttype == 'OPCODE':\n            current_word = opcodes.index(token) + 1\n            shift = 0\n            for o_ttype, o_token in [emitter.next(), emitter.next()]:\n                i = get_i(o_ttype, o_token)\n                current_word += i << (4 + 6 * shift)\n                shift += 1\n            result.append(current_word)\n            result.extend(to_append)\n        elif ttype == 'OPCODE_NB':\n            index = nonbasic_opcodes.index(token) + 1\n            current_word = index << 4\n            o_ttype, o_token = emitter.next()\n            i = get_i(o_ttype, o_token)\n            current_word += i << 10\n            result.append(current_word)\n            result.extend(to_append)\n    return result\n\n\ndef pprint(words):\n    f = '%0.4x'\n    wrds = words\n    if len(words) % 8:\n        wrds = words + [0] * (8 - len(words) % 8)\n    for x in range(0, len(wrds), 8):\n        print f % x + ':', ' '.join(f % w for w in wrds[x:x + 8])\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='A simple Python-based DCPU assembly compiler'\n     )\n    parser.add_argument(\n        'source', metavar='IN', type=str, nargs=1,\n        help='file path of the file containing the assembly code'\n    )\n    parser.add_argument(\n        'destination', metavar='OUT', type=str, nargs='?',\n        help='file path where to store the binary code'\n    )\n    args = parser.parse_args()\n\n    c = compile(open(args.source[0]).read())\n    if args.destination is None:\n        return pprint(c)\n\n    assert sys.byteorder == 'little'\n    out = open(args.destination, 'wb')\n    c = [struct.pack('>H', b) for b in c]\n    out.write(''.join(c))\n    out.close()\n\n\nif __name__ == '__main__':\n    main()\n"
u"1226,def emit_from_str(code):\n    for line in code.split('\\n'):\n        parsed_line = re_row.match(line)\n        if parsed_line is None:\n            print 'error found on line: %s' % line\n            exit(1)\n        for token in emit_from_line(parsed_line.groups()):\n            yield token\n"
u"1227,def emit_from_line(line):\n    if line[0]:\n        yield ('LABEL_DEF', line[0][1:])\n    if line[3]:\n        yield ('OPCODE', line[3])\n        for token in emit_from_op(line[4:14]):\n            yield token\n        for token in emit_from_op(line[14:24]):\n            yield token\n    if line[24]:\n        yield ('OPCODE_NB', line[25])\n        for token in emit_from_op(line[26:36]):\n            yield token\n    if line[36]:\n        yield ('COMMENT', line[36][1:])\n"
u"1228,def emit_from_op(op):\n    if op[1]:\n        yield ('CONST', int(op[1], 0))\n    elif op[2]:\n        yield ('CONST_DEREF', int(op[2][1:-1], 0))\n    elif op[3]:\n        yield ('REGISTRY', op[3])\n    elif op[4]:\n        yield ('REGISTRY_DEREF', op[4][1:-1])\n    elif op[5]:\n        yield ('OFFSET', (int(op[6], 0), op[7]))\n    elif op[8]:\n        yield ('CONST', int(op[8]))\n    elif op[9]:\n        yield ('LABEL_USE', op[9])\n"
u"1229,def compile(source):\n    result = []\n    emitter = emit_from_str(source)\n    labels = {}\n    labels_to_update = {}\n    to_append = []\n\n    def get_i(o_ttype, o_token):\n        if o_ttype == 'CONST':\n            i = o_token + 0x20\n            if o_token > 0x1f:\n                i = 0x1f\n                to_append.append(o_token)\n        elif o_ttype == 'CONST_DEREF':\n            i = 0x1e\n            to_append.append(o_token)\n        elif o_ttype == 'REGISTRY':\n            i = pointers.index(o_token)\n            if i >= 8:\n                i += 0x10\n        elif o_ttype == 'REGISTRY_DEREF':\n            i = pointers.index(o_token) + 0x08\n        elif o_ttype == 'OFFSET':\n            offset, reg = o_token\n            i = pointers.index(reg) + 0x10\n            to_append.append(offset)\n        elif o_ttype == 'LABEL_USE':\n            i = 0x1f\n            addr = labels.get(o_token)\n            if addr is None:\n                pos = len(result) + 1\n                labels_to_update.setdefault(o_token, []).append(pos)\n            to_append.append(addr)\n        return i\n\n    for ttype, token in emitter:\n        to_append[:] = []\n        if ttype == 'LABEL_DEF':\n            addr = labels[token] = len(result)\n            for pos in labels_to_update.get(token, []):\n                result[pos] = addr\n        elif ttype == 'OPCODE':\n            current_word = opcodes.index(token) + 1\n            shift = 0\n            for o_ttype, o_token in [emitter.next(), emitter.next()]:\n                i = get_i(o_ttype, o_token)\n                current_word += i << (4 + 6 * shift)\n                shift += 1\n            result.append(current_word)\n            result.extend(to_append)\n        elif ttype == 'OPCODE_NB':\n            index = nonbasic_opcodes.index(token) + 1\n            current_word = index << 4\n            o_ttype, o_token = emitter.next()\n            i = get_i(o_ttype, o_token)\n            current_word += i << 10\n            result.append(current_word)\n            result.extend(to_append)\n    return result\n"
u"1230,def pprint(words):\n    f = '%0.4x'\n    wrds = words\n    if len(words) % 8:\n        wrds = words + [0] * (8 - len(words) % 8)\n    for x in range(0, len(wrds), 8):\n        print f % x + ':', ' '.join(f % w for w in wrds[x:x + 8])\n"
u"1231,def main():\n    parser = argparse.ArgumentParser(\n        description='A simple Python-based DCPU assembly compiler'\n     )\n    parser.add_argument(\n        'source', metavar='IN', type=str, nargs=1,\n        help='file path of the file containing the assembly code'\n    )\n    parser.add_argument(\n        'destination', metavar='OUT', type=str, nargs='?',\n        help='file path where to store the binary code'\n    )\n    args = parser.parse_args()\n\n    c = compile(open(args.source[0]).read())\n    if args.destination is None:\n        return pprint(c)\n\n    assert sys.byteorder == 'little'\n    out = open(args.destination, 'wb')\n    c = [struct.pack('>H', b) for b in c]\n    out.write(''.join(c))\n    out.close()\n"
u"1232,    def get_i(o_ttype, o_token):\n        if o_ttype == 'CONST':\n            i = o_token + 0x20\n            if o_token > 0x1f:\n                i = 0x1f\n                to_append.append(o_token)\n        elif o_ttype == 'CONST_DEREF':\n            i = 0x1e\n            to_append.append(o_token)\n        elif o_ttype == 'REGISTRY':\n            i = pointers.index(o_token)\n            if i >= 8:\n                i += 0x10\n        elif o_ttype == 'REGISTRY_DEREF':\n            i = pointers.index(o_token) + 0x08\n        elif o_ttype == 'OFFSET':\n            offset, reg = o_token\n            i = pointers.index(reg) + 0x10\n            to_append.append(offset)\n        elif o_ttype == 'LABEL_USE':\n            i = 0x1f\n            addr = labels.get(o_token)\n            if addr is None:\n                pos = len(result) + 1\n                labels_to_update.setdefault(o_token, []).append(pos)\n            to_append.append(addr)\n        return i\n"
u'1233,#!/usr/bin/env python\n\nfrom setuptools import setup\n\nsetup(\n\n    name=\'0x10c-asm\',\n    version=\'0.0.2\',\n    description="A simple Python-based DCPU assembly compiler",\n    long_description=open(\'README.rst\').read(),\n    keywords=\'notch asm dcpu-16 dcpu assembly asm\',\n    author=\'Sever Banesiu\',\n    author_email=\'banesiu.sever@gmail.com\',\n    url=\'https://github.com/severb/0x10c-asm\',\n    license=\'BSD License\',\n    scripts=[\'0x10c-asm.py\'],\n    zip_safe=False,\n\n)\n'
u'1234,from setuptools import setup, find_packages\n\n\nsetup(\n    name=\'115wangpan\',\n    version=\'0.7.6\',\n    description="Unofficial Python API wrapper for 115.com",\n    long_description=open(\'README.rst\').read(),\n    keywords=\'115 wangpan pan cloud lixian\',\n    author=\'Shichao An\',\n    author_email=\'shichao.an@nyu.edu\',\n    url=\'https://github.com/shichao-an/115wangpan\',\n    license=\'BSD\',\n    install_requires=open(\'requirements.txt\').read().splitlines(),\n    packages=find_packages(exclude=[\'tests\', \'docs\']),\n    scripts=[\n        \'bin/115\',\n        \'bin/115down\',\n        \'bin/115up\',\n    ],\n    include_package_data=True,\n    zip_safe=False,\n    classifiers=[\n        "License :: OSI Approved :: BSD License",\n        "Programming Language :: Python",\n        "Programming Language :: Python :: 2",\n        "Programming Language :: Python :: 3",\n    ],\n)\n'
u"1235,# -*-COMMENT utf-8 -*-\n# flake8: noqa\n__version__ = '0.7.6'\nfrom u115.api import (API, Passport, RequestHandler, Request, Response,\n                      RequestsLWPCookieJar, RequestsMozillaCookieJar,\n                      Torrent, Task, TorrentFile, File, Directory,\n                      APIError, TaskError, AuthenticationError,\n                      InvalidAPIAccess, RequestFailure, JobError)\n"
u'1236,# -*-COMMENT utf-8 -*-\nfrom __future__ import print_function, absolute_import\n\nimport humanize\nimport inspect\nimport json\nimport logging\nimport os\nimport re\nimport requests\nimport time\nfrom hashlib import sha1\nfrom bs4 import BeautifulSoup\nfrom requests.cookies import RequestsCookieJar\nfrom u115 import conf\nfrom u115.utils import (get_timestamp, get_utcdatetime, string_to_datetime,\n                        eval_path, quote, unquote, utf8_encode, txt_type, PY3)\nfrom homura import download\n\nif PY3:\n    from http import cookiejar as cookielib\nelse:\n    import cookielib\n\nUSER_AGENT = \'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_4) \\\nAppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.94 Safari/537.36\'\nLOGIN_URL = \'http://passport.115.com/?ct=login&ac=ajax&is_ssl=1\'\nLOGOUT_URL = \'http://passport.115.com/?ac=logout\'\nCHECKPOINT_URL = \'http://passport.115.com/?ct=ajax&ac=ajax_check_point\'\n\n\nclass RequestsLWPCookieJar(cookielib.LWPCookieJar, RequestsCookieJar):\n    """:class:`requests.cookies.RequestsCookieJar` compatible\n    :class:`cookielib.LWPCookieJar`"""\n    pass\n\n\nclass RequestsMozillaCookieJar(cookielib.MozillaCookieJar, RequestsCookieJar):\n    """:class:`requests.cookies.RequestsCookieJar` compatible\n    :class:`cookielib.MozillaCookieJar`"""\n    pass\n\n\nclass RequestHandler(object):\n    """\n    Request handler that maintains session\n\n    :ivar session: underlying :class:`requests.Session` instance\n\n    """\n\n    def __init__(self):\n        self.session = requests.Session()\n        self.session.headers[\'User-Agent\'] = USER_AGENT\n\n    def get(self, url, params=None):\n        """\n        Initiate a GET request\n        """\n        r = self.session.get(url, params=params)\n        return self._response_parser(r, expect_json=False)\n\n    def post(self, url, data, params=None):\n        """\n        Initiate a POST request\n        """\n        r = self.session.post(url, data=data, params=params)\n        return self._response_parser(r, expect_json=False)\n\n    def send(self, request, expect_json=True, ignore_content=False):\n        """\n        Send a formatted API request\n\n        :param request: a formatted request object\n        :type request: :class:`.Request`\n        :param bool expect_json: if True, raise :class:`.InvalidAPIAccess` if\n            response is not in JSON format\n        :param bool ignore_content: whether to ignore setting content of the\n            Response object\n        """\n        r = self.session.request(method=request.method,\n                                 url=request.url,\n                                 params=request.params,\n                                 data=request.data,\n                                 files=request.files,\n                                 headers=request.headers)\n        return self._response_parser(r, expect_json, ignore_content)\n\n    def _response_parser(self, r, expect_json=True, ignore_content=False):\n        """\n        :param :class:`requests.Response` r: a response object of the Requests\n            library\n        :param bool expect_json: if True, raise :class:`.InvalidAPIAccess` if\n            response is not in JSON format\n        :param bool ignore_content: whether to ignore setting content of the\n            Response object\n        """\n        if r.ok:\n            try:\n                j = r.json()\n                return Response(j.get(\'state\'), j)\n            except ValueError:\n                # No JSON-encoded data returned\n                if expect_json:\n                    logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n                    logger.debug(r.text)\n                    raise InvalidAPIAccess(\'Invalid API access.\')\n                # Raw response\n                if ignore_content:\n                    res = Response(True, None)\n                else:\n                    res = Response(True, r.text)\n                return res\n        else:\n            r.raise_for_status()\n\n\nclass Request(object):\n    """Formatted API request class"""\n\n    def __init__(self, url, method=\'GET\', params=None, data=None,\n                 files=None, headers=None):\n        """\n        Create a Request object\n\n        :param str url: URL\n        :param str method: request method\n        :param dict params: request parameters\n        :param dict data: form data\n        :param dict files: mulitpart form data\n        :param dict headers: custom request headers\n\n        """\n        self.url = url\n        self.method = method\n        self.params = params\n        self.data = data\n        self.files = files\n        self.headers = headers\n        self._debug()\n\n    def _debug(self):\n        logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n        level = logger.getEffectiveLevel()\n        if level == logging.DEBUG:\n            func = inspect.stack()[2][3]\n            msg = conf.DEBUG_REQ_FMT % (func, self.url, self.method,\n                                        self.params, self.data)\n            logger.debug(msg)\n\n\nclass Response(object):\n    """\n    Formatted API response class\n\n    :ivar bool state: whether API access is successful\n    :ivar dict content: result content\n    """\n\n    def __init__(self, state, content):\n        self.state = state\n        self.content = content\n        self._debug()\n\n    def _debug(self):\n        logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n        level = logger.getEffectiveLevel()\n        if level == logging.DEBUG:\n            func = inspect.stack()[4][3]\n            msg = conf.DEBUG_RES_FMT % (func, self.state, self.content)\n            logger.debug(msg)\n\n\nclass API(object):\n    """\n    Request and response interface\n\n    :ivar passport: :class:`.Passport` object associated with this interface\n    :ivar http: :class:`.RequestHandler` object associated with this\n        interface\n    :cvar int num_tasks_per_page: default number of tasks per page/request\n    :cvar str web_api_url: files API url\n    :cvar str aps_natsort_url: natural sort files API url\n    :cvar str proapi_url: pro API url for downloads\n    """\n\n    num_tasks_per_page = 30\n    web_api_url = \'http://web.api.115.com/files\'\n    aps_natsort_url = \'http://aps.115.com/natsort/files.php\'\n    proapi_url = \'http://proapi.115.com/app/chrome/down\'\n    referer_url = \'http://115.com\'\n\n    def __init__(self, persistent=False,\n                 cookies_filename=None, cookies_type=\'LWPCookieJar\'):\n        """\n        :param bool auto_logout: whether to logout automatically when\n            :class:`.API` object is destroyed\n\n                                 .. deprecated:: 0.6.0\n                                     Call :meth:`.API.logout` explicitly\n\n        :param bool persistent: whether to use persistent session that stores\n            cookies on disk\n        :param str cookies_filename: path to the cookies file, use default\n            path (`~/.115cookies`) if None\n        :param str cookies_type: a string representing\n            :class:`cookielib.FileCookieJar` subclass,\n            `LWPCookieJar` (default) or `MozillaCookieJar`\n        """\n        self.persistent = persistent\n        self.cookies_filename = cookies_filename\n        self.cookies_type = cookies_type\n        self.passport = None\n        self.http = RequestHandler()\n        self.logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n        # Cache attributes to decrease API hits\n        self._user_id = None\n        self._username = None\n        self._signatures = {}\n        self._upload_url = None\n        self._lixian_timestamp = None\n        self._root_directory = None\n        self._downloads_directory = None\n        self._receiver_directory = None\n        self._torrents_directory = None\n        self._task_count = None\n        self._task_quota = None\n        if self.persistent:\n            self.load_cookies()\n\n    def _reset_cache(self):\n        self._user_id = None\n        self._username = None\n        self._signatures = {}\n        self._upload_url = None\n        self._lixian_timestamp = None\n        self._root_directory = None\n        self._downloads_directory = None\n        self._receiver_directory = None\n        self._torrents_directory = None\n        self._task_count = None\n        self._task_quota = None\n\n    def _init_cookies(self):\n        # RequestsLWPCookieJar or RequestsMozillaCookieJar\n        cookies_class = globals()[\'Requests\' + self.cookies_type]\n        f = self.cookies_filename or conf.COOKIES_FILENAME\n        self.cookies = cookies_class(f)\n\n    def load_cookies(self, ignore_discard=True, ignore_expires=True):\n        """Load cookies from the file :attr:`.API.cookies_filename`"""\n        self._init_cookies()\n        if os.path.exists(self.cookies.filename):\n            self.cookies.load(ignore_discard=ignore_discard,\n                              ignore_expires=ignore_expires)\n            self._reset_cache()\n\n    def save_cookies(self, ignore_discard=True, ignore_expires=True):\n        """Save cookies to the file :attr:`.API.cookies_filename`"""\n        if not isinstance(self.cookies, cookielib.FileCookieJar):\n            m = \'Cookies must be a cookielib.FileCookieJar object to be saved.\'\n            raise APIError(m)\n        self.cookies.save(ignore_discard=ignore_discard,\n                          ignore_expires=ignore_expires)\n\n    @property\n    def cookies(self):\n        """\n        Cookies of the current API session (cookies getter shortcut)\n        """\n        return self.http.session.cookies\n\n    @cookies.setter\n    def cookies(self, cookies):\n        """\n        Cookies of the current API session (cookies setter shortcut)\n        """\n        self.http.session.cookies = cookies\n\n    def login(self, username=None, password=None,\n              section=\'default\'):\n        """\n        Created the passport with ``username`` and ``password`` and log in.\n        If either ``username`` or ``password`` is None or omitted, the\n        credentials file will be parsed.\n\n        :param str username: username to login (email, phone number or user ID)\n        :param str password: password\n        :param str section: section name in the credential file\n        :raise: raises :class:`.AuthenticationError` if failed to login\n        """\n        if self.has_logged_in:\n            return True\n        if username is None or password is None:\n            credential = conf.get_credential(section)\n            username = credential[\'username\']\n            password = credential[\'password\']\n\n        passport = Passport(username, password)\n        r = self.http.post(LOGIN_URL, passport.form)\n\n        if r.state is True:\n            # Bind this passport to API\n            self.passport = passport\n            passport.data = r.content[\'data\']\n            self._user_id = r.content[\'data\'][\'USER_ID\']\n            return True\n        else:\n            msg = None\n            if \'err_name\' in r.content:\n                if r.content[\'err_name\'] == \'account\':\n                    msg = \'Account does not exist.\'\n                elif r.content[\'err_name\'] == \'passwd\':\n                    msg = \'Password is incorrect.\'\n            raise AuthenticationError(msg)\n\n    def get_user_info(self):\n        """\n        Get user info\n\n        :return: a dictionary of user information\n        :rtype: dict\n\n        """\n        return self._req_get_user_aq()\n\n    @property\n    def user_id(self):\n        """\n        User id of the current API user\n        """\n        if self._user_id is None:\n            if self.has_logged_in:\n                self._user_id = self._req_get_user_aq()[\'data\'][\'uid\']\n            else:\n                raise AuthenticationError(\'Not logged in.\')\n        return self._user_id\n\n    @property\n    def username(self):\n        """\n        Username of the current API user\n        """\n        if self._username is None:\n            if self.has_logged_in:\n                self._username = self._get_username()\n            else:\n                raise AuthenticationError(\'Not logged in.\')\n        return self._username\n\n    @property\n    def has_logged_in(self):\n        """Check whether the API has logged in"""\n        r = self.http.get(CHECKPOINT_URL)\n        if r.state is False:\n            return True\n        # If logged out, flush cache\n        self._reset_cache()\n        return False\n\n    def logout(self):\n        """Log out"""\n        self.http.get(LOGOUT_URL)\n        self._reset_cache()\n        return True\n\n    @property\n    def root_directory(self):\n        """Root directory"""\n        if self._root_directory is None:\n            self._load_root_directory()\n        return self._root_directory\n\n    @property\n    def downloads_directory(self):\n        """Default directory for downloaded files"""\n        if self._downloads_directory is None:\n            self._load_downloads_directory()\n        return self._downloads_directory\n\n    @property\n    def receiver_directory(self):\n        """Parent directory of the downloads directory"""\n        if self._receiver_directory is None:\n            self._receiver_directory = self.downloads_directory.parent\n        return self._receiver_directory\n\n    @property\n    def torrents_directory(self):\n        """Default directory that stores uploaded torrents"""\n        if self._torrents_directory is None:\n            self._load_torrents_directory()\n        return self._torrents_directory\n\n    @property\n    def task_count(self):\n        """\n        Number of tasks created\n        """\n        self._req_lixian_task_lists()\n        return self._task_count\n\n    @property\n    def task_quota(self):\n        """\n        Task quota (monthly)\n        """\n        self._req_lixian_task_lists()\n        return self._task_quota\n\n    def get_tasks(self, count=30):\n        """\n        Get ``count`` number of tasks\n\n        :param int count: number of tasks to get\n        :return: a list of :class:`.Task` objects\n        """\n\n        return self._load_tasks(count)\n\n    def add_task_bt(self, filename, select=False):\n        """\n        Add a new BT task\n\n        :param str filename: path to torrent file to upload\n        :param bool select: whether to select files in the torrent.\n\n            * True: it returns the opened torrent (:class:`.Torrent`) and\n                can then iterate files in :attr:`.Torrent.files` and\n                select/unselect them before calling :meth:`.Torrent.submit`\n            * False: it will submit the torrent with default selected files\n\n        """\n        filename = eval_path(filename)\n        u = self.upload(filename, self.torrents_directory)\n        t = self._load_torrent(u)\n        if select:\n            return t\n        return t.submit()\n\n    def add_task_url(self, target_url):\n        """\n        Add a new URL task\n\n        :param str target_url: the URL of the file that to be downloaded\n\n        """\n        return self._req_lixian_add_task_url(target_url)\n\n    def get_storage_info(self, human=False):\n        """\n        Get storage info\n\n        :param bool human: whether return human-readable size\n        :return: total and used storage\n        :rtype: dict\n\n        """\n        res = self._req_get_storage_info()\n        if human:\n            res[\'total\'] = humanize.naturalsize(res[\'total\'], binary=True)\n            res[\'used\'] = humanize.naturalsize(res[\'used\'], binary=True)\n        return res\n\n    def upload(self, filename, directory=None):\n        """\n        Upload a file ``filename`` to ``directory``\n\n        :param str filename: path to the file to upload\n        :param directory: destionation :class:`.Directory`, defaults to\n            :attribute:`.API.downloads_directory` if None\n        :return: the uploaded file\n        :rtype: :class:`.File`\n        """\n        filename = eval_path(filename)\n        if directory is None:\n            directory = self.downloads_directory\n\n        # First request\n        res1 = self._req_upload(filename, directory)\n        data1 = res1[\'data\']\n        file_id = data1[\'file_id\']\n\n        # Second request\n        res2 = self._req_file(file_id)\n        data2 = res2[\'data\'][0]\n        data2.update(**data1)\n        return _instantiate_uploaded_file(self, data2)\n\n    def download(self, obj, path=None, show_progress=True, resume=True,\n                 auto_retry=True, proapi=False):\n        """\n        Download a file\n\n        :param obj: :class:`.File` object\n        :param str path: local path\n        :param bool show_progress: whether to show download progress\n        :param bool resume: whether to resume on unfinished downloads\n            identified by filename\n        :param bool auto_retry: whether to retry automatically upon closed\n            transfer until the file\'s download is finished\n        :param bool proapi: whether to use pro API\n        """\n        url = obj.get_download_url(proapi)\n        download(url, path=path, session=self.http.session,\n                 show_progress=show_progress, resume=resume,\n                 auto_retry=auto_retry)\n\n    def search(self, keyword, count=30):\n        """\n        Search files or directories\n\n        :param str keyword: keyword\n        :param int count: number of entries to be listed\n        """\n        kwargs = {}\n        kwargs[\'search_value\'] = keyword\n        root = self.root_directory\n        entries = root._load_entries(func=self._req_files_search,\n                                     count=count, page=1, **kwargs)\n\n        res = []\n        for entry in entries:\n            if \'pid\' in entry:\n                res.append(_instantiate_directory(self, entry))\n            else:\n                res.append(_instantiate_file(self, entry))\n        return res\n\n    def move(self, entries, directory):\n        """\n        Move one or more entries (file or directory) to the destination\n        directory\n\n        :param list entries: a list of source entries (:class:`.BaseFile`\n            object)\n        :param directory: destination directory\n        :return: whether the action is successful\n        :raise: :class:`.APIError` if something bad happened\n        """\n        fcids = []\n        for entry in entries:\n            if isinstance(entry, File):\n                fcid = entry.fid\n            elif isinstance(entry, Directory):\n                fcid = entry.cid\n            else:\n                raise APIError(\'Invalid BaseFile instance for an entry.\')\n            fcids.append(fcid)\n        if not isinstance(directory, Directory):\n            raise APIError(\'Invalid destination directory.\')\n        if self._req_files_move(directory.cid, fcids):\n            for entry in entries:\n                if isinstance(entry, File):\n                    entry.cid = directory.cid\n                entry.reload()\n            return True\n        else:\n            raise APIError(\'Error moving entries.\')\n\n    def edit(self, entry, name, mark=False):\n        """\n        Edit an entry (file or directory)\n\n        :param entry: :class:`.BaseFile` object\n        :param str name: new name for the entry\n        :param bool mark: whether to bookmark the entry\n        """\n        fcid = None\n        if isinstance(entry, File):\n            fcid = entry.fid\n        elif isinstance(entry, Directory):\n            fcid = entry.cid\n        else:\n            raise APIError(\'Invalid BaseFile instance for an entry.\')\n        is_mark = 0\n        if mark is True:\n            is_mark = 1\n        if self._req_files_edit(fcid, name, is_mark):\n            entry.reload()\n            return True\n        else:\n            raise APIError(\'Error editing the entry.\')\n\n    def mkdir(self, parent, name):\n        """\n        Create a directory\n\n        :param parent: the parent directory\n        :param str name: the name of the new directory\n        :return: the new directory\n        :rtype: :class:`.Directory`\n\n        """\n        pid = None\n        cid = None\n        if isinstance(parent, Directory):\n            pid = parent.cid\n        else:\n            raise(\'Invalid Directory instance.\')\n        cid = self._req_files_add(pid, name)[\'cid\']\n        return self._load_directory(cid)\n\n    def _req_offline_space(self):\n        """Required before accessing lixian tasks"""\n        url = \'http://115.com/\'\n        params = {\n            \'ct\': \'offline\',\n            \'ac\': \'space\',\n            \'_\': get_timestamp(13)\n        }\n        _sign = os.environ.get(\'U115_BROWSER_SIGN\')\n        if _sign is not None:\n            _time = os.environ.get(\'U115_BROWSER_TIME\')\n            if _time is None:\n                msg = \'U115_BROWSER_TIME is required given U115_BROWSER_SIGN.\'\n                raise APIError(msg)\n            params[\'sign\'] = _sign\n            params[\'time\'] = _time\n            params[\'uid\'] = self.user_id\n        req = Request(url=url, params=params)\n        r = self.http.send(req)\n        if r.state:\n            self._signatures[\'offline_space\'] = r.content[\'sign\']\n            self._lixian_timestamp = r.content[\'time\']\n        else:\n            msg = \'Failed to retrieve signatures.\'\n            raise RequestFailure(msg)\n\n    def _req_lixian_task_lists(self, page=1):\n        """\n        This request will cause the system to create a default downloads\n        directory if it does not exist\n        """\n        url = \'http://115.com/lixian/\'\n        params = {\'ct\': \'lixian\', \'ac\': \'task_lists\'}\n        self._load_signatures()\n        data = {\n            \'page\': page,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            self._task_count = res.content[\'count\']\n            self._task_quota = res.content[\'quota\']\n            return res.content[\'tasks\']\n        else:\n            msg = \'Failed to get tasks.\'\n            raise RequestFailure(msg)\n\n    def _req_lixian_get_id(self, torrent=False):\n        """Get `cid` of lixian space directory"""\n        url = \'http://115.com/\'\n        params = {\n            \'ct\': \'lixian\',\n            \'ac\': \'get_id\',\n            \'torrent\': 1 if torrent else None,\n            \'_\': get_timestamp(13)\n        }\n        req = Request(method=\'GET\', url=url, params=params)\n        res = self.http.send(req)\n        return res.content\n\n    def _req_lixian_torrent(self, u):\n        """\n        :param u: uploaded torrent file\n        """\n\n        self._load_signatures()\n        url = \'http://115.com/lixian/\'\n        params = {\n            \'ct\': \'lixian\',\n            \'ac\': \'torrent\',\n        }\n        data = {\n            \'pickcode\': u.pickcode,\n            \'sha1\': u.sha,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            msg = res.content.get(\'error_msg\')\n            self.logger.error(msg)\n            raise RequestFailure(\'Failed to open torrent.\')\n\n    def _req_lixian_add_task_bt(self, t):\n\n        self._load_signatures()\n        url = \'http://115.com/lixian/\'\n        params = {\'ct\': \'lixian\', \'ac\': \'add_task_bt\'}\n        _wanted = []\n        for i, b in enumerate(t.files):\n            if b.selected:\n                _wanted.append(str(i))\n        wanted = \',\'.join(_wanted)\n        data = {\n            \'info_hash\': t.info_hash,\n            \'wanted\': wanted,\n            \'savepath\': t.name,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            msg = res.content.get(\'error_msg\')\n            self.logger.error(msg)\n            raise RequestFailure(\'Failed to create new task.\')\n\n    def _req_lixian_add_task_url(self, target_url):\n\n        self._load_signatures()\n        url = \'http://115.com/lixian/\'\n        params = {\'ct\': \'lixian\', \'ac\': \'add_task_url\'}\n        data = {\n            \'url\': target_url,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            msg = res.content.get(\'error_msg\')\n            self.logger.error(msg)\n            raise RequestFailure(\'Failed to create new task.\')\n\n    def _req_lixian_task_del(self, t):\n\n        self._load_signatures()\n        url = \'http://115.com/lixian/\'\n        params = {\'ct\': \'lixian\', \'ac\': \'task_del\'}\n        data = {\n            \'hash[0]\': t.info_hash,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure(\'Failed to delete the task.\')\n\n    def _req_file_userfile(self):\n\n        url = \'http://115.com/\'\n        params = {\n            \'ct\': \'file\',\n            \'ac\': \'userfile\',\n            \'is_wl_tpl\': 1,\n        }\n        req = Request(method=\'GET\', url=url, params=params)\n        self.http.send(req, expect_json=False, ignore_content=True)\n\n    def _req_aps_natsort_files(self, cid, offset, limit, o=\'file_name\',\n                               asc=1, aid=1, show_dir=1, code=None, scid=None,\n                               snap=0, natsort=1, source=None, type=0,\n                               format=\'json\', star=None, is_share=None):\n        """\n        When :meth:`.API._req_files` is called with `o=\'filename\'` and\n            `natsort=1`, API access will fail\n            and :meth:`.API._req_aps_natsort_files` is subsequently called with\n            the same kwargs. Refer to the implementation in\n            :meth:`.Directory.list`\n        """\n        params = locals()\n        del params[\'self\']\n        req = Request(method=\'GET\', url=self.aps_natsort_url, params=params)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files(self, cid, offset, limit, o=\'user_ptime\', asc=1, aid=1,\n                   show_dir=1, code=None, scid=None, snap=0, natsort=1,\n                   source=None, type=0, format=\'json\', star=None,\n                   is_share=None):\n        """\n        :param int type: type of files to be displayed\n\n            * \'\' (empty string): marked\n            * None: all\n            * 0: all\n            * 1: documents\n            * 2: images\n            * 3: music\n            * 4: video\n            * 5: zipped\n            * 6: applications\n            * 99: files only\n        """\n        params = locals()\n        del params[\'self\']\n        req = Request(method=\'GET\', url=self.web_api_url, params=params)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files_search(self, offset, limit, search_value, aid=-1,\n                          date=None, pick_code=None, source=None, type=0,\n                          format=\'json\'):\n        params = locals()\n        del params[\'self\']\n        url = self.web_api_url + \'/search\'\n        req = Request(method=\'GET\', url=url, params=params)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files_edit(self, fid, file_name=None, is_mark=0):\n        """Edit a file or directory"""\n        url = self.web_api_url + \'/edit\'\n        data = locals()\n        del data[\'self\']\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files_add(self, pid, cname):\n        """\n        Add a directory\n        :param str pid: parent directory id\n        :param str cname: directory name\n        """\n        url = self.web_api_url + \'/add\'\n        data = locals()\n        del data[\'self\']\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files_move(self, pid, fids):\n        """\n        Move files or directories\n        :param str pid: destination directory id\n        :param list fids: a list of ids of files or directories to be moved\n        """\n        url = self.web_api_url + \'/move\'\n        data = {}\n        data[\'pid\'] = pid\n        for i, fid in enumerate(fids):\n            data[\'fid[%d]\' % i] = fid\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_file(self, file_id):\n        url = self.web_api_url + \'/file\'\n        data = {\'file_id\': file_id}\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_directory(self, cid):\n        """Return name and pid of by cid"""\n        res = self._req_files(cid=cid, offset=0, limit=1, show_dir=1)\n        path = res[\'path\']\n        count = res[\'count\']\n        for d in path:\n            if str(d[\'cid\']) == str(cid):\n                res = {\n                    \'cid\': d[\'cid\'],\n                    \'name\': d[\'name\'],\n                    \'pid\': d[\'pid\'],\n                    \'count\': count,\n                }\n                return res\n        else:\n            raise RequestFailure(\'No directory found.\')\n\n    def _req_files_download_url(self, pickcode, proapi=False):\n        if \'_115_curtime\' not in self.cookies:\n            self._req_file_userfile()\n        if not proapi:\n            url = self.web_api_url + \'/download\'\n            params = {\'pickcode\': pickcode, \'_\': get_timestamp(13)}\n        else:\n            url = self.proapi_url\n            params = {\'pickcode\': pickcode, \'method\': \'get_file_url\'}\n        headers = {\n            \'Referer\': self.referer_url,\n        }\n        req = Request(method=\'GET\', url=url, params=params,\n                      headers=headers)\n        res = self.http.send(req)\n        if res.state:\n            if not proapi:\n                return res.content[\'file_url\']\n            else:\n                fid = res.content[\'data\'].keys()[0]\n                return res.content[\'data\'][fid][\'url\'][\'url\']\n        else:\n            raise RequestFailure(\'Failed to get download URL.\')\n\n    def _req_get_storage_info(self):\n        url = \'http://115.com\'\n        params = {\n            \'ct\': \'ajax\',\n            \'ac\': \'get_storage_info\',\n            \'_\': get_timestamp(13),\n        }\n        req = Request(method=\'GET\', url=url, params=params)\n        res = self.http.send(req)\n        return res.content[\'1\']\n\n    def _req_upload(self, filename, directory):\n        """Raw request to upload a file ``filename``"""\n        self._upload_url = self._load_upload_url()\n        self.http.get(\'http://upload.115.com/crossdomain.xml\')\n        b = os.path.basename(filename)\n        target = \'U_1_\' + str(directory.cid)\n        files = {\n            \'Filename\': (\'\', quote(b), \'\'),\n            \'target\': (\'\', target, \'\'),\n            \'Filedata\': (quote(b), open(filename, \'rb\'), \'\'),\n            \'Upload\': (\'\', \'Submit Query\', \'\'),\n        }\n        req = Request(method=\'POST\', url=self._upload_url, files=files)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            msg = None\n            if res.content[\'code\'] == 990002:\n                msg = \'Invalid parameter.\'\n            elif res.content[\'code\'] == 1001:\n                msg = \'Torrent upload failed. Please try again later.\'\n            raise RequestFailure(msg)\n\n    def _req_rb_delete(self, fcid, pid):\n\n        url = \'http://web.api.115.com/rb/delete\'\n        data = {\n            \'pid\': pid,\n            \'fid[0]\': fcid,\n        }\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            msg = \'Failed to delete this file or directory.\'\n            if \'errno\' in res.content:\n                if res.content[\'errno\'] == 990005:\n                    raise JobError()\n            self.logger.error(res.content[\'error\'])\n            raise APIError(msg)\n\n    def _req_get_user_aq(self):\n        url = \'http://my.115.com/\'\n        data = {\n            \'ct\': \'ajax\',\n            \'ac\': \'get_user_aq\'\n        }\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n\n    def _load_signatures(self, force=True):\n        if not self._signatures or force:\n            self._req_offline_space()\n\n    def _load_tasks(self, count, page=1, tasks=None):\n        if tasks is None:\n            tasks = []\n        req_tasks = self._req_lixian_task_lists(page)\n        loaded_tasks = []\n        if req_tasks is not None:\n            loaded_tasks = [\n                _instantiate_task(self, t) for t in req_tasks[:count]\n            ]\n        if count <= self.num_tasks_per_page or req_tasks is None:\n            return tasks + loaded_tasks\n        else:\n            return self._load_tasks(count - self.num_tasks_per_page,\n                                    page + 1, tasks + loaded_tasks)\n\n    def _load_directory(self, cid):\n        kwargs = self._req_directory(cid)\n        if str(kwargs[\'pid\']) != str(cid):\n            return Directory(api=self, **kwargs)\n\n    def _load_root_directory(self):\n        """\n        Load root directory, which has a cid of 0\n        """\n        kwargs = self._req_directory(0)\n        self._root_directory = Directory(api=self, **kwargs)\n\n    def _load_torrents_directory(self):\n        """\n        Load torrents directory\n\n        If it does not exist yet, this request will cause the system to create\n        one\n        """\n        r = self._req_lixian_get_id(torrent=True)\n        self._downloads_directory = self._load_directory(r[\'cid\'])\n\n    def _load_downloads_directory(self):\n        """\n        Load downloads directory\n\n        If it does not exist yet, this request will cause the system to create\n        one\n        """\n        r = self._req_lixian_get_id(torrent=False)\n        self._downloads_directory = self._load_directory(r[\'cid\'])\n\n    def _load_upload_url(self):\n        res = self._parse_src_js_var(\'upload_config_h5\')\n        return res[\'url\']\n\n    def _load_torrent(self, u):\n        res = self._req_lixian_torrent(u)\n        return _instantiate_torrent(self, res)\n\n    def _parse_src_js_var(self, variable):\n        """Parse JavaScript variables in the source page"""\n\n        src_url = \'http://115.com\'\n        r = self.http.get(src_url)\n        soup = BeautifulSoup(r.content)\n        scripts = [script.text for script in soup.find_all(\'script\')]\n        text = \'\\n\'.join(scripts)\n        pattern = "%s\\s*=\\s*(.*);" % (variable.upper())\n        m = re.search(pattern, text)\n        if not m:\n            msg = \'Cannot parse source JavaScript for %s.\' % variable\n            raise APIError(msg)\n        return json.loads(m.group(1).strip())\n\n    def _get_username(self):\n        return unquote(self.cookies.get(\'OOFL\'))\n\n\nclass Base(object):\n    def __repr__(self):\n        try:\n            u = self.__str__()\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            u = \'[Bad Unicode data]\'\n        repr_type = type(u)\n        return repr_type(\'<%s: %s>\' % (self.__class__.__name__, u))\n\n    def __str__(self):\n        if hasattr(self, \'__unicode__\'):\n            if PY3:\n                return self.__unicode__()\n            else:\n                return unicode(self).encode(\'utf-8\')\n        return txt_type(\'%s object\' % self.__class__.__name__)\n\n\nclass Passport(Base):\n    """\n    Passport for user authentication\n\n    :ivar str username: username\n    :ivar str password: user password\n    :ivar dict form: a dictionary of POST data to login\n    :ivar int user_id: user ID of the authenticated user\n    :ivar dict data: data returned upon login\n\n    """\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.form = self._form()\n        self.data = None\n\n    def _form(self):\n        vcode = self._vcode()\n        f = {\n            \'login[ssoent]\': \'A1\',\n            \'login[version]\': \'2.0\',\n            \'login[ssoext]\': vcode,\n            \'login[ssoln]\': self.username,\n            \'login[ssopw]\': self._ssopw(vcode),\n            \'login[ssovcode]\': vcode,\n            \'login[safe]\': \'1\',\n            \'login[time]\': \'0\',\n            \'login[safe_login]\': \'0\',\n            \'goto\': \'http://115.com/\',\n        }\n        return f\n\n    def _vcode(self):\n        s = \'%.6f\' % time.time()\n        whole, frac = map(int, s.split(\'.\'))\n        res = \'%.8x%.5x\' % (whole, frac)\n        return res\n\n    def _ssopw(self, vcode):\n        p = sha1(utf8_encode(self.password)).hexdigest()\n        u = sha1(utf8_encode(self.username)).hexdigest()\n        v = vcode.upper()\n        pu = sha1(utf8_encode(p + u)).hexdigest()\n        return sha1(utf8_encode(pu + v)).hexdigest()\n\n    def __unicode__(self):\n        return self.username\n\n\nclass BaseFile(Base):\n    def __init__(self, api, cid, name):\n        """\n        :param API api: associated API object\n        :param str cid: directory id\n\n            * For file: this represents the directory it belongs to;\n            * For directory: this represents itself\n\n        :param str name: originally named `n`\n\n        NOTICE\n            cid, fid and pid are in string format at this time\n        """\n        self.api = api\n        self.cid = cid\n        self.name = name\n        self._deleted = False\n\n    def delete(self):\n        """\n        Delete this file or directory\n\n        :return: whether deletion is successful\n        :raise: :class:`.APIError` if this file or directory is already deleted\n\n        """\n        fcid = None\n        pid = None\n\n        if isinstance(self, File):\n            fcid = self.fid\n            pid = self.cid\n        elif isinstance(self, Directory):\n            fcid = self.cid\n            pid = self.pid\n        else:\n            raise APIError(\'Invalid BaseFile instance.\')\n\n        if not self._deleted:\n            if self.api._req_rb_delete(fcid, pid):\n                self._deleted = True\n                return True\n        else:\n            raise APIError(\'This file or directory is already deleted.\')\n\n    def move(self, directory):\n        """\n        Move this file or directory to the destination directory\n\n        :param directory: destination directory\n        :return: whether the action is successful\n        :raise: :class:`.APIError` if something bad happened\n        """\n        self.api.move([self], directory)\n\n    def edit(self, name, mark=False):\n        """\n        Edit this file or directory\n\n        :param str name: new name for this entry\n        :param bool mark: whether to bookmark this entry\n        """\n        self.api.edit(self, name, mark)\n\n    @property\n    def is_deleted(self):\n        """Whether this file or directory is deleted"""\n        return self._deleted\n\n    def __eq__(self, other):\n        if isinstance(self, File):\n            if isinstance(other, File):\n                return self.fid == other.fid\n        elif isinstance(self, Directory):\n            if isinstance(other, Directory):\n                return self.cid == other.cid\n        return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __unicode__(self):\n        return self.name\n\n\nclass File(BaseFile):\n    """\n    File in a directory\n\n    :ivar int fid: file id\n    :ivar str cid: cid of the current directory\n    :ivar int size: size in bytes\n    :ivar str size_human: human-readable size\n    :ivar str file_type: originally named `ico`\n    :ivar str sha: SHA1 hash\n    :ivar datetime.datetime date_created: in "%Y-%m-%d %H:%M:%S" format,\n        originally named `t`\n    :ivar str thumbnail: thumbnail URL, originally named `u`\n    :ivar str pickcode: originally named `pc`\n    """\n\n    def __init__(self, api, fid, cid, name, size, file_type, sha,\n                 date_created, thumbnail, pickcode, *args, **kwargs):\n\n        super(File, self).__init__(api, cid, name)\n\n        self.fid = fid\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.file_type = file_type\n        self.sha = sha\n        self.date_created = date_created\n        self.thumbnail = thumbnail\n        self.pickcode = pickcode\n        self._directory = None\n        self._download_url = None\n\n    @property\n    def directory(self):\n        """Directory that holds this file"""\n        if self._directory is None:\n            self._directory = self.api._load_directory(self.cid)\n        return self._directory\n\n    def get_download_url(self, proapi=False):\n        """\n        Get this file\'s download URL\n\n        :param bool proapi: whether to use pro API\n\n        """\n        if self._download_url is None:\n            self._download_url = \\\n                self.api._req_files_download_url(self.pickcode, proapi)\n        return self._download_url\n\n    @property\n    def url(self):\n        """Alias for :meth:`.File.get_download_url` with `proapi=False`"""\n        return self.get_download_url()\n\n    def download(self, path=None, show_progress=True, resume=True,\n                 auto_retry=True, proapi=False):\n        """Download this file"""\n        self.api.download(self, path, show_progress, resume, auto_retry,\n                          proapi)\n\n    @property\n    def is_torrent(self):\n        """Whether the file is a torrent"""\n        return self.file_type == \'torrent\'\n\n    def open_torrent(self):\n        """\n        Open the torrent (if it is a torrent)\n\n        :return: opened torrent\n        :rtype: :class:`.Torrent`\n        """\n        if self.is_torrent:\n            return self.api._load_torrent(self)\n\n    def reload(self):\n        """\n        Reload file info and metadata\n\n        * name\n        * sha\n        * pickcode\n\n        """\n        res = self.api._req_file(self.fid)\n        data = res[\'data\'][0]\n        self.name = data[\'file_name\']\n        self.sha = data[\'sha1\']\n        self.pickcode = data[\'pick_code\']\n\n\nclass Directory(BaseFile):\n    """\n    :ivar str cid: cid of this directory\n    :ivar str pid: represents the parent directory it belongs to\n    :ivar int count: number of entries in this directory\n    :ivar datetime.datetime date_created: integer, originally named `t`\n    :ivar str pickcode: string, originally named `pc`\n\n    """\n\n    max_entries_per_load = 24  # Smaller than 24 may cause abnormal result\n\n    def __init__(self, api, cid, name, pid, count=-1,\n                 date_created=None, pickcode=None, is_root=False,\n                 *args, **kwargs):\n        super(Directory, self).__init__(api, cid, name)\n\n        self.pid = pid\n        self._count = count\n        if date_created is not None:\n            self.date_created = date_created\n        self.pickcode = pickcode\n        self._parent = None\n\n    @property\n    def is_root(self):\n        """Whether this directory is the root directory"""\n        return int(self.cid) == 0\n\n    @property\n    def parent(self):\n        """Parent directory that holds this directory"""\n        if self._parent is None:\n            if self.pid is not None:\n                self._parent = self.api._load_directory(self.pid)\n        return self._parent\n\n    @property\n    def count(self):\n        """Number of entries in this directory"""\n        if self._count == -1:\n            self.reload()\n        return self._count\n\n    def reload(self):\n        """\n        Reload directory info and metadata\n\n        * `name`\n        * `pid`\n        * `count`\n\n        """\n        r = self.api._req_directory(self.cid)\n        self.pid = r[\'pid\']\n        self.name = r[\'name\']\n        self._count = r[\'count\']\n\n    def _load_entries(self, func, count, page=1, entries=None, **kwargs):\n        """\n        Load entries\n\n        :param function func: function (:meth:`.API._req_files` or\n            :meth:`.API._req_search`) that returns entries\n        :param int count: number of entries to load. This value should never\n            be greater than self.count\n        :param int page: page number (starting from 1)\n\n        """\n        if entries is None:\n            entries = []\n        res = \\\n            func(offset=(page - 1) * self.max_entries_per_load,\n                 limit=self.max_entries_per_load,\n                 **kwargs)\n        loaded_entries = [\n            entry for entry in res[\'data\'][:count]\n        ]\n        #total_count = res[\'count\']\n        total_count = self.count\n        # count should never be greater than total_count\n        if count > total_count:\n            count = total_count\n        if count <= self.max_entries_per_load:\n            return entries + loaded_entries\n        else:\n            cur_count = count - self.max_entries_per_load\n            return self._load_entries(\n                func=func, count=cur_count, page=page + 1,\n                entries=entries + loaded_entries, **kwargs)\n\n    def list(self, count=30, order=\'user_ptime\', asc=False, show_dir=True,\n             natsort=True):\n        """\n        List directory contents\n\n        :param int count: number of entries to be listed\n        :param str order: order of entries, originally named `o`. This value\n            may be one of `user_ptime` (default), `file_size` and `file_name`\n        :param bool asc: whether in ascending order\n        :param bool show_dir: whether to show directories\n        :param bool natsort: whether to use natural sort\n\n        Return a list of :class:`.File` or :class:`.Directory` objects\n        """\n        if self.cid is None:\n            return False\n        self.reload()\n        kwargs = {}\n        # `cid` is the only required argument\n        kwargs[\'cid\'] = self.cid\n        kwargs[\'asc\'] = 1 if asc is True else 0\n        kwargs[\'show_dir\'] = 1 if show_dir is True else 0\n        kwargs[\'natsort\'] = 1 if natsort is True else 0\n        kwargs[\'o\'] = order\n\n        # When the downloads directory exists along with its parent directory,\n        # the receiver directory, its parent\'s count (receiver directory\'s\n        # count) does not include the downloads directory. This behavior is\n        # similar to its parent\'s parent (root), the count of which does not\n        # include the receiver directory.\n        # The following code fixed this behavior so that a directory\'s\n        # count correctly reflects the actual number of entries in it\n        # The side-effect that this code may ensure that downloads directory\n        # exists, causing the system to create the receiver directory and\n        # downloads directory, if they do not exist.\n\n        if self.is_root or self == self.api.receiver_directory:\n            self._count += 1\n\n        if self.count <= count:\n            # count should never be greater than self.count\n            count = self.count\n        try:\n            entries = self._load_entries(func=self.api._req_files,\n                                         count=count, page=1, **kwargs)\n        # When natsort=1 and order=\'file_name\', API access will fail\n        except RequestFailure as e:\n            if natsort is True and order == \'file_name\':\n                entries = \\\n                    self._load_entries(func=self.api._req_aps_natsort_files,\n                                       count=count, page=1, **kwargs)\n            else:\n                raise e\n        res = []\n        for entry in entries:\n            if \'pid\' in entry:\n                res.append(_instantiate_directory(self.api, entry))\n            else:\n                res.append(_instantiate_file(self.api, entry))\n        return res\n\n    def mkdir(self, name):\n        """\n        Create a new directory in this directory\n        """\n        self.api.mkdir(self, name)\n\n\nclass Task(Base):\n    """\n    BitTorrent or URL task\n\n    :ivar datetime.datetime add_time: added time\n    :ivar str cid: associated directory id, if any. For a directory task (\n        e.g. BT task), this is its associated directory\'s cid. For a file\n        task (e.g. HTTP url task), this is the cid of the downloads directory.\n        This value may be None if the task is failed and has no corresponding\n        directory\n    :ivar str file_id: equivalent to `cid` of :class:`.Directory`. This value\n        may be None if the task is failed and has no corresponding directory\n    :ivar str info_hash: hashed value\n    :ivar datetime.datetime last_update: last updated time\n    :ivar int left_time: left time ()\n    :ivar int move: moving state\n\n        * 0: not transferred\n        * 1: transferred\n        * 2: partially transferred\n\n    :ivar str name: name of this task\n    :ivar int peers: number of peers\n    :ivar int percent_done: <=100, originally named `percentDone`\n    :ivar int rate_download: download rate (B/s), originally named\n        `rateDownload`\n    :ivar int size: size of task\n    :ivar str size_human: human-readable size\n    :ivar int status: status code\n\n        * -1: failed\n        * 1: downloading\n        * 2: downloaded\n        * 4: searching resources\n\n    """\n\n    def __init__(self, api, add_time, file_id, info_hash, last_update,\n                 left_time, move, name, peers, percent_done, rate_download,\n                 size, status, cid, pid, url, *args, **kwargs):\n        self.api = api\n        self.cid = cid\n        self.name = name\n        self.add_time = add_time\n        self.file_id = file_id\n        self.info_hash = info_hash\n        self.last_update = last_update\n        self.left_time = left_time\n        self.move = move\n        self.peers = peers\n        self.percent_done = percent_done\n        self.rate_download = rate_download\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.status = status\n        self.url = url\n        self._directory = None\n        self._deleted = False\n        self._count = -1\n\n    @property\n    def is_directory(self):\n        """\n        :return: whether this task is associated with a directory.\n        :rtype: bool\n        """\n        if self.cid is None:\n            msg = \'Cannot determine whether this task is a directory.\'\n            if not self.is_transferred:\n                msg += \' This task has not been transferred.\'\n            raise TaskError(msg)\n        return self.api.downloads_directory.cid != self.cid\n\n    @property\n    def is_bt(self):\n        """Alias of `is_directory`"""\n        return self.is_directory\n\n    def delete(self):\n        """\n        Delete task (does not influence its corresponding directory)\n\n        :return: whether deletion is successful\n        :raise: :class:`.TaskError` if the task is already deleted\n        """\n        if not self._deleted:\n            if self.api._req_lixian_task_del(self):\n                self._deleted = True\n                return True\n        raise TaskError(\'This task is already deleted.\')\n\n    @property\n    def is_deleted(self):\n        """\n        :return: whether this task is deleted\n        :rtype: bool\n        """\n        return self._deleted\n\n    @property\n    def is_transferred(self):\n        """\n        :return: whether this tasks has been transferred\n        :rtype: bool\n        """\n        return self.move == 1\n\n    @property\n    def status_human(self):\n        """\n        Human readable status\n\n        :return:\n\n            * `DOWNLOADING`: the task is downloading files\n            * `BEING TRANSFERRED`: the task is being transferred\n            * `TRANSFERRED`: the task has been transferred to downloads \\\n                    directory\n            * `SEARCHING RESOURCES`: the task is searching resources\n            * `FAILED`: the task is failed\n            * `DELETED`: the task is deleted\n            * `UNKNOWN STATUS`\n\n        :rtype: str\n\n        """\n        res = None\n        if self._deleted:\n            return \'DELETED\'\n        if self.status == 1:\n            res = \'DOWNLOADING\'\n        elif self.status == 2:\n            if self.move == 0:\n                res = \'BEING TRANSFERRED\'\n            elif self.move == 1:\n                res = \'TRANSFERRED\'\n            elif self.move == 2:\n                res = \'PARTIALLY TRANSFERRED\'\n        elif self.status == 4:\n            res = \'SEARCHING RESOURCES\'\n        elif self.status == -1:\n            res = \'FAILED\'\n        if res is not None:\n            return res\n        return \'UNKNOWN STATUS\'\n\n    @property\n    def directory(self):\n        """Associated directory, if any, with this task"""\n        if not self.is_directory:\n            msg = \'This task is a file task with no associated directory.\'\n            raise TaskError(msg)\n        if self._directory is None:\n            if self.is_transferred:\n                self._directory = self.api._load_directory(self.cid)\n        if self._directory is None:\n            msg = \'No directory assciated with this task: Task is %s.\' % \\\n                self.status_human.lower()\n            raise TaskError(msg)\n        return self._directory\n\n    @property\n    def parent(self):\n        """Parent directory of the associated directory"""\n        return self.directory.parent\n\n    @property\n    def count(self):\n        """Number of entries in the associated directory"""\n        return self.directory.count\n\n    def list(self, count=30, order=\'user_ptime\', asc=False, show_dir=True,\n             natsort=True):\n        """\n        List files of the associated directory to this task.\n\n        :param int count: number of entries to be listed\n        :param str order: originally named `o`\n        :param bool asc: whether in ascending order\n        :param bool show_dir: whether to show directories\n\n        """\n        return self.directory.list(count, order, asc, show_dir, natsort)\n\n    def __unicode__(self):\n        return self.name\n\n\nclass Torrent(Base):\n    """\n    Opened torrent before becoming a task\n\n    :ivar api: associated API object\n    :ivar str name: task name, originally named `torrent_name`\n    :ivar int size: task size, originally named `torrent_size`\n    :ivar str info_hash: hashed value\n    :ivar int file_count: number of files included\n    :ivar list files: files included (list of :class:`.TorrentFile`),\n        originally named `torrent_filelist_web`\n    """\n\n    def __init__(self, api, name, size, info_hash, file_count, files=None,\n                 *args, **kwargs):\n        self.api = api\n        self.name = name\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.info_hash = info_hash\n        self.file_count = file_count\n        self.files = files\n        self.submitted = False\n\n    def submit(self):\n        """Submit this torrent and create a new task"""\n        if self.api._req_lixian_add_task_bt(self):\n            self.submitted = True\n            return True\n        return False\n\n    @property\n    def selected_files(self):\n        """List of selected :class:`.TorrentFile` objects of this torrent"""\n        return [f for f in self.files if f.selected]\n\n    @property\n    def unselected_files(self):\n        """List of unselected :class:`.TorrentFile` objects of this torrent"""\n        return [f for f in self.files if not f.selected]\n\n    def __unicode__(self):\n        return self.name\n\n\nclass TorrentFile(Base):\n    """\n    File in the torrent file list\n\n    :param torrent: the torrent that holds this file\n    :type torrent: :class:`.Torrent`\n    :param str path: file path in the torrent\n    :param int size: file size\n    :param bool selected: whether this file is selected\n    """\n\n    def __init__(self, torrent, path, size, selected, *args, **kwargs):\n        self.torrent = torrent\n        self.path = path\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.selected = selected\n\n    def select(self):\n        """Select this file"""\n        self.selected = True\n\n    def unselect(self):\n        """Unselect this file"""\n        self.selected = False\n\n    def __unicode__(self):\n        return \'[%s] %s\' % (\'*\' if self.selected else \' \', self.path)\n\n\ndef _instantiate_task(api, kwargs):\n    """Create a Task object from raw kwargs"""\n    file_id = kwargs[\'file_id\']\n    kwargs[\'file_id\'] = file_id if str(file_id).strip() else None\n    kwargs[\'cid\'] = kwargs[\'file_id\'] or None\n    kwargs[\'rate_download\'] = kwargs[\'rateDownload\']\n    kwargs[\'percent_done\'] = kwargs[\'percentDone\']\n    kwargs[\'add_time\'] = get_utcdatetime(kwargs[\'add_time\'])\n    kwargs[\'last_update\'] = get_utcdatetime(kwargs[\'last_update\'])\n    is_transferred = (kwargs[\'status\'] == 2 and kwargs[\'move\'] == 1)\n    if is_transferred:\n        kwargs[\'pid\'] = api.downloads_directory.cid\n    else:\n        kwargs[\'pid\'] = None\n    del kwargs[\'rateDownload\']\n    del kwargs[\'percentDone\']\n    if \'url\' in kwargs:\n        if not kwargs[\'url\']:\n            kwargs[\'url\'] = None\n    else:\n        kwargs[\'url\'] = None\n    task = Task(api, **kwargs)\n    if is_transferred:\n        task._parent = api.downloads_directory\n    return task\n\n\ndef _instantiate_file(api, kwargs):\n    kwargs[\'file_type\'] = kwargs[\'ico\']\n    kwargs[\'date_created\'] = string_to_datetime(kwargs[\'t\'])\n    kwargs[\'pickcode\'] = kwargs[\'pc\']\n    kwargs[\'name\'] = kwargs[\'n\']\n    kwargs[\'thumbnail\'] = kwargs.get(\'u\')\n    kwargs[\'size\'] = kwargs[\'s\']\n    del kwargs[\'ico\']\n    del kwargs[\'t\']\n    del kwargs[\'pc\']\n    del kwargs[\'s\']\n    if \'u\' in kwargs:\n        del kwargs[\'u\']\n    return File(api, **kwargs)\n\n\ndef _instantiate_directory(api, kwargs):\n    kwargs[\'name\'] = kwargs[\'n\']\n    kwargs[\'date_created\'] = get_utcdatetime(float(kwargs[\'t\']))\n    kwargs[\'pickcode\'] = kwargs.get(\'pc\')\n    return Directory(api, **kwargs)\n\n\ndef _instantiate_uploaded_file(api, kwargs):\n    kwargs[\'fid\'] = kwargs[\'file_id\']\n    kwargs[\'name\'] = kwargs[\'file_name\']\n    kwargs[\'pickcode\'] = kwargs[\'pick_code\']\n    kwargs[\'size\'] = kwargs[\'file_size\']\n    kwargs[\'sha\'] = kwargs[\'sha1\']\n    kwargs[\'date_created\'] = get_utcdatetime(kwargs[\'file_ptime\'])\n    kwargs[\'thumbnail\'] = None\n    _, ft = os.path.splitext(kwargs[\'name\'])\n    kwargs[\'file_type\'] = ft[1:]\n    return File(api, **kwargs)\n\n\ndef _instantiate_torrent(api, kwargs):\n    kwargs[\'size\'] = kwargs[\'file_size\']\n    kwargs[\'name\'] = kwargs[\'torrent_name\']\n    file_list = kwargs[\'torrent_filelist_web\']\n    del kwargs[\'file_size\']\n    del kwargs[\'torrent_name\']\n    del kwargs[\'torrent_filelist_web\']\n    torrent = Torrent(api, **kwargs)\n    torrent.files = [_instantiate_torrent_file(torrent, f) for f in file_list]\n    return torrent\n\n\ndef _instantiate_torrent_file(torrent, kwargs):\n    kwargs[\'selected\'] = True if kwargs[\'wanted\'] == 1 else False\n    del kwargs[\'wanted\']\n    return TorrentFile(torrent, **kwargs)\n\n\nclass APIError(Exception):\n    """General error related to API"""\n    def __init__(self, *args, **kwargs):\n        content = kwargs.pop(\'content\', None)\n        self.content = content\n        super(APIError, self).__init__(*args, **kwargs)\n\n\nclass TaskError(APIError):\n    """Task has unstable status or no directory operation"""\n    pass\n\n\nclass AuthenticationError(APIError):\n    """Authentication error"""\n    pass\n\n\nclass InvalidAPIAccess(APIError):\n    """Invalid and forbidden API access"""\n    pass\n\n\nclass RequestFailure(APIError):\n    """Request failure"""\n    pass\n\n\nclass JobError(APIError):\n    """Job running error (request multiple similar jobs simultaneously)"""\n    def __init__(self, *args, **kwargs):\n        content = kwargs.pop(\'content\', None)\n        self.content = content\n        if not args:\n            msg = \'Your account has a similar job running. Try again later.\'\n            args = (msg,)\n        super(JobError, self).__init__(*args, **kwargs)\n'
u'1237,class RequestsLWPCookieJar(cookielib.LWPCookieJar, RequestsCookieJar):\n    """:class:`requests.cookies.RequestsCookieJar` compatible\n    :class:`cookielib.LWPCookieJar`"""\n    pass\n'
u'1238,class RequestsMozillaCookieJar(cookielib.MozillaCookieJar, RequestsCookieJar):\n    """:class:`requests.cookies.RequestsCookieJar` compatible\n    :class:`cookielib.MozillaCookieJar`"""\n    pass\n'
u'1239,class RequestHandler(object):\n    """\n    Request handler that maintains session\n\n    :ivar session: underlying :class:`requests.Session` instance\n\n    """\n\n    def __init__(self):\n        self.session = requests.Session()\n        self.session.headers[\'User-Agent\'] = USER_AGENT\n\n    def get(self, url, params=None):\n        """\n        Initiate a GET request\n        """\n        r = self.session.get(url, params=params)\n        return self._response_parser(r, expect_json=False)\n\n    def post(self, url, data, params=None):\n        """\n        Initiate a POST request\n        """\n        r = self.session.post(url, data=data, params=params)\n        return self._response_parser(r, expect_json=False)\n\n    def send(self, request, expect_json=True, ignore_content=False):\n        """\n        Send a formatted API request\n\n        :param request: a formatted request object\n        :type request: :class:`.Request`\n        :param bool expect_json: if True, raise :class:`.InvalidAPIAccess` if\n            response is not in JSON format\n        :param bool ignore_content: whether to ignore setting content of the\n            Response object\n        """\n        r = self.session.request(method=request.method,\n                                 url=request.url,\n                                 params=request.params,\n                                 data=request.data,\n                                 files=request.files,\n                                 headers=request.headers)\n        return self._response_parser(r, expect_json, ignore_content)\n\n    def _response_parser(self, r, expect_json=True, ignore_content=False):\n        """\n        :param :class:`requests.Response` r: a response object of the Requests\n            library\n        :param bool expect_json: if True, raise :class:`.InvalidAPIAccess` if\n            response is not in JSON format\n        :param bool ignore_content: whether to ignore setting content of the\n            Response object\n        """\n        if r.ok:\n            try:\n                j = r.json()\n                return Response(j.get(\'state\'), j)\n            except ValueError:\n                # No JSON-encoded data returned\n                if expect_json:\n                    logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n                    logger.debug(r.text)\n                    raise InvalidAPIAccess(\'Invalid API access.\')\n                # Raw response\n                if ignore_content:\n                    res = Response(True, None)\n                else:\n                    res = Response(True, r.text)\n                return res\n        else:\n            r.raise_for_status()\n'
u'1240,class Request(object):\n    """Formatted API request class"""\n\n    def __init__(self, url, method=\'GET\', params=None, data=None,\n                 files=None, headers=None):\n        """\n        Create a Request object\n\n        :param str url: URL\n        :param str method: request method\n        :param dict params: request parameters\n        :param dict data: form data\n        :param dict files: mulitpart form data\n        :param dict headers: custom request headers\n\n        """\n        self.url = url\n        self.method = method\n        self.params = params\n        self.data = data\n        self.files = files\n        self.headers = headers\n        self._debug()\n\n    def _debug(self):\n        logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n        level = logger.getEffectiveLevel()\n        if level == logging.DEBUG:\n            func = inspect.stack()[2][3]\n            msg = conf.DEBUG_REQ_FMT % (func, self.url, self.method,\n                                        self.params, self.data)\n            logger.debug(msg)\n'
u'1241,class Response(object):\n    """\n    Formatted API response class\n\n    :ivar bool state: whether API access is successful\n    :ivar dict content: result content\n    """\n\n    def __init__(self, state, content):\n        self.state = state\n        self.content = content\n        self._debug()\n\n    def _debug(self):\n        logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n        level = logger.getEffectiveLevel()\n        if level == logging.DEBUG:\n            func = inspect.stack()[4][3]\n            msg = conf.DEBUG_RES_FMT % (func, self.state, self.content)\n            logger.debug(msg)\n'
u'1242,class API(object):\n    """\n    Request and response interface\n\n    :ivar passport: :class:`.Passport` object associated with this interface\n    :ivar http: :class:`.RequestHandler` object associated with this\n        interface\n    :cvar int num_tasks_per_page: default number of tasks per page/request\n    :cvar str web_api_url: files API url\n    :cvar str aps_natsort_url: natural sort files API url\n    :cvar str proapi_url: pro API url for downloads\n    """\n\n    num_tasks_per_page = 30\n    web_api_url = \'http://web.api.115.com/files\'\n    aps_natsort_url = \'http://aps.115.com/natsort/files.php\'\n    proapi_url = \'http://proapi.115.com/app/chrome/down\'\n    referer_url = \'http://115.com\'\n\n    def __init__(self, persistent=False,\n                 cookies_filename=None, cookies_type=\'LWPCookieJar\'):\n        """\n        :param bool auto_logout: whether to logout automatically when\n            :class:`.API` object is destroyed\n\n                                 .. deprecated:: 0.6.0\n                                     Call :meth:`.API.logout` explicitly\n\n        :param bool persistent: whether to use persistent session that stores\n            cookies on disk\n        :param str cookies_filename: path to the cookies file, use default\n            path (`~/.115cookies`) if None\n        :param str cookies_type: a string representing\n            :class:`cookielib.FileCookieJar` subclass,\n            `LWPCookieJar` (default) or `MozillaCookieJar`\n        """\n        self.persistent = persistent\n        self.cookies_filename = cookies_filename\n        self.cookies_type = cookies_type\n        self.passport = None\n        self.http = RequestHandler()\n        self.logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n        # Cache attributes to decrease API hits\n        self._user_id = None\n        self._username = None\n        self._signatures = {}\n        self._upload_url = None\n        self._lixian_timestamp = None\n        self._root_directory = None\n        self._downloads_directory = None\n        self._receiver_directory = None\n        self._torrents_directory = None\n        self._task_count = None\n        self._task_quota = None\n        if self.persistent:\n            self.load_cookies()\n\n    def _reset_cache(self):\n        self._user_id = None\n        self._username = None\n        self._signatures = {}\n        self._upload_url = None\n        self._lixian_timestamp = None\n        self._root_directory = None\n        self._downloads_directory = None\n        self._receiver_directory = None\n        self._torrents_directory = None\n        self._task_count = None\n        self._task_quota = None\n\n    def _init_cookies(self):\n        # RequestsLWPCookieJar or RequestsMozillaCookieJar\n        cookies_class = globals()[\'Requests\' + self.cookies_type]\n        f = self.cookies_filename or conf.COOKIES_FILENAME\n        self.cookies = cookies_class(f)\n\n    def load_cookies(self, ignore_discard=True, ignore_expires=True):\n        """Load cookies from the file :attr:`.API.cookies_filename`"""\n        self._init_cookies()\n        if os.path.exists(self.cookies.filename):\n            self.cookies.load(ignore_discard=ignore_discard,\n                              ignore_expires=ignore_expires)\n            self._reset_cache()\n\n    def save_cookies(self, ignore_discard=True, ignore_expires=True):\n        """Save cookies to the file :attr:`.API.cookies_filename`"""\n        if not isinstance(self.cookies, cookielib.FileCookieJar):\n            m = \'Cookies must be a cookielib.FileCookieJar object to be saved.\'\n            raise APIError(m)\n        self.cookies.save(ignore_discard=ignore_discard,\n                          ignore_expires=ignore_expires)\n\n    @property\n    def cookies(self):\n        """\n        Cookies of the current API session (cookies getter shortcut)\n        """\n        return self.http.session.cookies\n\n    @cookies.setter\n    def cookies(self, cookies):\n        """\n        Cookies of the current API session (cookies setter shortcut)\n        """\n        self.http.session.cookies = cookies\n\n    def login(self, username=None, password=None,\n              section=\'default\'):\n        """\n        Created the passport with ``username`` and ``password`` and log in.\n        If either ``username`` or ``password`` is None or omitted, the\n        credentials file will be parsed.\n\n        :param str username: username to login (email, phone number or user ID)\n        :param str password: password\n        :param str section: section name in the credential file\n        :raise: raises :class:`.AuthenticationError` if failed to login\n        """\n        if self.has_logged_in:\n            return True\n        if username is None or password is None:\n            credential = conf.get_credential(section)\n            username = credential[\'username\']\n            password = credential[\'password\']\n\n        passport = Passport(username, password)\n        r = self.http.post(LOGIN_URL, passport.form)\n\n        if r.state is True:\n            # Bind this passport to API\n            self.passport = passport\n            passport.data = r.content[\'data\']\n            self._user_id = r.content[\'data\'][\'USER_ID\']\n            return True\n        else:\n            msg = None\n            if \'err_name\' in r.content:\n                if r.content[\'err_name\'] == \'account\':\n                    msg = \'Account does not exist.\'\n                elif r.content[\'err_name\'] == \'passwd\':\n                    msg = \'Password is incorrect.\'\n            raise AuthenticationError(msg)\n\n    def get_user_info(self):\n        """\n        Get user info\n\n        :return: a dictionary of user information\n        :rtype: dict\n\n        """\n        return self._req_get_user_aq()\n\n    @property\n    def user_id(self):\n        """\n        User id of the current API user\n        """\n        if self._user_id is None:\n            if self.has_logged_in:\n                self._user_id = self._req_get_user_aq()[\'data\'][\'uid\']\n            else:\n                raise AuthenticationError(\'Not logged in.\')\n        return self._user_id\n\n    @property\n    def username(self):\n        """\n        Username of the current API user\n        """\n        if self._username is None:\n            if self.has_logged_in:\n                self._username = self._get_username()\n            else:\n                raise AuthenticationError(\'Not logged in.\')\n        return self._username\n\n    @property\n    def has_logged_in(self):\n        """Check whether the API has logged in"""\n        r = self.http.get(CHECKPOINT_URL)\n        if r.state is False:\n            return True\n        # If logged out, flush cache\n        self._reset_cache()\n        return False\n\n    def logout(self):\n        """Log out"""\n        self.http.get(LOGOUT_URL)\n        self._reset_cache()\n        return True\n\n    @property\n    def root_directory(self):\n        """Root directory"""\n        if self._root_directory is None:\n            self._load_root_directory()\n        return self._root_directory\n\n    @property\n    def downloads_directory(self):\n        """Default directory for downloaded files"""\n        if self._downloads_directory is None:\n            self._load_downloads_directory()\n        return self._downloads_directory\n\n    @property\n    def receiver_directory(self):\n        """Parent directory of the downloads directory"""\n        if self._receiver_directory is None:\n            self._receiver_directory = self.downloads_directory.parent\n        return self._receiver_directory\n\n    @property\n    def torrents_directory(self):\n        """Default directory that stores uploaded torrents"""\n        if self._torrents_directory is None:\n            self._load_torrents_directory()\n        return self._torrents_directory\n\n    @property\n    def task_count(self):\n        """\n        Number of tasks created\n        """\n        self._req_lixian_task_lists()\n        return self._task_count\n\n    @property\n    def task_quota(self):\n        """\n        Task quota (monthly)\n        """\n        self._req_lixian_task_lists()\n        return self._task_quota\n\n    def get_tasks(self, count=30):\n        """\n        Get ``count`` number of tasks\n\n        :param int count: number of tasks to get\n        :return: a list of :class:`.Task` objects\n        """\n\n        return self._load_tasks(count)\n\n    def add_task_bt(self, filename, select=False):\n        """\n        Add a new BT task\n\n        :param str filename: path to torrent file to upload\n        :param bool select: whether to select files in the torrent.\n\n            * True: it returns the opened torrent (:class:`.Torrent`) and\n                can then iterate files in :attr:`.Torrent.files` and\n                select/unselect them before calling :meth:`.Torrent.submit`\n            * False: it will submit the torrent with default selected files\n\n        """\n        filename = eval_path(filename)\n        u = self.upload(filename, self.torrents_directory)\n        t = self._load_torrent(u)\n        if select:\n            return t\n        return t.submit()\n\n    def add_task_url(self, target_url):\n        """\n        Add a new URL task\n\n        :param str target_url: the URL of the file that to be downloaded\n\n        """\n        return self._req_lixian_add_task_url(target_url)\n\n    def get_storage_info(self, human=False):\n        """\n        Get storage info\n\n        :param bool human: whether return human-readable size\n        :return: total and used storage\n        :rtype: dict\n\n        """\n        res = self._req_get_storage_info()\n        if human:\n            res[\'total\'] = humanize.naturalsize(res[\'total\'], binary=True)\n            res[\'used\'] = humanize.naturalsize(res[\'used\'], binary=True)\n        return res\n\n    def upload(self, filename, directory=None):\n        """\n        Upload a file ``filename`` to ``directory``\n\n        :param str filename: path to the file to upload\n        :param directory: destionation :class:`.Directory`, defaults to\n            :attribute:`.API.downloads_directory` if None\n        :return: the uploaded file\n        :rtype: :class:`.File`\n        """\n        filename = eval_path(filename)\n        if directory is None:\n            directory = self.downloads_directory\n\n        # First request\n        res1 = self._req_upload(filename, directory)\n        data1 = res1[\'data\']\n        file_id = data1[\'file_id\']\n\n        # Second request\n        res2 = self._req_file(file_id)\n        data2 = res2[\'data\'][0]\n        data2.update(**data1)\n        return _instantiate_uploaded_file(self, data2)\n\n    def download(self, obj, path=None, show_progress=True, resume=True,\n                 auto_retry=True, proapi=False):\n        """\n        Download a file\n\n        :param obj: :class:`.File` object\n        :param str path: local path\n        :param bool show_progress: whether to show download progress\n        :param bool resume: whether to resume on unfinished downloads\n            identified by filename\n        :param bool auto_retry: whether to retry automatically upon closed\n            transfer until the file\'s download is finished\n        :param bool proapi: whether to use pro API\n        """\n        url = obj.get_download_url(proapi)\n        download(url, path=path, session=self.http.session,\n                 show_progress=show_progress, resume=resume,\n                 auto_retry=auto_retry)\n\n    def search(self, keyword, count=30):\n        """\n        Search files or directories\n\n        :param str keyword: keyword\n        :param int count: number of entries to be listed\n        """\n        kwargs = {}\n        kwargs[\'search_value\'] = keyword\n        root = self.root_directory\n        entries = root._load_entries(func=self._req_files_search,\n                                     count=count, page=1, **kwargs)\n\n        res = []\n        for entry in entries:\n            if \'pid\' in entry:\n                res.append(_instantiate_directory(self, entry))\n            else:\n                res.append(_instantiate_file(self, entry))\n        return res\n\n    def move(self, entries, directory):\n        """\n        Move one or more entries (file or directory) to the destination\n        directory\n\n        :param list entries: a list of source entries (:class:`.BaseFile`\n            object)\n        :param directory: destination directory\n        :return: whether the action is successful\n        :raise: :class:`.APIError` if something bad happened\n        """\n        fcids = []\n        for entry in entries:\n            if isinstance(entry, File):\n                fcid = entry.fid\n            elif isinstance(entry, Directory):\n                fcid = entry.cid\n            else:\n                raise APIError(\'Invalid BaseFile instance for an entry.\')\n            fcids.append(fcid)\n        if not isinstance(directory, Directory):\n            raise APIError(\'Invalid destination directory.\')\n        if self._req_files_move(directory.cid, fcids):\n            for entry in entries:\n                if isinstance(entry, File):\n                    entry.cid = directory.cid\n                entry.reload()\n            return True\n        else:\n            raise APIError(\'Error moving entries.\')\n\n    def edit(self, entry, name, mark=False):\n        """\n        Edit an entry (file or directory)\n\n        :param entry: :class:`.BaseFile` object\n        :param str name: new name for the entry\n        :param bool mark: whether to bookmark the entry\n        """\n        fcid = None\n        if isinstance(entry, File):\n            fcid = entry.fid\n        elif isinstance(entry, Directory):\n            fcid = entry.cid\n        else:\n            raise APIError(\'Invalid BaseFile instance for an entry.\')\n        is_mark = 0\n        if mark is True:\n            is_mark = 1\n        if self._req_files_edit(fcid, name, is_mark):\n            entry.reload()\n            return True\n        else:\n            raise APIError(\'Error editing the entry.\')\n\n    def mkdir(self, parent, name):\n        """\n        Create a directory\n\n        :param parent: the parent directory\n        :param str name: the name of the new directory\n        :return: the new directory\n        :rtype: :class:`.Directory`\n\n        """\n        pid = None\n        cid = None\n        if isinstance(parent, Directory):\n            pid = parent.cid\n        else:\n            raise(\'Invalid Directory instance.\')\n        cid = self._req_files_add(pid, name)[\'cid\']\n        return self._load_directory(cid)\n\n    def _req_offline_space(self):\n        """Required before accessing lixian tasks"""\n        url = \'http://115.com/\'\n        params = {\n            \'ct\': \'offline\',\n            \'ac\': \'space\',\n            \'_\': get_timestamp(13)\n        }\n        _sign = os.environ.get(\'U115_BROWSER_SIGN\')\n        if _sign is not None:\n            _time = os.environ.get(\'U115_BROWSER_TIME\')\n            if _time is None:\n                msg = \'U115_BROWSER_TIME is required given U115_BROWSER_SIGN.\'\n                raise APIError(msg)\n            params[\'sign\'] = _sign\n            params[\'time\'] = _time\n            params[\'uid\'] = self.user_id\n        req = Request(url=url, params=params)\n        r = self.http.send(req)\n        if r.state:\n            self._signatures[\'offline_space\'] = r.content[\'sign\']\n            self._lixian_timestamp = r.content[\'time\']\n        else:\n            msg = \'Failed to retrieve signatures.\'\n            raise RequestFailure(msg)\n\n    def _req_lixian_task_lists(self, page=1):\n        """\n        This request will cause the system to create a default downloads\n        directory if it does not exist\n        """\n        url = \'http://115.com/lixian/\'\n        params = {\'ct\': \'lixian\', \'ac\': \'task_lists\'}\n        self._load_signatures()\n        data = {\n            \'page\': page,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            self._task_count = res.content[\'count\']\n            self._task_quota = res.content[\'quota\']\n            return res.content[\'tasks\']\n        else:\n            msg = \'Failed to get tasks.\'\n            raise RequestFailure(msg)\n\n    def _req_lixian_get_id(self, torrent=False):\n        """Get `cid` of lixian space directory"""\n        url = \'http://115.com/\'\n        params = {\n            \'ct\': \'lixian\',\n            \'ac\': \'get_id\',\n            \'torrent\': 1 if torrent else None,\n            \'_\': get_timestamp(13)\n        }\n        req = Request(method=\'GET\', url=url, params=params)\n        res = self.http.send(req)\n        return res.content\n\n    def _req_lixian_torrent(self, u):\n        """\n        :param u: uploaded torrent file\n        """\n\n        self._load_signatures()\n        url = \'http://115.com/lixian/\'\n        params = {\n            \'ct\': \'lixian\',\n            \'ac\': \'torrent\',\n        }\n        data = {\n            \'pickcode\': u.pickcode,\n            \'sha1\': u.sha,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            msg = res.content.get(\'error_msg\')\n            self.logger.error(msg)\n            raise RequestFailure(\'Failed to open torrent.\')\n\n    def _req_lixian_add_task_bt(self, t):\n\n        self._load_signatures()\n        url = \'http://115.com/lixian/\'\n        params = {\'ct\': \'lixian\', \'ac\': \'add_task_bt\'}\n        _wanted = []\n        for i, b in enumerate(t.files):\n            if b.selected:\n                _wanted.append(str(i))\n        wanted = \',\'.join(_wanted)\n        data = {\n            \'info_hash\': t.info_hash,\n            \'wanted\': wanted,\n            \'savepath\': t.name,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            msg = res.content.get(\'error_msg\')\n            self.logger.error(msg)\n            raise RequestFailure(\'Failed to create new task.\')\n\n    def _req_lixian_add_task_url(self, target_url):\n\n        self._load_signatures()\n        url = \'http://115.com/lixian/\'\n        params = {\'ct\': \'lixian\', \'ac\': \'add_task_url\'}\n        data = {\n            \'url\': target_url,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            msg = res.content.get(\'error_msg\')\n            self.logger.error(msg)\n            raise RequestFailure(\'Failed to create new task.\')\n\n    def _req_lixian_task_del(self, t):\n\n        self._load_signatures()\n        url = \'http://115.com/lixian/\'\n        params = {\'ct\': \'lixian\', \'ac\': \'task_del\'}\n        data = {\n            \'hash[0]\': t.info_hash,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure(\'Failed to delete the task.\')\n\n    def _req_file_userfile(self):\n\n        url = \'http://115.com/\'\n        params = {\n            \'ct\': \'file\',\n            \'ac\': \'userfile\',\n            \'is_wl_tpl\': 1,\n        }\n        req = Request(method=\'GET\', url=url, params=params)\n        self.http.send(req, expect_json=False, ignore_content=True)\n\n    def _req_aps_natsort_files(self, cid, offset, limit, o=\'file_name\',\n                               asc=1, aid=1, show_dir=1, code=None, scid=None,\n                               snap=0, natsort=1, source=None, type=0,\n                               format=\'json\', star=None, is_share=None):\n        """\n        When :meth:`.API._req_files` is called with `o=\'filename\'` and\n            `natsort=1`, API access will fail\n            and :meth:`.API._req_aps_natsort_files` is subsequently called with\n            the same kwargs. Refer to the implementation in\n            :meth:`.Directory.list`\n        """\n        params = locals()\n        del params[\'self\']\n        req = Request(method=\'GET\', url=self.aps_natsort_url, params=params)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files(self, cid, offset, limit, o=\'user_ptime\', asc=1, aid=1,\n                   show_dir=1, code=None, scid=None, snap=0, natsort=1,\n                   source=None, type=0, format=\'json\', star=None,\n                   is_share=None):\n        """\n        :param int type: type of files to be displayed\n\n            * \'\' (empty string): marked\n            * None: all\n            * 0: all\n            * 1: documents\n            * 2: images\n            * 3: music\n            * 4: video\n            * 5: zipped\n            * 6: applications\n            * 99: files only\n        """\n        params = locals()\n        del params[\'self\']\n        req = Request(method=\'GET\', url=self.web_api_url, params=params)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files_search(self, offset, limit, search_value, aid=-1,\n                          date=None, pick_code=None, source=None, type=0,\n                          format=\'json\'):\n        params = locals()\n        del params[\'self\']\n        url = self.web_api_url + \'/search\'\n        req = Request(method=\'GET\', url=url, params=params)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files_edit(self, fid, file_name=None, is_mark=0):\n        """Edit a file or directory"""\n        url = self.web_api_url + \'/edit\'\n        data = locals()\n        del data[\'self\']\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files_add(self, pid, cname):\n        """\n        Add a directory\n        :param str pid: parent directory id\n        :param str cname: directory name\n        """\n        url = self.web_api_url + \'/add\'\n        data = locals()\n        del data[\'self\']\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_files_move(self, pid, fids):\n        """\n        Move files or directories\n        :param str pid: destination directory id\n        :param list fids: a list of ids of files or directories to be moved\n        """\n        url = self.web_api_url + \'/move\'\n        data = {}\n        data[\'pid\'] = pid\n        for i, fid in enumerate(fids):\n            data[\'fid[%d]\' % i] = fid\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_file(self, file_id):\n        url = self.web_api_url + \'/file\'\n        data = {\'file_id\': file_id}\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n\n    def _req_directory(self, cid):\n        """Return name and pid of by cid"""\n        res = self._req_files(cid=cid, offset=0, limit=1, show_dir=1)\n        path = res[\'path\']\n        count = res[\'count\']\n        for d in path:\n            if str(d[\'cid\']) == str(cid):\n                res = {\n                    \'cid\': d[\'cid\'],\n                    \'name\': d[\'name\'],\n                    \'pid\': d[\'pid\'],\n                    \'count\': count,\n                }\n                return res\n        else:\n            raise RequestFailure(\'No directory found.\')\n\n    def _req_files_download_url(self, pickcode, proapi=False):\n        if \'_115_curtime\' not in self.cookies:\n            self._req_file_userfile()\n        if not proapi:\n            url = self.web_api_url + \'/download\'\n            params = {\'pickcode\': pickcode, \'_\': get_timestamp(13)}\n        else:\n            url = self.proapi_url\n            params = {\'pickcode\': pickcode, \'method\': \'get_file_url\'}\n        headers = {\n            \'Referer\': self.referer_url,\n        }\n        req = Request(method=\'GET\', url=url, params=params,\n                      headers=headers)\n        res = self.http.send(req)\n        if res.state:\n            if not proapi:\n                return res.content[\'file_url\']\n            else:\n                fid = res.content[\'data\'].keys()[0]\n                return res.content[\'data\'][fid][\'url\'][\'url\']\n        else:\n            raise RequestFailure(\'Failed to get download URL.\')\n\n    def _req_get_storage_info(self):\n        url = \'http://115.com\'\n        params = {\n            \'ct\': \'ajax\',\n            \'ac\': \'get_storage_info\',\n            \'_\': get_timestamp(13),\n        }\n        req = Request(method=\'GET\', url=url, params=params)\n        res = self.http.send(req)\n        return res.content[\'1\']\n\n    def _req_upload(self, filename, directory):\n        """Raw request to upload a file ``filename``"""\n        self._upload_url = self._load_upload_url()\n        self.http.get(\'http://upload.115.com/crossdomain.xml\')\n        b = os.path.basename(filename)\n        target = \'U_1_\' + str(directory.cid)\n        files = {\n            \'Filename\': (\'\', quote(b), \'\'),\n            \'target\': (\'\', target, \'\'),\n            \'Filedata\': (quote(b), open(filename, \'rb\'), \'\'),\n            \'Upload\': (\'\', \'Submit Query\', \'\'),\n        }\n        req = Request(method=\'POST\', url=self._upload_url, files=files)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            msg = None\n            if res.content[\'code\'] == 990002:\n                msg = \'Invalid parameter.\'\n            elif res.content[\'code\'] == 1001:\n                msg = \'Torrent upload failed. Please try again later.\'\n            raise RequestFailure(msg)\n\n    def _req_rb_delete(self, fcid, pid):\n\n        url = \'http://web.api.115.com/rb/delete\'\n        data = {\n            \'pid\': pid,\n            \'fid[0]\': fcid,\n        }\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            msg = \'Failed to delete this file or directory.\'\n            if \'errno\' in res.content:\n                if res.content[\'errno\'] == 990005:\n                    raise JobError()\n            self.logger.error(res.content[\'error\'])\n            raise APIError(msg)\n\n    def _req_get_user_aq(self):\n        url = \'http://my.115.com/\'\n        data = {\n            \'ct\': \'ajax\',\n            \'ac\': \'get_user_aq\'\n        }\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n\n    def _load_signatures(self, force=True):\n        if not self._signatures or force:\n            self._req_offline_space()\n\n    def _load_tasks(self, count, page=1, tasks=None):\n        if tasks is None:\n            tasks = []\n        req_tasks = self._req_lixian_task_lists(page)\n        loaded_tasks = []\n        if req_tasks is not None:\n            loaded_tasks = [\n                _instantiate_task(self, t) for t in req_tasks[:count]\n            ]\n        if count <= self.num_tasks_per_page or req_tasks is None:\n            return tasks + loaded_tasks\n        else:\n            return self._load_tasks(count - self.num_tasks_per_page,\n                                    page + 1, tasks + loaded_tasks)\n\n    def _load_directory(self, cid):\n        kwargs = self._req_directory(cid)\n        if str(kwargs[\'pid\']) != str(cid):\n            return Directory(api=self, **kwargs)\n\n    def _load_root_directory(self):\n        """\n        Load root directory, which has a cid of 0\n        """\n        kwargs = self._req_directory(0)\n        self._root_directory = Directory(api=self, **kwargs)\n\n    def _load_torrents_directory(self):\n        """\n        Load torrents directory\n\n        If it does not exist yet, this request will cause the system to create\n        one\n        """\n        r = self._req_lixian_get_id(torrent=True)\n        self._downloads_directory = self._load_directory(r[\'cid\'])\n\n    def _load_downloads_directory(self):\n        """\n        Load downloads directory\n\n        If it does not exist yet, this request will cause the system to create\n        one\n        """\n        r = self._req_lixian_get_id(torrent=False)\n        self._downloads_directory = self._load_directory(r[\'cid\'])\n\n    def _load_upload_url(self):\n        res = self._parse_src_js_var(\'upload_config_h5\')\n        return res[\'url\']\n\n    def _load_torrent(self, u):\n        res = self._req_lixian_torrent(u)\n        return _instantiate_torrent(self, res)\n\n    def _parse_src_js_var(self, variable):\n        """Parse JavaScript variables in the source page"""\n\n        src_url = \'http://115.com\'\n        r = self.http.get(src_url)\n        soup = BeautifulSoup(r.content)\n        scripts = [script.text for script in soup.find_all(\'script\')]\n        text = \'\\n\'.join(scripts)\n        pattern = "%s\\s*=\\s*(.*);" % (variable.upper())\n        m = re.search(pattern, text)\n        if not m:\n            msg = \'Cannot parse source JavaScript for %s.\' % variable\n            raise APIError(msg)\n        return json.loads(m.group(1).strip())\n\n    def _get_username(self):\n        return unquote(self.cookies.get(\'OOFL\'))\n'
u"1243,class Base(object):\n    def __repr__(self):\n        try:\n            u = self.__str__()\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            u = '[Bad Unicode data]'\n        repr_type = type(u)\n        return repr_type('<%s: %s>' % (self.__class__.__name__, u))\n\n    def __str__(self):\n        if hasattr(self, '__unicode__'):\n            if PY3:\n                return self.__unicode__()\n            else:\n                return unicode(self).encode('utf-8')\n        return txt_type('%s object' % self.__class__.__name__)\n"
u'1244,class Passport(Base):\n    """\n    Passport for user authentication\n\n    :ivar str username: username\n    :ivar str password: user password\n    :ivar dict form: a dictionary of POST data to login\n    :ivar int user_id: user ID of the authenticated user\n    :ivar dict data: data returned upon login\n\n    """\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.form = self._form()\n        self.data = None\n\n    def _form(self):\n        vcode = self._vcode()\n        f = {\n            \'login[ssoent]\': \'A1\',\n            \'login[version]\': \'2.0\',\n            \'login[ssoext]\': vcode,\n            \'login[ssoln]\': self.username,\n            \'login[ssopw]\': self._ssopw(vcode),\n            \'login[ssovcode]\': vcode,\n            \'login[safe]\': \'1\',\n            \'login[time]\': \'0\',\n            \'login[safe_login]\': \'0\',\n            \'goto\': \'http://115.com/\',\n        }\n        return f\n\n    def _vcode(self):\n        s = \'%.6f\' % time.time()\n        whole, frac = map(int, s.split(\'.\'))\n        res = \'%.8x%.5x\' % (whole, frac)\n        return res\n\n    def _ssopw(self, vcode):\n        p = sha1(utf8_encode(self.password)).hexdigest()\n        u = sha1(utf8_encode(self.username)).hexdigest()\n        v = vcode.upper()\n        pu = sha1(utf8_encode(p + u)).hexdigest()\n        return sha1(utf8_encode(pu + v)).hexdigest()\n\n    def __unicode__(self):\n        return self.username\n'
u'1245,class BaseFile(Base):\n    def __init__(self, api, cid, name):\n        """\n        :param API api: associated API object\n        :param str cid: directory id\n\n            * For file: this represents the directory it belongs to;\n            * For directory: this represents itself\n\n        :param str name: originally named `n`\n\n        NOTICE\n            cid, fid and pid are in string format at this time\n        """\n        self.api = api\n        self.cid = cid\n        self.name = name\n        self._deleted = False\n\n    def delete(self):\n        """\n        Delete this file or directory\n\n        :return: whether deletion is successful\n        :raise: :class:`.APIError` if this file or directory is already deleted\n\n        """\n        fcid = None\n        pid = None\n\n        if isinstance(self, File):\n            fcid = self.fid\n            pid = self.cid\n        elif isinstance(self, Directory):\n            fcid = self.cid\n            pid = self.pid\n        else:\n            raise APIError(\'Invalid BaseFile instance.\')\n\n        if not self._deleted:\n            if self.api._req_rb_delete(fcid, pid):\n                self._deleted = True\n                return True\n        else:\n            raise APIError(\'This file or directory is already deleted.\')\n\n    def move(self, directory):\n        """\n        Move this file or directory to the destination directory\n\n        :param directory: destination directory\n        :return: whether the action is successful\n        :raise: :class:`.APIError` if something bad happened\n        """\n        self.api.move([self], directory)\n\n    def edit(self, name, mark=False):\n        """\n        Edit this file or directory\n\n        :param str name: new name for this entry\n        :param bool mark: whether to bookmark this entry\n        """\n        self.api.edit(self, name, mark)\n\n    @property\n    def is_deleted(self):\n        """Whether this file or directory is deleted"""\n        return self._deleted\n\n    def __eq__(self, other):\n        if isinstance(self, File):\n            if isinstance(other, File):\n                return self.fid == other.fid\n        elif isinstance(self, Directory):\n            if isinstance(other, Directory):\n                return self.cid == other.cid\n        return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __unicode__(self):\n        return self.name\n'
u'1246,class File(BaseFile):\n    """\n    File in a directory\n\n    :ivar int fid: file id\n    :ivar str cid: cid of the current directory\n    :ivar int size: size in bytes\n    :ivar str size_human: human-readable size\n    :ivar str file_type: originally named `ico`\n    :ivar str sha: SHA1 hash\n    :ivar datetime.datetime date_created: in "%Y-%m-%d %H:%M:%S" format,\n        originally named `t`\n    :ivar str thumbnail: thumbnail URL, originally named `u`\n    :ivar str pickcode: originally named `pc`\n    """\n\n    def __init__(self, api, fid, cid, name, size, file_type, sha,\n                 date_created, thumbnail, pickcode, *args, **kwargs):\n\n        super(File, self).__init__(api, cid, name)\n\n        self.fid = fid\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.file_type = file_type\n        self.sha = sha\n        self.date_created = date_created\n        self.thumbnail = thumbnail\n        self.pickcode = pickcode\n        self._directory = None\n        self._download_url = None\n\n    @property\n    def directory(self):\n        """Directory that holds this file"""\n        if self._directory is None:\n            self._directory = self.api._load_directory(self.cid)\n        return self._directory\n\n    def get_download_url(self, proapi=False):\n        """\n        Get this file\'s download URL\n\n        :param bool proapi: whether to use pro API\n\n        """\n        if self._download_url is None:\n            self._download_url = \\\n                self.api._req_files_download_url(self.pickcode, proapi)\n        return self._download_url\n\n    @property\n    def url(self):\n        """Alias for :meth:`.File.get_download_url` with `proapi=False`"""\n        return self.get_download_url()\n\n    def download(self, path=None, show_progress=True, resume=True,\n                 auto_retry=True, proapi=False):\n        """Download this file"""\n        self.api.download(self, path, show_progress, resume, auto_retry,\n                          proapi)\n\n    @property\n    def is_torrent(self):\n        """Whether the file is a torrent"""\n        return self.file_type == \'torrent\'\n\n    def open_torrent(self):\n        """\n        Open the torrent (if it is a torrent)\n\n        :return: opened torrent\n        :rtype: :class:`.Torrent`\n        """\n        if self.is_torrent:\n            return self.api._load_torrent(self)\n\n    def reload(self):\n        """\n        Reload file info and metadata\n\n        * name\n        * sha\n        * pickcode\n\n        """\n        res = self.api._req_file(self.fid)\n        data = res[\'data\'][0]\n        self.name = data[\'file_name\']\n        self.sha = data[\'sha1\']\n        self.pickcode = data[\'pick_code\']\n'
u'1247,class Directory(BaseFile):\n    """\n    :ivar str cid: cid of this directory\n    :ivar str pid: represents the parent directory it belongs to\n    :ivar int count: number of entries in this directory\n    :ivar datetime.datetime date_created: integer, originally named `t`\n    :ivar str pickcode: string, originally named `pc`\n\n    """\n\n    max_entries_per_load = 24  # Smaller than 24 may cause abnormal result\n\n    def __init__(self, api, cid, name, pid, count=-1,\n                 date_created=None, pickcode=None, is_root=False,\n                 *args, **kwargs):\n        super(Directory, self).__init__(api, cid, name)\n\n        self.pid = pid\n        self._count = count\n        if date_created is not None:\n            self.date_created = date_created\n        self.pickcode = pickcode\n        self._parent = None\n\n    @property\n    def is_root(self):\n        """Whether this directory is the root directory"""\n        return int(self.cid) == 0\n\n    @property\n    def parent(self):\n        """Parent directory that holds this directory"""\n        if self._parent is None:\n            if self.pid is not None:\n                self._parent = self.api._load_directory(self.pid)\n        return self._parent\n\n    @property\n    def count(self):\n        """Number of entries in this directory"""\n        if self._count == -1:\n            self.reload()\n        return self._count\n\n    def reload(self):\n        """\n        Reload directory info and metadata\n\n        * `name`\n        * `pid`\n        * `count`\n\n        """\n        r = self.api._req_directory(self.cid)\n        self.pid = r[\'pid\']\n        self.name = r[\'name\']\n        self._count = r[\'count\']\n\n    def _load_entries(self, func, count, page=1, entries=None, **kwargs):\n        """\n        Load entries\n\n        :param function func: function (:meth:`.API._req_files` or\n            :meth:`.API._req_search`) that returns entries\n        :param int count: number of entries to load. This value should never\n            be greater than self.count\n        :param int page: page number (starting from 1)\n\n        """\n        if entries is None:\n            entries = []\n        res = \\\n            func(offset=(page - 1) * self.max_entries_per_load,\n                 limit=self.max_entries_per_load,\n                 **kwargs)\n        loaded_entries = [\n            entry for entry in res[\'data\'][:count]\n        ]\n        #total_count = res[\'count\']\n        total_count = self.count\n        # count should never be greater than total_count\n        if count > total_count:\n            count = total_count\n        if count <= self.max_entries_per_load:\n            return entries + loaded_entries\n        else:\n            cur_count = count - self.max_entries_per_load\n            return self._load_entries(\n                func=func, count=cur_count, page=page + 1,\n                entries=entries + loaded_entries, **kwargs)\n\n    def list(self, count=30, order=\'user_ptime\', asc=False, show_dir=True,\n             natsort=True):\n        """\n        List directory contents\n\n        :param int count: number of entries to be listed\n        :param str order: order of entries, originally named `o`. This value\n            may be one of `user_ptime` (default), `file_size` and `file_name`\n        :param bool asc: whether in ascending order\n        :param bool show_dir: whether to show directories\n        :param bool natsort: whether to use natural sort\n\n        Return a list of :class:`.File` or :class:`.Directory` objects\n        """\n        if self.cid is None:\n            return False\n        self.reload()\n        kwargs = {}\n        # `cid` is the only required argument\n        kwargs[\'cid\'] = self.cid\n        kwargs[\'asc\'] = 1 if asc is True else 0\n        kwargs[\'show_dir\'] = 1 if show_dir is True else 0\n        kwargs[\'natsort\'] = 1 if natsort is True else 0\n        kwargs[\'o\'] = order\n\n        # When the downloads directory exists along with its parent directory,\n        # the receiver directory, its parent\'s count (receiver directory\'s\n        # count) does not include the downloads directory. This behavior is\n        # similar to its parent\'s parent (root), the count of which does not\n        # include the receiver directory.\n        # The following code fixed this behavior so that a directory\'s\n        # count correctly reflects the actual number of entries in it\n        # The side-effect that this code may ensure that downloads directory\n        # exists, causing the system to create the receiver directory and\n        # downloads directory, if they do not exist.\n\n        if self.is_root or self == self.api.receiver_directory:\n            self._count += 1\n\n        if self.count <= count:\n            # count should never be greater than self.count\n            count = self.count\n        try:\n            entries = self._load_entries(func=self.api._req_files,\n                                         count=count, page=1, **kwargs)\n        # When natsort=1 and order=\'file_name\', API access will fail\n        except RequestFailure as e:\n            if natsort is True and order == \'file_name\':\n                entries = \\\n                    self._load_entries(func=self.api._req_aps_natsort_files,\n                                       count=count, page=1, **kwargs)\n            else:\n                raise e\n        res = []\n        for entry in entries:\n            if \'pid\' in entry:\n                res.append(_instantiate_directory(self.api, entry))\n            else:\n                res.append(_instantiate_file(self.api, entry))\n        return res\n\n    def mkdir(self, name):\n        """\n        Create a new directory in this directory\n        """\n        self.api.mkdir(self, name)\n'
u'1248,class Task(Base):\n    """\n    BitTorrent or URL task\n\n    :ivar datetime.datetime add_time: added time\n    :ivar str cid: associated directory id, if any. For a directory task (\n        e.g. BT task), this is its associated directory\'s cid. For a file\n        task (e.g. HTTP url task), this is the cid of the downloads directory.\n        This value may be None if the task is failed and has no corresponding\n        directory\n    :ivar str file_id: equivalent to `cid` of :class:`.Directory`. This value\n        may be None if the task is failed and has no corresponding directory\n    :ivar str info_hash: hashed value\n    :ivar datetime.datetime last_update: last updated time\n    :ivar int left_time: left time ()\n    :ivar int move: moving state\n\n        * 0: not transferred\n        * 1: transferred\n        * 2: partially transferred\n\n    :ivar str name: name of this task\n    :ivar int peers: number of peers\n    :ivar int percent_done: <=100, originally named `percentDone`\n    :ivar int rate_download: download rate (B/s), originally named\n        `rateDownload`\n    :ivar int size: size of task\n    :ivar str size_human: human-readable size\n    :ivar int status: status code\n\n        * -1: failed\n        * 1: downloading\n        * 2: downloaded\n        * 4: searching resources\n\n    """\n\n    def __init__(self, api, add_time, file_id, info_hash, last_update,\n                 left_time, move, name, peers, percent_done, rate_download,\n                 size, status, cid, pid, url, *args, **kwargs):\n        self.api = api\n        self.cid = cid\n        self.name = name\n        self.add_time = add_time\n        self.file_id = file_id\n        self.info_hash = info_hash\n        self.last_update = last_update\n        self.left_time = left_time\n        self.move = move\n        self.peers = peers\n        self.percent_done = percent_done\n        self.rate_download = rate_download\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.status = status\n        self.url = url\n        self._directory = None\n        self._deleted = False\n        self._count = -1\n\n    @property\n    def is_directory(self):\n        """\n        :return: whether this task is associated with a directory.\n        :rtype: bool\n        """\n        if self.cid is None:\n            msg = \'Cannot determine whether this task is a directory.\'\n            if not self.is_transferred:\n                msg += \' This task has not been transferred.\'\n            raise TaskError(msg)\n        return self.api.downloads_directory.cid != self.cid\n\n    @property\n    def is_bt(self):\n        """Alias of `is_directory`"""\n        return self.is_directory\n\n    def delete(self):\n        """\n        Delete task (does not influence its corresponding directory)\n\n        :return: whether deletion is successful\n        :raise: :class:`.TaskError` if the task is already deleted\n        """\n        if not self._deleted:\n            if self.api._req_lixian_task_del(self):\n                self._deleted = True\n                return True\n        raise TaskError(\'This task is already deleted.\')\n\n    @property\n    def is_deleted(self):\n        """\n        :return: whether this task is deleted\n        :rtype: bool\n        """\n        return self._deleted\n\n    @property\n    def is_transferred(self):\n        """\n        :return: whether this tasks has been transferred\n        :rtype: bool\n        """\n        return self.move == 1\n\n    @property\n    def status_human(self):\n        """\n        Human readable status\n\n        :return:\n\n            * `DOWNLOADING`: the task is downloading files\n            * `BEING TRANSFERRED`: the task is being transferred\n            * `TRANSFERRED`: the task has been transferred to downloads \\\n                    directory\n            * `SEARCHING RESOURCES`: the task is searching resources\n            * `FAILED`: the task is failed\n            * `DELETED`: the task is deleted\n            * `UNKNOWN STATUS`\n\n        :rtype: str\n\n        """\n        res = None\n        if self._deleted:\n            return \'DELETED\'\n        if self.status == 1:\n            res = \'DOWNLOADING\'\n        elif self.status == 2:\n            if self.move == 0:\n                res = \'BEING TRANSFERRED\'\n            elif self.move == 1:\n                res = \'TRANSFERRED\'\n            elif self.move == 2:\n                res = \'PARTIALLY TRANSFERRED\'\n        elif self.status == 4:\n            res = \'SEARCHING RESOURCES\'\n        elif self.status == -1:\n            res = \'FAILED\'\n        if res is not None:\n            return res\n        return \'UNKNOWN STATUS\'\n\n    @property\n    def directory(self):\n        """Associated directory, if any, with this task"""\n        if not self.is_directory:\n            msg = \'This task is a file task with no associated directory.\'\n            raise TaskError(msg)\n        if self._directory is None:\n            if self.is_transferred:\n                self._directory = self.api._load_directory(self.cid)\n        if self._directory is None:\n            msg = \'No directory assciated with this task: Task is %s.\' % \\\n                self.status_human.lower()\n            raise TaskError(msg)\n        return self._directory\n\n    @property\n    def parent(self):\n        """Parent directory of the associated directory"""\n        return self.directory.parent\n\n    @property\n    def count(self):\n        """Number of entries in the associated directory"""\n        return self.directory.count\n\n    def list(self, count=30, order=\'user_ptime\', asc=False, show_dir=True,\n             natsort=True):\n        """\n        List files of the associated directory to this task.\n\n        :param int count: number of entries to be listed\n        :param str order: originally named `o`\n        :param bool asc: whether in ascending order\n        :param bool show_dir: whether to show directories\n\n        """\n        return self.directory.list(count, order, asc, show_dir, natsort)\n\n    def __unicode__(self):\n        return self.name\n'
u'1249,class Torrent(Base):\n    """\n    Opened torrent before becoming a task\n\n    :ivar api: associated API object\n    :ivar str name: task name, originally named `torrent_name`\n    :ivar int size: task size, originally named `torrent_size`\n    :ivar str info_hash: hashed value\n    :ivar int file_count: number of files included\n    :ivar list files: files included (list of :class:`.TorrentFile`),\n        originally named `torrent_filelist_web`\n    """\n\n    def __init__(self, api, name, size, info_hash, file_count, files=None,\n                 *args, **kwargs):\n        self.api = api\n        self.name = name\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.info_hash = info_hash\n        self.file_count = file_count\n        self.files = files\n        self.submitted = False\n\n    def submit(self):\n        """Submit this torrent and create a new task"""\n        if self.api._req_lixian_add_task_bt(self):\n            self.submitted = True\n            return True\n        return False\n\n    @property\n    def selected_files(self):\n        """List of selected :class:`.TorrentFile` objects of this torrent"""\n        return [f for f in self.files if f.selected]\n\n    @property\n    def unselected_files(self):\n        """List of unselected :class:`.TorrentFile` objects of this torrent"""\n        return [f for f in self.files if not f.selected]\n\n    def __unicode__(self):\n        return self.name\n'
u'1250,class TorrentFile(Base):\n    """\n    File in the torrent file list\n\n    :param torrent: the torrent that holds this file\n    :type torrent: :class:`.Torrent`\n    :param str path: file path in the torrent\n    :param int size: file size\n    :param bool selected: whether this file is selected\n    """\n\n    def __init__(self, torrent, path, size, selected, *args, **kwargs):\n        self.torrent = torrent\n        self.path = path\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.selected = selected\n\n    def select(self):\n        """Select this file"""\n        self.selected = True\n\n    def unselect(self):\n        """Unselect this file"""\n        self.selected = False\n\n    def __unicode__(self):\n        return \'[%s] %s\' % (\'*\' if self.selected else \' \', self.path)\n'
u'1251,def _instantiate_task(api, kwargs):\n    """Create a Task object from raw kwargs"""\n    file_id = kwargs[\'file_id\']\n    kwargs[\'file_id\'] = file_id if str(file_id).strip() else None\n    kwargs[\'cid\'] = kwargs[\'file_id\'] or None\n    kwargs[\'rate_download\'] = kwargs[\'rateDownload\']\n    kwargs[\'percent_done\'] = kwargs[\'percentDone\']\n    kwargs[\'add_time\'] = get_utcdatetime(kwargs[\'add_time\'])\n    kwargs[\'last_update\'] = get_utcdatetime(kwargs[\'last_update\'])\n    is_transferred = (kwargs[\'status\'] == 2 and kwargs[\'move\'] == 1)\n    if is_transferred:\n        kwargs[\'pid\'] = api.downloads_directory.cid\n    else:\n        kwargs[\'pid\'] = None\n    del kwargs[\'rateDownload\']\n    del kwargs[\'percentDone\']\n    if \'url\' in kwargs:\n        if not kwargs[\'url\']:\n            kwargs[\'url\'] = None\n    else:\n        kwargs[\'url\'] = None\n    task = Task(api, **kwargs)\n    if is_transferred:\n        task._parent = api.downloads_directory\n    return task\n'
u"1252,def _instantiate_file(api, kwargs):\n    kwargs['file_type'] = kwargs['ico']\n    kwargs['date_created'] = string_to_datetime(kwargs['t'])\n    kwargs['pickcode'] = kwargs['pc']\n    kwargs['name'] = kwargs['n']\n    kwargs['thumbnail'] = kwargs.get('u')\n    kwargs['size'] = kwargs['s']\n    del kwargs['ico']\n    del kwargs['t']\n    del kwargs['pc']\n    del kwargs['s']\n    if 'u' in kwargs:\n        del kwargs['u']\n    return File(api, **kwargs)\n"
u"1253,def _instantiate_directory(api, kwargs):\n    kwargs['name'] = kwargs['n']\n    kwargs['date_created'] = get_utcdatetime(float(kwargs['t']))\n    kwargs['pickcode'] = kwargs.get('pc')\n    return Directory(api, **kwargs)\n"
u"1254,def _instantiate_uploaded_file(api, kwargs):\n    kwargs['fid'] = kwargs['file_id']\n    kwargs['name'] = kwargs['file_name']\n    kwargs['pickcode'] = kwargs['pick_code']\n    kwargs['size'] = kwargs['file_size']\n    kwargs['sha'] = kwargs['sha1']\n    kwargs['date_created'] = get_utcdatetime(kwargs['file_ptime'])\n    kwargs['thumbnail'] = None\n    _, ft = os.path.splitext(kwargs['name'])\n    kwargs['file_type'] = ft[1:]\n    return File(api, **kwargs)\n"
u"1255,def _instantiate_torrent(api, kwargs):\n    kwargs['size'] = kwargs['file_size']\n    kwargs['name'] = kwargs['torrent_name']\n    file_list = kwargs['torrent_filelist_web']\n    del kwargs['file_size']\n    del kwargs['torrent_name']\n    del kwargs['torrent_filelist_web']\n    torrent = Torrent(api, **kwargs)\n    torrent.files = [_instantiate_torrent_file(torrent, f) for f in file_list]\n    return torrent\n"
u"1256,def _instantiate_torrent_file(torrent, kwargs):\n    kwargs['selected'] = True if kwargs['wanted'] == 1 else False\n    del kwargs['wanted']\n    return TorrentFile(torrent, **kwargs)\n"
u'1257,class APIError(Exception):\n    """General error related to API"""\n    def __init__(self, *args, **kwargs):\n        content = kwargs.pop(\'content\', None)\n        self.content = content\n        super(APIError, self).__init__(*args, **kwargs)\n'
u'1258,class TaskError(APIError):\n    """Task has unstable status or no directory operation"""\n    pass\n'
u'1259,class AuthenticationError(APIError):\n    """Authentication error"""\n    pass\n'
u'1260,class InvalidAPIAccess(APIError):\n    """Invalid and forbidden API access"""\n    pass\n'
u'1261,class RequestFailure(APIError):\n    """Request failure"""\n    pass\n'
u'1262,class JobError(APIError):\n    """Job running error (request multiple similar jobs simultaneously)"""\n    def __init__(self, *args, **kwargs):\n        content = kwargs.pop(\'content\', None)\n        self.content = content\n        if not args:\n            msg = \'Your account has a similar job running. Try again later.\'\n            args = (msg,)\n        super(JobError, self).__init__(*args, **kwargs)\n'
u"1263,    def __init__(self):\n        self.session = requests.Session()\n        self.session.headers['User-Agent'] = USER_AGENT\n"
u'1264,    def get(self, url, params=None):\n        """\n        Initiate a GET request\n        """\n        r = self.session.get(url, params=params)\n        return self._response_parser(r, expect_json=False)\n'
u'1265,    def post(self, url, data, params=None):\n        """\n        Initiate a POST request\n        """\n        r = self.session.post(url, data=data, params=params)\n        return self._response_parser(r, expect_json=False)\n'
u'1266,    def send(self, request, expect_json=True, ignore_content=False):\n        """\n        Send a formatted API request\n\n        :param request: a formatted request object\n        :type request: :class:`.Request`\n        :param bool expect_json: if True, raise :class:`.InvalidAPIAccess` if\n            response is not in JSON format\n        :param bool ignore_content: whether to ignore setting content of the\n            Response object\n        """\n        r = self.session.request(method=request.method,\n                                 url=request.url,\n                                 params=request.params,\n                                 data=request.data,\n                                 files=request.files,\n                                 headers=request.headers)\n        return self._response_parser(r, expect_json, ignore_content)\n'
u'1267,    def _response_parser(self, r, expect_json=True, ignore_content=False):\n        """\n        :param :class:`requests.Response` r: a response object of the Requests\n            library\n        :param bool expect_json: if True, raise :class:`.InvalidAPIAccess` if\n            response is not in JSON format\n        :param bool ignore_content: whether to ignore setting content of the\n            Response object\n        """\n        if r.ok:\n            try:\n                j = r.json()\n                return Response(j.get(\'state\'), j)\n            except ValueError:\n                # No JSON-encoded data returned\n                if expect_json:\n                    logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n                    logger.debug(r.text)\n                    raise InvalidAPIAccess(\'Invalid API access.\')\n                # Raw response\n                if ignore_content:\n                    res = Response(True, None)\n                else:\n                    res = Response(True, r.text)\n                return res\n        else:\n            r.raise_for_status()\n'
u'1268,    def __init__(self, url, method=\'GET\', params=None, data=None,\n                 files=None, headers=None):\n        """\n        Create a Request object\n\n        :param str url: URL\n        :param str method: request method\n        :param dict params: request parameters\n        :param dict data: form data\n        :param dict files: mulitpart form data\n        :param dict headers: custom request headers\n\n        """\n        self.url = url\n        self.method = method\n        self.params = params\n        self.data = data\n        self.files = files\n        self.headers = headers\n        self._debug()\n'
u'1269,    def _debug(self):\n        logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n        level = logger.getEffectiveLevel()\n        if level == logging.DEBUG:\n            func = inspect.stack()[2][3]\n            msg = conf.DEBUG_REQ_FMT % (func, self.url, self.method,\n                                        self.params, self.data)\n            logger.debug(msg)\n'
u'1270,    def __init__(self, state, content):\n        self.state = state\n        self.content = content\n        self._debug()\n'
u'1271,    def _debug(self):\n        logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n        level = logger.getEffectiveLevel()\n        if level == logging.DEBUG:\n            func = inspect.stack()[4][3]\n            msg = conf.DEBUG_RES_FMT % (func, self.state, self.content)\n            logger.debug(msg)\n'
u'1272,    def __init__(self, persistent=False,\n                 cookies_filename=None, cookies_type=\'LWPCookieJar\'):\n        """\n        :param bool auto_logout: whether to logout automatically when\n            :class:`.API` object is destroyed\n\n                                 .. deprecated:: 0.6.0\n                                     Call :meth:`.API.logout` explicitly\n\n        :param bool persistent: whether to use persistent session that stores\n            cookies on disk\n        :param str cookies_filename: path to the cookies file, use default\n            path (`~/.115cookies`) if None\n        :param str cookies_type: a string representing\n            :class:`cookielib.FileCookieJar` subclass,\n            `LWPCookieJar` (default) or `MozillaCookieJar`\n        """\n        self.persistent = persistent\n        self.cookies_filename = cookies_filename\n        self.cookies_type = cookies_type\n        self.passport = None\n        self.http = RequestHandler()\n        self.logger = logging.getLogger(conf.LOGGING_API_LOGGER)\n        # Cache attributes to decrease API hits\n        self._user_id = None\n        self._username = None\n        self._signatures = {}\n        self._upload_url = None\n        self._lixian_timestamp = None\n        self._root_directory = None\n        self._downloads_directory = None\n        self._receiver_directory = None\n        self._torrents_directory = None\n        self._task_count = None\n        self._task_quota = None\n        if self.persistent:\n            self.load_cookies()\n'
u'1273,    def _reset_cache(self):\n        self._user_id = None\n        self._username = None\n        self._signatures = {}\n        self._upload_url = None\n        self._lixian_timestamp = None\n        self._root_directory = None\n        self._downloads_directory = None\n        self._receiver_directory = None\n        self._torrents_directory = None\n        self._task_count = None\n        self._task_quota = None\n'
u"1274,    def _init_cookies(self):\n        # RequestsLWPCookieJar or RequestsMozillaCookieJar\n        cookies_class = globals()['Requests' + self.cookies_type]\n        f = self.cookies_filename or conf.COOKIES_FILENAME\n        self.cookies = cookies_class(f)\n"
u'1275,    def load_cookies(self, ignore_discard=True, ignore_expires=True):\n        """Load cookies from the file :attr:`.API.cookies_filename`"""\n        self._init_cookies()\n        if os.path.exists(self.cookies.filename):\n            self.cookies.load(ignore_discard=ignore_discard,\n                              ignore_expires=ignore_expires)\n            self._reset_cache()\n'
u'1276,    def save_cookies(self, ignore_discard=True, ignore_expires=True):\n        """Save cookies to the file :attr:`.API.cookies_filename`"""\n        if not isinstance(self.cookies, cookielib.FileCookieJar):\n            m = \'Cookies must be a cookielib.FileCookieJar object to be saved.\'\n            raise APIError(m)\n        self.cookies.save(ignore_discard=ignore_discard,\n                          ignore_expires=ignore_expires)\n'
u'1277,    @property\n    def cookies(self):\n        """\n        Cookies of the current API session (cookies getter shortcut)\n        """\n        return self.http.session.cookies\n'
u'1278,    @cookies.setter\n    def cookies(self, cookies):\n        """\n        Cookies of the current API session (cookies setter shortcut)\n        """\n        self.http.session.cookies = cookies\n'
u'1279,    def login(self, username=None, password=None,\n              section=\'default\'):\n        """\n        Created the passport with ``username`` and ``password`` and log in.\n        If either ``username`` or ``password`` is None or omitted, the\n        credentials file will be parsed.\n\n        :param str username: username to login (email, phone number or user ID)\n        :param str password: password\n        :param str section: section name in the credential file\n        :raise: raises :class:`.AuthenticationError` if failed to login\n        """\n        if self.has_logged_in:\n            return True\n        if username is None or password is None:\n            credential = conf.get_credential(section)\n            username = credential[\'username\']\n            password = credential[\'password\']\n\n        passport = Passport(username, password)\n        r = self.http.post(LOGIN_URL, passport.form)\n\n        if r.state is True:\n            # Bind this passport to API\n            self.passport = passport\n            passport.data = r.content[\'data\']\n            self._user_id = r.content[\'data\'][\'USER_ID\']\n            return True\n        else:\n            msg = None\n            if \'err_name\' in r.content:\n                if r.content[\'err_name\'] == \'account\':\n                    msg = \'Account does not exist.\'\n                elif r.content[\'err_name\'] == \'passwd\':\n                    msg = \'Password is incorrect.\'\n            raise AuthenticationError(msg)\n'
u'1280,    def get_user_info(self):\n        """\n        Get user info\n\n        :return: a dictionary of user information\n        :rtype: dict\n\n        """\n        return self._req_get_user_aq()\n'
u'1281,    @property\n    def user_id(self):\n        """\n        User id of the current API user\n        """\n        if self._user_id is None:\n            if self.has_logged_in:\n                self._user_id = self._req_get_user_aq()[\'data\'][\'uid\']\n            else:\n                raise AuthenticationError(\'Not logged in.\')\n        return self._user_id\n'
u'1282,    @property\n    def username(self):\n        """\n        Username of the current API user\n        """\n        if self._username is None:\n            if self.has_logged_in:\n                self._username = self._get_username()\n            else:\n                raise AuthenticationError(\'Not logged in.\')\n        return self._username\n'
u'1283,    @property\n    def has_logged_in(self):\n        """Check whether the API has logged in"""\n        r = self.http.get(CHECKPOINT_URL)\n        if r.state is False:\n            return True\n        # If logged out, flush cache\n        self._reset_cache()\n        return False\n'
u'1284,    def logout(self):\n        """Log out"""\n        self.http.get(LOGOUT_URL)\n        self._reset_cache()\n        return True\n'
u'1285,    @property\n    def root_directory(self):\n        """Root directory"""\n        if self._root_directory is None:\n            self._load_root_directory()\n        return self._root_directory\n'
u'1286,    @property\n    def downloads_directory(self):\n        """Default directory for downloaded files"""\n        if self._downloads_directory is None:\n            self._load_downloads_directory()\n        return self._downloads_directory\n'
u'1287,    @property\n    def receiver_directory(self):\n        """Parent directory of the downloads directory"""\n        if self._receiver_directory is None:\n            self._receiver_directory = self.downloads_directory.parent\n        return self._receiver_directory\n'
u'1288,    @property\n    def torrents_directory(self):\n        """Default directory that stores uploaded torrents"""\n        if self._torrents_directory is None:\n            self._load_torrents_directory()\n        return self._torrents_directory\n'
u'1289,    @property\n    def task_count(self):\n        """\n        Number of tasks created\n        """\n        self._req_lixian_task_lists()\n        return self._task_count\n'
u'1290,    @property\n    def task_quota(self):\n        """\n        Task quota (monthly)\n        """\n        self._req_lixian_task_lists()\n        return self._task_quota\n'
u'1291,    def get_tasks(self, count=30):\n        """\n        Get ``count`` number of tasks\n\n        :param int count: number of tasks to get\n        :return: a list of :class:`.Task` objects\n        """\n\n        return self._load_tasks(count)\n'
u'1292,    def add_task_bt(self, filename, select=False):\n        """\n        Add a new BT task\n\n        :param str filename: path to torrent file to upload\n        :param bool select: whether to select files in the torrent.\n\n            * True: it returns the opened torrent (:class:`.Torrent`) and\n                can then iterate files in :attr:`.Torrent.files` and\n                select/unselect them before calling :meth:`.Torrent.submit`\n            * False: it will submit the torrent with default selected files\n\n        """\n        filename = eval_path(filename)\n        u = self.upload(filename, self.torrents_directory)\n        t = self._load_torrent(u)\n        if select:\n            return t\n        return t.submit()\n'
u'1293,    def add_task_url(self, target_url):\n        """\n        Add a new URL task\n\n        :param str target_url: the URL of the file that to be downloaded\n\n        """\n        return self._req_lixian_add_task_url(target_url)\n'
u'1294,    def get_storage_info(self, human=False):\n        """\n        Get storage info\n\n        :param bool human: whether return human-readable size\n        :return: total and used storage\n        :rtype: dict\n\n        """\n        res = self._req_get_storage_info()\n        if human:\n            res[\'total\'] = humanize.naturalsize(res[\'total\'], binary=True)\n            res[\'used\'] = humanize.naturalsize(res[\'used\'], binary=True)\n        return res\n'
u'1295,    def upload(self, filename, directory=None):\n        """\n        Upload a file ``filename`` to ``directory``\n\n        :param str filename: path to the file to upload\n        :param directory: destionation :class:`.Directory`, defaults to\n            :attribute:`.API.downloads_directory` if None\n        :return: the uploaded file\n        :rtype: :class:`.File`\n        """\n        filename = eval_path(filename)\n        if directory is None:\n            directory = self.downloads_directory\n\n        # First request\n        res1 = self._req_upload(filename, directory)\n        data1 = res1[\'data\']\n        file_id = data1[\'file_id\']\n\n        # Second request\n        res2 = self._req_file(file_id)\n        data2 = res2[\'data\'][0]\n        data2.update(**data1)\n        return _instantiate_uploaded_file(self, data2)\n'
u'1296,    def download(self, obj, path=None, show_progress=True, resume=True,\n                 auto_retry=True, proapi=False):\n        """\n        Download a file\n\n        :param obj: :class:`.File` object\n        :param str path: local path\n        :param bool show_progress: whether to show download progress\n        :param bool resume: whether to resume on unfinished downloads\n            identified by filename\n        :param bool auto_retry: whether to retry automatically upon closed\n            transfer until the file\'s download is finished\n        :param bool proapi: whether to use pro API\n        """\n        url = obj.get_download_url(proapi)\n        download(url, path=path, session=self.http.session,\n                 show_progress=show_progress, resume=resume,\n                 auto_retry=auto_retry)\n'
u'1297,    def search(self, keyword, count=30):\n        """\n        Search files or directories\n\n        :param str keyword: keyword\n        :param int count: number of entries to be listed\n        """\n        kwargs = {}\n        kwargs[\'search_value\'] = keyword\n        root = self.root_directory\n        entries = root._load_entries(func=self._req_files_search,\n                                     count=count, page=1, **kwargs)\n\n        res = []\n        for entry in entries:\n            if \'pid\' in entry:\n                res.append(_instantiate_directory(self, entry))\n            else:\n                res.append(_instantiate_file(self, entry))\n        return res\n'
u'1298,    def move(self, entries, directory):\n        """\n        Move one or more entries (file or directory) to the destination\n        directory\n\n        :param list entries: a list of source entries (:class:`.BaseFile`\n            object)\n        :param directory: destination directory\n        :return: whether the action is successful\n        :raise: :class:`.APIError` if something bad happened\n        """\n        fcids = []\n        for entry in entries:\n            if isinstance(entry, File):\n                fcid = entry.fid\n            elif isinstance(entry, Directory):\n                fcid = entry.cid\n            else:\n                raise APIError(\'Invalid BaseFile instance for an entry.\')\n            fcids.append(fcid)\n        if not isinstance(directory, Directory):\n            raise APIError(\'Invalid destination directory.\')\n        if self._req_files_move(directory.cid, fcids):\n            for entry in entries:\n                if isinstance(entry, File):\n                    entry.cid = directory.cid\n                entry.reload()\n            return True\n        else:\n            raise APIError(\'Error moving entries.\')\n'
u'1299,    def edit(self, entry, name, mark=False):\n        """\n        Edit an entry (file or directory)\n\n        :param entry: :class:`.BaseFile` object\n        :param str name: new name for the entry\n        :param bool mark: whether to bookmark the entry\n        """\n        fcid = None\n        if isinstance(entry, File):\n            fcid = entry.fid\n        elif isinstance(entry, Directory):\n            fcid = entry.cid\n        else:\n            raise APIError(\'Invalid BaseFile instance for an entry.\')\n        is_mark = 0\n        if mark is True:\n            is_mark = 1\n        if self._req_files_edit(fcid, name, is_mark):\n            entry.reload()\n            return True\n        else:\n            raise APIError(\'Error editing the entry.\')\n'
u'1300,    def mkdir(self, parent, name):\n        """\n        Create a directory\n\n        :param parent: the parent directory\n        :param str name: the name of the new directory\n        :return: the new directory\n        :rtype: :class:`.Directory`\n\n        """\n        pid = None\n        cid = None\n        if isinstance(parent, Directory):\n            pid = parent.cid\n        else:\n            raise(\'Invalid Directory instance.\')\n        cid = self._req_files_add(pid, name)[\'cid\']\n        return self._load_directory(cid)\n'
u'1301,    def _req_offline_space(self):\n        """Required before accessing lixian tasks"""\n        url = \'http://115.com/\'\n        params = {\n            \'ct\': \'offline\',\n            \'ac\': \'space\',\n            \'_\': get_timestamp(13)\n        }\n        _sign = os.environ.get(\'U115_BROWSER_SIGN\')\n        if _sign is not None:\n            _time = os.environ.get(\'U115_BROWSER_TIME\')\n            if _time is None:\n                msg = \'U115_BROWSER_TIME is required given U115_BROWSER_SIGN.\'\n                raise APIError(msg)\n            params[\'sign\'] = _sign\n            params[\'time\'] = _time\n            params[\'uid\'] = self.user_id\n        req = Request(url=url, params=params)\n        r = self.http.send(req)\n        if r.state:\n            self._signatures[\'offline_space\'] = r.content[\'sign\']\n            self._lixian_timestamp = r.content[\'time\']\n        else:\n            msg = \'Failed to retrieve signatures.\'\n            raise RequestFailure(msg)\n'
u'1302,    def _req_lixian_task_lists(self, page=1):\n        """\n        This request will cause the system to create a default downloads\n        directory if it does not exist\n        """\n        url = \'http://115.com/lixian/\'\n        params = {\'ct\': \'lixian\', \'ac\': \'task_lists\'}\n        self._load_signatures()\n        data = {\n            \'page\': page,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            self._task_count = res.content[\'count\']\n            self._task_quota = res.content[\'quota\']\n            return res.content[\'tasks\']\n        else:\n            msg = \'Failed to get tasks.\'\n            raise RequestFailure(msg)\n'
u'1303,    def _req_lixian_get_id(self, torrent=False):\n        """Get `cid` of lixian space directory"""\n        url = \'http://115.com/\'\n        params = {\n            \'ct\': \'lixian\',\n            \'ac\': \'get_id\',\n            \'torrent\': 1 if torrent else None,\n            \'_\': get_timestamp(13)\n        }\n        req = Request(method=\'GET\', url=url, params=params)\n        res = self.http.send(req)\n        return res.content\n'
u'1304,    def _req_lixian_torrent(self, u):\n        """\n        :param u: uploaded torrent file\n        """\n\n        self._load_signatures()\n        url = \'http://115.com/lixian/\'\n        params = {\n            \'ct\': \'lixian\',\n            \'ac\': \'torrent\',\n        }\n        data = {\n            \'pickcode\': u.pickcode,\n            \'sha1\': u.sha,\n            \'uid\': self.user_id,\n            \'sign\': self._signatures[\'offline_space\'],\n            \'time\': self._lixian_timestamp,\n        }\n        req = Request(method=\'POST\', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            msg = res.content.get(\'error_msg\')\n            self.logger.error(msg)\n            raise RequestFailure(\'Failed to open torrent.\')\n'
u"1305,    def _req_lixian_add_task_bt(self, t):\n\n        self._load_signatures()\n        url = 'http://115.com/lixian/'\n        params = {'ct': 'lixian', 'ac': 'add_task_bt'}\n        _wanted = []\n        for i, b in enumerate(t.files):\n            if b.selected:\n                _wanted.append(str(i))\n        wanted = ','.join(_wanted)\n        data = {\n            'info_hash': t.info_hash,\n            'wanted': wanted,\n            'savepath': t.name,\n            'uid': self.user_id,\n            'sign': self._signatures['offline_space'],\n            'time': self._lixian_timestamp,\n        }\n        req = Request(method='POST', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            msg = res.content.get('error_msg')\n            self.logger.error(msg)\n            raise RequestFailure('Failed to create new task.')\n"
u"1306,    def _req_lixian_add_task_url(self, target_url):\n\n        self._load_signatures()\n        url = 'http://115.com/lixian/'\n        params = {'ct': 'lixian', 'ac': 'add_task_url'}\n        data = {\n            'url': target_url,\n            'uid': self.user_id,\n            'sign': self._signatures['offline_space'],\n            'time': self._lixian_timestamp,\n        }\n        req = Request(method='POST', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            msg = res.content.get('error_msg')\n            self.logger.error(msg)\n            raise RequestFailure('Failed to create new task.')\n"
u"1307,    def _req_lixian_task_del(self, t):\n\n        self._load_signatures()\n        url = 'http://115.com/lixian/'\n        params = {'ct': 'lixian', 'ac': 'task_del'}\n        data = {\n            'hash[0]': t.info_hash,\n            'uid': self.user_id,\n            'sign': self._signatures['offline_space'],\n            'time': self._lixian_timestamp,\n        }\n        req = Request(method='POST', url=url, params=params, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure('Failed to delete the task.')\n"
u"1308,    def _req_file_userfile(self):\n\n        url = 'http://115.com/'\n        params = {\n            'ct': 'file',\n            'ac': 'userfile',\n            'is_wl_tpl': 1,\n        }\n        req = Request(method='GET', url=url, params=params)\n        self.http.send(req, expect_json=False, ignore_content=True)\n"
u'1309,    def _req_aps_natsort_files(self, cid, offset, limit, o=\'file_name\',\n                               asc=1, aid=1, show_dir=1, code=None, scid=None,\n                               snap=0, natsort=1, source=None, type=0,\n                               format=\'json\', star=None, is_share=None):\n        """\n        When :meth:`.API._req_files` is called with `o=\'filename\'` and\n            `natsort=1`, API access will fail\n            and :meth:`.API._req_aps_natsort_files` is subsequently called with\n            the same kwargs. Refer to the implementation in\n            :meth:`.Directory.list`\n        """\n        params = locals()\n        del params[\'self\']\n        req = Request(method=\'GET\', url=self.aps_natsort_url, params=params)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n'
u'1310,    def _req_files(self, cid, offset, limit, o=\'user_ptime\', asc=1, aid=1,\n                   show_dir=1, code=None, scid=None, snap=0, natsort=1,\n                   source=None, type=0, format=\'json\', star=None,\n                   is_share=None):\n        """\n        :param int type: type of files to be displayed\n\n            * \'\' (empty string): marked\n            * None: all\n            * 0: all\n            * 1: documents\n            * 2: images\n            * 3: music\n            * 4: video\n            * 5: zipped\n            * 6: applications\n            * 99: files only\n        """\n        params = locals()\n        del params[\'self\']\n        req = Request(method=\'GET\', url=self.web_api_url, params=params)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n'
u"1311,    def _req_files_search(self, offset, limit, search_value, aid=-1,\n                          date=None, pick_code=None, source=None, type=0,\n                          format='json'):\n        params = locals()\n        del params['self']\n        url = self.web_api_url + '/search'\n        req = Request(method='GET', url=url, params=params)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure('Failed to access files API.')\n"
u'1312,    def _req_files_edit(self, fid, file_name=None, is_mark=0):\n        """Edit a file or directory"""\n        url = self.web_api_url + \'/edit\'\n        data = locals()\n        del data[\'self\']\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n'
u'1313,    def _req_files_add(self, pid, cname):\n        """\n        Add a directory\n        :param str pid: parent directory id\n        :param str cname: directory name\n        """\n        url = self.web_api_url + \'/add\'\n        data = locals()\n        del data[\'self\']\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n'
u'1314,    def _req_files_move(self, pid, fids):\n        """\n        Move files or directories\n        :param str pid: destination directory id\n        :param list fids: a list of ids of files or directories to be moved\n        """\n        url = self.web_api_url + \'/move\'\n        data = {}\n        data[\'pid\'] = pid\n        for i, fid in enumerate(fids):\n            data[\'fid[%d]\' % i] = fid\n        req = Request(method=\'POST\', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            raise RequestFailure(\'Failed to access files API.\')\n'
u"1315,    def _req_file(self, file_id):\n        url = self.web_api_url + '/file'\n        data = {'file_id': file_id}\n        req = Request(method='POST', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            raise RequestFailure('Failed to access files API.')\n"
u'1316,    def _req_directory(self, cid):\n        """Return name and pid of by cid"""\n        res = self._req_files(cid=cid, offset=0, limit=1, show_dir=1)\n        path = res[\'path\']\n        count = res[\'count\']\n        for d in path:\n            if str(d[\'cid\']) == str(cid):\n                res = {\n                    \'cid\': d[\'cid\'],\n                    \'name\': d[\'name\'],\n                    \'pid\': d[\'pid\'],\n                    \'count\': count,\n                }\n                return res\n        else:\n            raise RequestFailure(\'No directory found.\')\n'
u"1317,    def _req_files_download_url(self, pickcode, proapi=False):\n        if '_115_curtime' not in self.cookies:\n            self._req_file_userfile()\n        if not proapi:\n            url = self.web_api_url + '/download'\n            params = {'pickcode': pickcode, '_': get_timestamp(13)}\n        else:\n            url = self.proapi_url\n            params = {'pickcode': pickcode, 'method': 'get_file_url'}\n        headers = {\n            'Referer': self.referer_url,\n        }\n        req = Request(method='GET', url=url, params=params,\n                      headers=headers)\n        res = self.http.send(req)\n        if res.state:\n            if not proapi:\n                return res.content['file_url']\n            else:\n                fid = res.content['data'].keys()[0]\n                return res.content['data'][fid]['url']['url']\n        else:\n            raise RequestFailure('Failed to get download URL.')\n"
u"1318,    def _req_get_storage_info(self):\n        url = 'http://115.com'\n        params = {\n            'ct': 'ajax',\n            'ac': 'get_storage_info',\n            '_': get_timestamp(13),\n        }\n        req = Request(method='GET', url=url, params=params)\n        res = self.http.send(req)\n        return res.content['1']\n"
u'1319,    def _req_upload(self, filename, directory):\n        """Raw request to upload a file ``filename``"""\n        self._upload_url = self._load_upload_url()\n        self.http.get(\'http://upload.115.com/crossdomain.xml\')\n        b = os.path.basename(filename)\n        target = \'U_1_\' + str(directory.cid)\n        files = {\n            \'Filename\': (\'\', quote(b), \'\'),\n            \'target\': (\'\', target, \'\'),\n            \'Filedata\': (quote(b), open(filename, \'rb\'), \'\'),\n            \'Upload\': (\'\', \'Submit Query\', \'\'),\n        }\n        req = Request(method=\'POST\', url=self._upload_url, files=files)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n        else:\n            msg = None\n            if res.content[\'code\'] == 990002:\n                msg = \'Invalid parameter.\'\n            elif res.content[\'code\'] == 1001:\n                msg = \'Torrent upload failed. Please try again later.\'\n            raise RequestFailure(msg)\n'
u"1320,    def _req_rb_delete(self, fcid, pid):\n\n        url = 'http://web.api.115.com/rb/delete'\n        data = {\n            'pid': pid,\n            'fid[0]': fcid,\n        }\n        req = Request(method='POST', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return True\n        else:\n            msg = 'Failed to delete this file or directory.'\n            if 'errno' in res.content:\n                if res.content['errno'] == 990005:\n                    raise JobError()\n            self.logger.error(res.content['error'])\n            raise APIError(msg)\n"
u"1321,    def _req_get_user_aq(self):\n        url = 'http://my.115.com/'\n        data = {\n            'ct': 'ajax',\n            'ac': 'get_user_aq'\n        }\n        req = Request(method='POST', url=url, data=data)\n        res = self.http.send(req)\n        if res.state:\n            return res.content\n"
u'1322,    def _load_signatures(self, force=True):\n        if not self._signatures or force:\n            self._req_offline_space()\n'
u'1323,    def _load_tasks(self, count, page=1, tasks=None):\n        if tasks is None:\n            tasks = []\n        req_tasks = self._req_lixian_task_lists(page)\n        loaded_tasks = []\n        if req_tasks is not None:\n            loaded_tasks = [\n                _instantiate_task(self, t) for t in req_tasks[:count]\n            ]\n        if count <= self.num_tasks_per_page or req_tasks is None:\n            return tasks + loaded_tasks\n        else:\n            return self._load_tasks(count - self.num_tasks_per_page,\n                                    page + 1, tasks + loaded_tasks)\n'
u"1324,    def _load_directory(self, cid):\n        kwargs = self._req_directory(cid)\n        if str(kwargs['pid']) != str(cid):\n            return Directory(api=self, **kwargs)\n"
u'1325,    def _load_root_directory(self):\n        """\n        Load root directory, which has a cid of 0\n        """\n        kwargs = self._req_directory(0)\n        self._root_directory = Directory(api=self, **kwargs)\n'
u'1326,    def _load_torrents_directory(self):\n        """\n        Load torrents directory\n\n        If it does not exist yet, this request will cause the system to create\n        one\n        """\n        r = self._req_lixian_get_id(torrent=True)\n        self._downloads_directory = self._load_directory(r[\'cid\'])\n'
u'1327,    def _load_downloads_directory(self):\n        """\n        Load downloads directory\n\n        If it does not exist yet, this request will cause the system to create\n        one\n        """\n        r = self._req_lixian_get_id(torrent=False)\n        self._downloads_directory = self._load_directory(r[\'cid\'])\n'
u"1328,    def _load_upload_url(self):\n        res = self._parse_src_js_var('upload_config_h5')\n        return res['url']\n"
u'1329,    def _load_torrent(self, u):\n        res = self._req_lixian_torrent(u)\n        return _instantiate_torrent(self, res)\n'
u'1330,    def _parse_src_js_var(self, variable):\n        """Parse JavaScript variables in the source page"""\n\n        src_url = \'http://115.com\'\n        r = self.http.get(src_url)\n        soup = BeautifulSoup(r.content)\n        scripts = [script.text for script in soup.find_all(\'script\')]\n        text = \'\\n\'.join(scripts)\n        pattern = "%s\\s*=\\s*(.*);" % (variable.upper())\n        m = re.search(pattern, text)\n        if not m:\n            msg = \'Cannot parse source JavaScript for %s.\' % variable\n            raise APIError(msg)\n        return json.loads(m.group(1).strip())\n'
u"1331,    def _get_username(self):\n        return unquote(self.cookies.get('OOFL'))\n"
u"1332,    def __repr__(self):\n        try:\n            u = self.__str__()\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            u = '[Bad Unicode data]'\n        repr_type = type(u)\n        return repr_type('<%s: %s>' % (self.__class__.__name__, u))\n"
u"1333,    def __str__(self):\n        if hasattr(self, '__unicode__'):\n            if PY3:\n                return self.__unicode__()\n            else:\n                return unicode(self).encode('utf-8')\n        return txt_type('%s object' % self.__class__.__name__)\n"
u'1334,    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.form = self._form()\n        self.data = None\n'
u"1335,    def _form(self):\n        vcode = self._vcode()\n        f = {\n            'login[ssoent]': 'A1',\n            'login[version]': '2.0',\n            'login[ssoext]': vcode,\n            'login[ssoln]': self.username,\n            'login[ssopw]': self._ssopw(vcode),\n            'login[ssovcode]': vcode,\n            'login[safe]': '1',\n            'login[time]': '0',\n            'login[safe_login]': '0',\n            'goto': 'http://115.com/',\n        }\n        return f\n"
u"1336,    def _vcode(self):\n        s = '%.6f' % time.time()\n        whole, frac = map(int, s.split('.'))\n        res = '%.8x%.5x' % (whole, frac)\n        return res\n"
u'1337,    def _ssopw(self, vcode):\n        p = sha1(utf8_encode(self.password)).hexdigest()\n        u = sha1(utf8_encode(self.username)).hexdigest()\n        v = vcode.upper()\n        pu = sha1(utf8_encode(p + u)).hexdigest()\n        return sha1(utf8_encode(pu + v)).hexdigest()\n'
u'1338,    def __unicode__(self):\n        return self.username\n'
u'1339,    def __init__(self, api, cid, name):\n        """\n        :param API api: associated API object\n        :param str cid: directory id\n\n            * For file: this represents the directory it belongs to;\n            * For directory: this represents itself\n\n        :param str name: originally named `n`\n\n        NOTICE\n            cid, fid and pid are in string format at this time\n        """\n        self.api = api\n        self.cid = cid\n        self.name = name\n        self._deleted = False\n'
u'1340,    def delete(self):\n        """\n        Delete this file or directory\n\n        :return: whether deletion is successful\n        :raise: :class:`.APIError` if this file or directory is already deleted\n\n        """\n        fcid = None\n        pid = None\n\n        if isinstance(self, File):\n            fcid = self.fid\n            pid = self.cid\n        elif isinstance(self, Directory):\n            fcid = self.cid\n            pid = self.pid\n        else:\n            raise APIError(\'Invalid BaseFile instance.\')\n\n        if not self._deleted:\n            if self.api._req_rb_delete(fcid, pid):\n                self._deleted = True\n                return True\n        else:\n            raise APIError(\'This file or directory is already deleted.\')\n'
u'1341,    def move(self, directory):\n        """\n        Move this file or directory to the destination directory\n\n        :param directory: destination directory\n        :return: whether the action is successful\n        :raise: :class:`.APIError` if something bad happened\n        """\n        self.api.move([self], directory)\n'
u'1342,    def edit(self, name, mark=False):\n        """\n        Edit this file or directory\n\n        :param str name: new name for this entry\n        :param bool mark: whether to bookmark this entry\n        """\n        self.api.edit(self, name, mark)\n'
u'1343,    @property\n    def is_deleted(self):\n        """Whether this file or directory is deleted"""\n        return self._deleted\n'
u'1344,    def __eq__(self, other):\n        if isinstance(self, File):\n            if isinstance(other, File):\n                return self.fid == other.fid\n        elif isinstance(self, Directory):\n            if isinstance(other, Directory):\n                return self.cid == other.cid\n        return False\n'
u'1345,    def __ne__(self, other):\n        return not self.__eq__(other)\n'
u'1346,    def __unicode__(self):\n        return self.name\n'
u'1347,    def __init__(self, api, fid, cid, name, size, file_type, sha,\n                 date_created, thumbnail, pickcode, *args, **kwargs):\n\n        super(File, self).__init__(api, cid, name)\n\n        self.fid = fid\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.file_type = file_type\n        self.sha = sha\n        self.date_created = date_created\n        self.thumbnail = thumbnail\n        self.pickcode = pickcode\n        self._directory = None\n        self._download_url = None\n'
u'1348,    @property\n    def directory(self):\n        """Directory that holds this file"""\n        if self._directory is None:\n            self._directory = self.api._load_directory(self.cid)\n        return self._directory\n'
u'1349,    def get_download_url(self, proapi=False):\n        """\n        Get this file\'s download URL\n\n        :param bool proapi: whether to use pro API\n\n        """\n        if self._download_url is None:\n            self._download_url = \\\n                self.api._req_files_download_url(self.pickcode, proapi)\n        return self._download_url\n'
u'1350,    @property\n    def url(self):\n        """Alias for :meth:`.File.get_download_url` with `proapi=False`"""\n        return self.get_download_url()\n'
u'1351,    def download(self, path=None, show_progress=True, resume=True,\n                 auto_retry=True, proapi=False):\n        """Download this file"""\n        self.api.download(self, path, show_progress, resume, auto_retry,\n                          proapi)\n'
u'1352,    @property\n    def is_torrent(self):\n        """Whether the file is a torrent"""\n        return self.file_type == \'torrent\'\n'
u'1353,    def open_torrent(self):\n        """\n        Open the torrent (if it is a torrent)\n\n        :return: opened torrent\n        :rtype: :class:`.Torrent`\n        """\n        if self.is_torrent:\n            return self.api._load_torrent(self)\n'
u'1354,    def reload(self):\n        """\n        Reload file info and metadata\n\n        * name\n        * sha\n        * pickcode\n\n        """\n        res = self.api._req_file(self.fid)\n        data = res[\'data\'][0]\n        self.name = data[\'file_name\']\n        self.sha = data[\'sha1\']\n        self.pickcode = data[\'pick_code\']\n'
u'1355,    def __init__(self, api, cid, name, pid, count=-1,\n                 date_created=None, pickcode=None, is_root=False,\n                 *args, **kwargs):\n        super(Directory, self).__init__(api, cid, name)\n\n        self.pid = pid\n        self._count = count\n        if date_created is not None:\n            self.date_created = date_created\n        self.pickcode = pickcode\n        self._parent = None\n'
u'1356,    @property\n    def is_root(self):\n        """Whether this directory is the root directory"""\n        return int(self.cid) == 0\n'
u'1357,    @property\n    def parent(self):\n        """Parent directory that holds this directory"""\n        if self._parent is None:\n            if self.pid is not None:\n                self._parent = self.api._load_directory(self.pid)\n        return self._parent\n'
u'1358,    @property\n    def count(self):\n        """Number of entries in this directory"""\n        if self._count == -1:\n            self.reload()\n        return self._count\n'
u'1359,    def reload(self):\n        """\n        Reload directory info and metadata\n\n        * `name`\n        * `pid`\n        * `count`\n\n        """\n        r = self.api._req_directory(self.cid)\n        self.pid = r[\'pid\']\n        self.name = r[\'name\']\n        self._count = r[\'count\']\n'
u'1360,    def _load_entries(self, func, count, page=1, entries=None, **kwargs):\n        """\n        Load entries\n\n        :param function func: function (:meth:`.API._req_files` or\n            :meth:`.API._req_search`) that returns entries\n        :param int count: number of entries to load. This value should never\n            be greater than self.count\n        :param int page: page number (starting from 1)\n\n        """\n        if entries is None:\n            entries = []\n        res = \\\n            func(offset=(page - 1) * self.max_entries_per_load,\n                 limit=self.max_entries_per_load,\n                 **kwargs)\n        loaded_entries = [\n            entry for entry in res[\'data\'][:count]\n        ]\n        #total_count = res[\'count\']\n        total_count = self.count\n        # count should never be greater than total_count\n        if count > total_count:\n            count = total_count\n        if count <= self.max_entries_per_load:\n            return entries + loaded_entries\n        else:\n            cur_count = count - self.max_entries_per_load\n            return self._load_entries(\n                func=func, count=cur_count, page=page + 1,\n                entries=entries + loaded_entries, **kwargs)\n'
u'1361,    def list(self, count=30, order=\'user_ptime\', asc=False, show_dir=True,\n             natsort=True):\n        """\n        List directory contents\n\n        :param int count: number of entries to be listed\n        :param str order: order of entries, originally named `o`. This value\n            may be one of `user_ptime` (default), `file_size` and `file_name`\n        :param bool asc: whether in ascending order\n        :param bool show_dir: whether to show directories\n        :param bool natsort: whether to use natural sort\n\n        Return a list of :class:`.File` or :class:`.Directory` objects\n        """\n        if self.cid is None:\n            return False\n        self.reload()\n        kwargs = {}\n        # `cid` is the only required argument\n        kwargs[\'cid\'] = self.cid\n        kwargs[\'asc\'] = 1 if asc is True else 0\n        kwargs[\'show_dir\'] = 1 if show_dir is True else 0\n        kwargs[\'natsort\'] = 1 if natsort is True else 0\n        kwargs[\'o\'] = order\n\n        # When the downloads directory exists along with its parent directory,\n        # the receiver directory, its parent\'s count (receiver directory\'s\n        # count) does not include the downloads directory. This behavior is\n        # similar to its parent\'s parent (root), the count of which does not\n        # include the receiver directory.\n        # The following code fixed this behavior so that a directory\'s\n        # count correctly reflects the actual number of entries in it\n        # The side-effect that this code may ensure that downloads directory\n        # exists, causing the system to create the receiver directory and\n        # downloads directory, if they do not exist.\n\n        if self.is_root or self == self.api.receiver_directory:\n            self._count += 1\n\n        if self.count <= count:\n            # count should never be greater than self.count\n            count = self.count\n        try:\n            entries = self._load_entries(func=self.api._req_files,\n                                         count=count, page=1, **kwargs)\n        # When natsort=1 and order=\'file_name\', API access will fail\n        except RequestFailure as e:\n            if natsort is True and order == \'file_name\':\n                entries = \\\n                    self._load_entries(func=self.api._req_aps_natsort_files,\n                                       count=count, page=1, **kwargs)\n            else:\n                raise e\n        res = []\n        for entry in entries:\n            if \'pid\' in entry:\n                res.append(_instantiate_directory(self.api, entry))\n            else:\n                res.append(_instantiate_file(self.api, entry))\n        return res\n'
u'1362,    def mkdir(self, name):\n        """\n        Create a new directory in this directory\n        """\n        self.api.mkdir(self, name)\n'
u'1363,    def __init__(self, api, add_time, file_id, info_hash, last_update,\n                 left_time, move, name, peers, percent_done, rate_download,\n                 size, status, cid, pid, url, *args, **kwargs):\n        self.api = api\n        self.cid = cid\n        self.name = name\n        self.add_time = add_time\n        self.file_id = file_id\n        self.info_hash = info_hash\n        self.last_update = last_update\n        self.left_time = left_time\n        self.move = move\n        self.peers = peers\n        self.percent_done = percent_done\n        self.rate_download = rate_download\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.status = status\n        self.url = url\n        self._directory = None\n        self._deleted = False\n        self._count = -1\n'
u'1364,    @property\n    def is_directory(self):\n        """\n        :return: whether this task is associated with a directory.\n        :rtype: bool\n        """\n        if self.cid is None:\n            msg = \'Cannot determine whether this task is a directory.\'\n            if not self.is_transferred:\n                msg += \' This task has not been transferred.\'\n            raise TaskError(msg)\n        return self.api.downloads_directory.cid != self.cid\n'
u'1365,    @property\n    def is_bt(self):\n        """Alias of `is_directory`"""\n        return self.is_directory\n'
u'1366,    def delete(self):\n        """\n        Delete task (does not influence its corresponding directory)\n\n        :return: whether deletion is successful\n        :raise: :class:`.TaskError` if the task is already deleted\n        """\n        if not self._deleted:\n            if self.api._req_lixian_task_del(self):\n                self._deleted = True\n                return True\n        raise TaskError(\'This task is already deleted.\')\n'
u'1367,    @property\n    def is_deleted(self):\n        """\n        :return: whether this task is deleted\n        :rtype: bool\n        """\n        return self._deleted\n'
u'1368,    @property\n    def is_transferred(self):\n        """\n        :return: whether this tasks has been transferred\n        :rtype: bool\n        """\n        return self.move == 1\n'
u'1369,    @property\n    def status_human(self):\n        """\n        Human readable status\n\n        :return:\n\n            * `DOWNLOADING`: the task is downloading files\n            * `BEING TRANSFERRED`: the task is being transferred\n            * `TRANSFERRED`: the task has been transferred to downloads \\\n                    directory\n            * `SEARCHING RESOURCES`: the task is searching resources\n            * `FAILED`: the task is failed\n            * `DELETED`: the task is deleted\n            * `UNKNOWN STATUS`\n\n        :rtype: str\n\n        """\n        res = None\n        if self._deleted:\n            return \'DELETED\'\n        if self.status == 1:\n            res = \'DOWNLOADING\'\n        elif self.status == 2:\n            if self.move == 0:\n                res = \'BEING TRANSFERRED\'\n            elif self.move == 1:\n                res = \'TRANSFERRED\'\n            elif self.move == 2:\n                res = \'PARTIALLY TRANSFERRED\'\n        elif self.status == 4:\n            res = \'SEARCHING RESOURCES\'\n        elif self.status == -1:\n            res = \'FAILED\'\n        if res is not None:\n            return res\n        return \'UNKNOWN STATUS\'\n'
u'1370,    @property\n    def directory(self):\n        """Associated directory, if any, with this task"""\n        if not self.is_directory:\n            msg = \'This task is a file task with no associated directory.\'\n            raise TaskError(msg)\n        if self._directory is None:\n            if self.is_transferred:\n                self._directory = self.api._load_directory(self.cid)\n        if self._directory is None:\n            msg = \'No directory assciated with this task: Task is %s.\' % \\\n                self.status_human.lower()\n            raise TaskError(msg)\n        return self._directory\n'
u'1371,    @property\n    def parent(self):\n        """Parent directory of the associated directory"""\n        return self.directory.parent\n'
u'1372,    @property\n    def count(self):\n        """Number of entries in the associated directory"""\n        return self.directory.count\n'
u'1373,    def list(self, count=30, order=\'user_ptime\', asc=False, show_dir=True,\n             natsort=True):\n        """\n        List files of the associated directory to this task.\n\n        :param int count: number of entries to be listed\n        :param str order: originally named `o`\n        :param bool asc: whether in ascending order\n        :param bool show_dir: whether to show directories\n\n        """\n        return self.directory.list(count, order, asc, show_dir, natsort)\n'
u'1374,    def __unicode__(self):\n        return self.name\n'
u'1375,    def __init__(self, api, name, size, info_hash, file_count, files=None,\n                 *args, **kwargs):\n        self.api = api\n        self.name = name\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.info_hash = info_hash\n        self.file_count = file_count\n        self.files = files\n        self.submitted = False\n'
u'1376,    def submit(self):\n        """Submit this torrent and create a new task"""\n        if self.api._req_lixian_add_task_bt(self):\n            self.submitted = True\n            return True\n        return False\n'
u'1377,    @property\n    def selected_files(self):\n        """List of selected :class:`.TorrentFile` objects of this torrent"""\n        return [f for f in self.files if f.selected]\n'
u'1378,    @property\n    def unselected_files(self):\n        """List of unselected :class:`.TorrentFile` objects of this torrent"""\n        return [f for f in self.files if not f.selected]\n'
u'1379,    def __unicode__(self):\n        return self.name\n'
u'1380,    def __init__(self, torrent, path, size, selected, *args, **kwargs):\n        self.torrent = torrent\n        self.path = path\n        self.size = size\n        self.size_human = humanize.naturalsize(size, binary=True)\n        self.selected = selected\n'
u'1381,    def select(self):\n        """Select this file"""\n        self.selected = True\n'
u'1382,    def unselect(self):\n        """Unselect this file"""\n        self.selected = False\n'
u"1383,    def __unicode__(self):\n        return '[%s] %s' % ('*' if self.selected else ' ', self.path)\n"
u"1384,    def __init__(self, *args, **kwargs):\n        content = kwargs.pop('content', None)\n        self.content = content\n        super(APIError, self).__init__(*args, **kwargs)\n"
u"1385,    def __init__(self, *args, **kwargs):\n        content = kwargs.pop('content', None)\n        self.content = content\n        if not args:\n            msg = 'Your account has a similar job running. Try again later.'\n            args = (msg,)\n        super(JobError, self).__init__(*args, **kwargs)\n"
u'1386,# -*-COMMENT utf-8 -*-\nfrom __future__ import print_function, absolute_import\n\ntry:\n    import configparser\nexcept ImportError:\n    import ConfigParser as configparser\nimport os\nimport logging\nfrom u115.utils import pjoin, eval_path\n\n_d = os.path.dirname(__file__)\nuser_dir = eval_path(\'~\')\nPROJECT_PATH = os.path.abspath(pjoin(_d, os.pardir))\nPROJECT_CREDENTIALS = pjoin(PROJECT_PATH, \'.credentials\')\nUSER_CREDENTIALS = pjoin(user_dir, \'.115\')\nCREDENTIALS = None\nCOOKIES_FILENAME = pjoin(user_dir, \'.115cookies\')\n\nLOGGING_API_LOGGER = \'API\'\nLOGGING_FORMAT = "%(levelname)s:%(name)s:%(funcName)s: %(message)s"\nLOGGING_LEVEL = logging.ERROR\nDEBUG_REQ_FMT = """\n  TYPE: Request\n  FUNC: %s\n   URL: %s\nMETHOD: %s\nPARAMS: %s\n  DATA: %s\n"""\n\nDEBUG_RES_FMT = """\n   TYPE: Response\n   FUNC: %s\n  STATE: %s\nCONTENT: %s\n"""\n\n# Initialize logger\nlogger = logging.getLogger(LOGGING_API_LOGGER)\nhandler = logging.StreamHandler()\nformatter = logging.Formatter(LOGGING_FORMAT)\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\nlogger.setLevel(LOGGING_LEVEL)\n\nif os.path.exists(PROJECT_CREDENTIALS):\n    CREDENTIALS = PROJECT_CREDENTIALS\nelif os.path.exists(USER_CREDENTIALS):\n    CREDENTIALS = USER_CREDENTIALS\n\nCONFIG = configparser.ConfigParser()\n\n\ndef get_credential(section=\'default\'):\n    if os.environ.get(\'TRAVIS_TEST\'):\n        username = os.environ.get(\'TEST_USER_USERNAME\')\n        password = os.environ.get(\'TEST_USER_PASSWORD\')\n        if username is None or password is None:\n            msg = \'No credentials environment variables found.\'\n            raise ConfigError(msg)\n    elif CREDENTIALS is not None:\n        CONFIG.read(CREDENTIALS)\n        if CONFIG.has_section(section):\n            items = dict(CONFIG.items(section))\n            try:\n                username = items[\'username\']\n                password = items[\'password\']\n            except KeyError as e:\n                msg = \'Key "%s" not found in credentials file.\' % e.args[0]\n                raise ConfigError(msg)\n        else:\n            msg = \'No section named "%s" found in credentials file.\' % section\n            raise ConfigError(msg)\n    else:\n        msg = \'No credentials file found.\'\n        raise ConfigError(msg)\n    return {\'username\': username, \'password\': password}\n\n\nclass ConfigError(Exception):\n    pass\n'
u'1387,def get_credential(section=\'default\'):\n    if os.environ.get(\'TRAVIS_TEST\'):\n        username = os.environ.get(\'TEST_USER_USERNAME\')\n        password = os.environ.get(\'TEST_USER_PASSWORD\')\n        if username is None or password is None:\n            msg = \'No credentials environment variables found.\'\n            raise ConfigError(msg)\n    elif CREDENTIALS is not None:\n        CONFIG.read(CREDENTIALS)\n        if CONFIG.has_section(section):\n            items = dict(CONFIG.items(section))\n            try:\n                username = items[\'username\']\n                password = items[\'password\']\n            except KeyError as e:\n                msg = \'Key "%s" not found in credentials file.\' % e.args[0]\n                raise ConfigError(msg)\n        else:\n            msg = \'No section named "%s" found in credentials file.\' % section\n            raise ConfigError(msg)\n    else:\n        msg = \'No credentials file found.\'\n        raise ConfigError(msg)\n    return {\'username\': username, \'password\': password}\n'
u'1388,class ConfigError(Exception):\n    pass\n'
u'1389,from __future__ import print_function, absolute_import\nimport datetime\nimport errno\nimport os\nimport six\nimport sys\nimport time\nfrom requests.utils import quote as _quote\nfrom requests.utils import unquote as _unquote\n\nPY3 = sys.version_info[0] == 3\nSTREAM = sys.stderr\nSTRPTIME_FORMATS = [\'%Y-%m-%d %H:%M\', \'%Y-%m-%d\']\n\nif PY3:\n    bin_type = bytes\n    txt_type = str\nelse:\n    bin_type = str\n    txt_type = unicode\n\nstr_types = (bin_type, txt_type)\n\n\ndef get_timestamp(length):\n    """Get a timestamp of `length` in string"""\n    s = \'%.6f\' % time.time()\n    whole, frac = map(int, s.split(\'.\'))\n    res = \'%d%d\' % (whole, frac)\n    return res[:length]\n\n\ndef get_utcdatetime(timestamp):\n    return datetime.datetime.utcfromtimestamp(timestamp)\n\n\ndef string_to_datetime(s):\n    for f in STRPTIME_FORMATS:\n        try:\n            return datetime.datetime.strptime(s, f)\n        except ValueError:\n            pass\n    msg = \'Time data %s does not match any formats in %s\' \\\n        % (s, STRPTIME_FORMATS)\n    raise ValueError(msg)\n\n\ndef eval_path(path):\n    return os.path.abspath(os.path.expanduser(path))\n\n\ndef quote(s):\n    res = s\n    if isinstance(res, six.text_type):\n        res = s.encode(\'utf-8\')\n    return _quote(res)\n\n\ndef unquote(s):\n    res = s\n    if not PY3:\n        if isinstance(res, six.text_type):\n            res = s.encode(\'utf-8\')\n    return _unquote(res)\n\n\ndef utf8_encode(s):\n    res = s\n    if isinstance(res, six.text_type):\n        res = s.encode(\'utf-8\')\n    return res\n\n\ndef pjoin(*args):\n    """Short cut for os.path.join"""\n    return os.path.join(*args)\n\n\ndef mkdir_p(path):\n    """mkdir -p path"""\n    if PY3:\n        return os.makedirs(path, exist_ok=True)\n    try:\n        os.makedirs(path)\n    except OSError as exc:\n        if exc.errno == errno.EEXIST and os.path.isdir(path):\n            pass\n        else:\n            raise\n'
u'1390,def get_timestamp(length):\n    """Get a timestamp of `length` in string"""\n    s = \'%.6f\' % time.time()\n    whole, frac = map(int, s.split(\'.\'))\n    res = \'%d%d\' % (whole, frac)\n    return res[:length]\n'
u'1391,def get_utcdatetime(timestamp):\n    return datetime.datetime.utcfromtimestamp(timestamp)\n'
u"1392,def string_to_datetime(s):\n    for f in STRPTIME_FORMATS:\n        try:\n            return datetime.datetime.strptime(s, f)\n        except ValueError:\n            pass\n    msg = 'Time data %s does not match any formats in %s' \\\n        % (s, STRPTIME_FORMATS)\n    raise ValueError(msg)\n"
u'1393,def eval_path(path):\n    return os.path.abspath(os.path.expanduser(path))\n'
u"1394,def quote(s):\n    res = s\n    if isinstance(res, six.text_type):\n        res = s.encode('utf-8')\n    return _quote(res)\n"
u"1395,def unquote(s):\n    res = s\n    if not PY3:\n        if isinstance(res, six.text_type):\n            res = s.encode('utf-8')\n    return _unquote(res)\n"
u"1396,def utf8_encode(s):\n    res = s\n    if isinstance(res, six.text_type):\n        res = s.encode('utf-8')\n    return res\n"
u'1397,def pjoin(*args):\n    """Short cut for os.path.join"""\n    return os.path.join(*args)\n'
u'1398,def mkdir_p(path):\n    """mkdir -p path"""\n    if PY3:\n        return os.makedirs(path, exist_ok=True)\n    try:\n        os.makedirs(path)\n    except OSError as exc:\n        if exc.errno == errno.EEXIST and os.path.isdir(path):\n            pass\n        else:\n            raise\n'
u'1399,def print_lol(the_list):\n    for each_item in the_list:\n        if isinstance(each_item, list):\n            print_lol(each_item)\n        else:\n            print(each_item)\n'
u'1400,def print_lol(the_list):\n    for each_item in the_list:\n        if isinstance(each_item, list):\n            print_lol(each_item)\n        else:\n            print(each_item)\n'
u"1401,from distutils.core import setup\n\nsetup(\n    name='131228_pytest_1',\n    version='1.0.0',\n    packages=[''],\n    url='none',\n    license='none',\n    author='smith9',\n    author_email='smith9@ms22.hinet.net',\n    description='A easy printer of nested list'\n)\n"
u"1402,# -*-COMMENT utf-8 -*-\nimport os\nimport time\n\nstart = '\\033[1;%dm'\nend = '\\033[0;0m'\n\nwidth = int(os.popen('stty size', 'r').read().split()[1])\n\n\ndef do_1337():\n    while True:\n        for j in range(40,48):\n            print(start % j + '1337' * (width // 4) + end)\n\n\ndef main():\n    while True:\n        try:\n            time.sleep(2)\n            do_1337()\n        except KeyboardInterrupt:\n            print('Not so easy...')\n\n\nif __name__ == '__main__':\n    main()\n"
u"1403,def do_1337():\n    while True:\n        for j in range(40,48):\n            print(start % j + '1337' * (width // 4) + end)\n"
u"1404,def main():\n    while True:\n        try:\n            time.sleep(2)\n            do_1337()\n        except KeyboardInterrupt:\n            print('Not so easy...')\n"
u"1405,#!/usr/bin/env python\n# -*-COMMENT utf-8 -*-\nfrom __future__ import print_function, division, absolute_import, unicode_literals\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='1337',\n    version='1.0.0',\n    description='This is so 1337!',\n    long_description='Run\\n\\n::\\n\\n    $ 1337\\n\\n...to be 1337.',\n    packages=find_packages(),\n    entry_points={\n        'console_scripts': [\n            '1337 = 1337.1337:main',\n        ]\n    }\n)\n"
u'1406,"""JQuery-Ajax Autocomplete fields for Django Forms."""\n__version__ = "1.5.2"\n__author__ = "crucialfelix"\n__contact__ = "crucialfelix@gmail.com"\n__homepage__ = "https://github.com/crucialfelix/django-ajax-selects/"\n\nfrom ajax_select.registry import registry, register  # noqa\nfrom ajax_select.helpers import make_ajax_form, make_ajax_field  # noqa\nfrom ajax_select.lookup_channel import LookupChannel  # noqa\n\ntry:\n    # django 1.7+ will use the new AppConfig api\n    # It will load all your lookups.py modules\n    # and any specified in settings.AJAX_LOOKUP_CHANNELS\n    # It will do this after all apps are imported.\n    from django.apps import AppConfig  # noqa\n    default_app_config = \'ajax_select.apps.AjaxSelectConfig\'\nexcept ImportError:\n    # Previous django versions should load now\n    # using settings.AJAX_LOOKUP_CHANNELS\n    registry.load_channels()\n'
u'1407,from django.contrib import admin\nfrom ajax_select.fields import autoselect_fields_check_can_add\n\n\nclass AjaxSelectAdmin(admin.ModelAdmin):\n\n    """ in order to get + popup functions subclass this or do the same hook inside of your get_form """\n\n    def get_form(self, request, obj=None, **kwargs):\n        form = super(AjaxSelectAdmin, self).get_form(request, obj, **kwargs)\n\n        autoselect_fields_check_can_add(form, self.model, request.user)\n        return form\n\n\nclass AjaxSelectAdminInlineFormsetMixin(object):\n\n    def get_formset(self, request, obj=None, **kwargs):\n        fs = super(AjaxSelectAdminInlineFormsetMixin, self).get_formset(request, obj, **kwargs)\n        autoselect_fields_check_can_add(fs.form, self.model, request.user)\n        return fs\n\n\nclass AjaxSelectAdminTabularInline(AjaxSelectAdminInlineFormsetMixin, admin.TabularInline):\n    pass\n\n\nclass AjaxSelectAdminStackedInline(AjaxSelectAdminInlineFormsetMixin, admin.StackedInline):\n    pass\n'
u'1408,class AjaxSelectAdmin(admin.ModelAdmin):\n\n    """ in order to get + popup functions subclass this or do the same hook inside of your get_form """\n\n    def get_form(self, request, obj=None, **kwargs):\n        form = super(AjaxSelectAdmin, self).get_form(request, obj, **kwargs)\n\n        autoselect_fields_check_can_add(form, self.model, request.user)\n        return form\n'
u'1409,class AjaxSelectAdminInlineFormsetMixin(object):\n\n    def get_formset(self, request, obj=None, **kwargs):\n        fs = super(AjaxSelectAdminInlineFormsetMixin, self).get_formset(request, obj, **kwargs)\n        autoselect_fields_check_can_add(fs.form, self.model, request.user)\n        return fs\n'
u'1410,class AjaxSelectAdminTabularInline(AjaxSelectAdminInlineFormsetMixin, admin.TabularInline):\n    pass\n'
u'1411,class AjaxSelectAdminStackedInline(AjaxSelectAdminInlineFormsetMixin, admin.StackedInline):\n    pass\n'
u'1412,    def get_form(self, request, obj=None, **kwargs):\n        form = super(AjaxSelectAdmin, self).get_form(request, obj, **kwargs)\n\n        autoselect_fields_check_can_add(form, self.model, request.user)\n        return form\n'
u'1413,    def get_formset(self, request, obj=None, **kwargs):\n        fs = super(AjaxSelectAdminInlineFormsetMixin, self).get_formset(request, obj, **kwargs)\n        autoselect_fields_check_can_add(fs.form, self.model, request.user)\n        return fs\n'
u'1414,from django.apps import AppConfig\n\n\nclass AjaxSelectConfig(AppConfig):\n\n    """\n    Django 1.7+ enables initializing installed applications\n    and autodiscovering modules\n\n    On startup, search for and import any modules called `lookups.py` in all installed apps.\n    Your LookupClass subclass may register itself.\n    """\n\n    name = \'ajax_select\'\n    verbose_name = \'Ajax Selects\'\n\n    def ready(self):\n        from ajax_select.registry import registry\n        registry.load_channels()\n'
u'1415,class AjaxSelectConfig(AppConfig):\n\n    """\n    Django 1.7+ enables initializing installed applications\n    and autodiscovering modules\n\n    On startup, search for and import any modules called `lookups.py` in all installed apps.\n    Your LookupClass subclass may register itself.\n    """\n\n    name = \'ajax_select\'\n    verbose_name = \'Ajax Selects\'\n\n    def ready(self):\n        from ajax_select.registry import registry\n        registry.load_channels()\n'
u'1416,    def ready(self):\n        from ajax_select.registry import registry\n        registry.load_channels()\n'
u'1417,from __future__ import unicode_literals\nimport json\nfrom ajax_select.registry import registry\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.urlresolvers import reverse\nfrom django.db.models.query import QuerySet\ntry:\n    from django.forms.utils import flatatt\nexcept ImportError:\n    # < django 1.7\n    from django.forms.util import flatatt\nfrom django.template.loader import render_to_string\nfrom django.template.defaultfilters import force_escape\nfrom django.utils.encoding import force_text\nfrom django.utils.safestring import mark_safe\nfrom django.utils.six import text_type\nfrom django.utils.translation import ugettext as _\n\n\nas_default_help = \'Enter text to search.\'\n\n\ndef _media(self):\n    # unless AJAX_SELECT_BOOTSTRAP == False\n    # then load jquery and jquery ui + default css\n    # where needed\n    js = (\'ajax_select/js/bootstrap.js\', \'ajax_select/js/ajax_select.js\')\n    try:\n        if not settings.AJAX_SELECT_BOOTSTRAP:\n            js = (\'ajax_select/js/ajax_select.js\',)\n    except AttributeError:\n        pass\n    return forms.Media(css={\'all\': (\'ajax_select/css/ajax_select.css\',)}, js=js)\n\n\n####################################################################################\n\n\nclass AutoCompleteSelectWidget(forms.widgets.TextInput):\n\n    """Widget to search for a model and return it as text for use in a CharField."""\n\n    media = property(_media)\n\n    add_link = None\n\n    def __init__(self,\n                 channel,\n                 help_text=\'\',\n                 show_help_text=True,\n                 plugin_options=None,\n                 *args,\n                 **kwargs):\n        self.plugin_options = plugin_options or {}\n        super(forms.widgets.TextInput, self).__init__(*args, **kwargs)\n        self.channel = channel\n        self.help_text = help_text\n        self.show_help_text = show_help_text\n\n    def render(self, name, value, attrs=None):\n        value = value or \'\'\n        # Always ignore required attribute when rendering HTML fields\n        attrs.pop(\'required\', None)\n        final_attrs = self.build_attrs(attrs)\n        self.html_id = final_attrs.pop(\'id\', name)\n\n        current_repr = \'\'\n        initial = None\n        lookup = registry.get(self.channel)\n        if value:\n            objs = lookup.get_objects([value])\n            try:\n                obj = objs[0]\n            except IndexError:\n                raise Exception("%s cannot find object:%s" % (lookup, value))\n            current_repr = lookup.format_item_display(obj)\n            initial = [current_repr, obj.pk]\n\n        if self.show_help_text:\n            help_text = self.help_text\n        else:\n            help_text = \'\'\n\n        context = {\n            \'name\': name,\n            \'html_id\': self.html_id,\n            \'current_id\': value,\n            \'current_repr\': current_repr,\n            \'help_text\': help_text,\n            \'extra_attrs\': mark_safe(flatatt(final_attrs)),\n            \'func_slug\': self.html_id.replace("-", ""),\n            \'add_link\': self.add_link,\n        }\n        context.update(make_plugin_options(lookup, self.channel, self.plugin_options, initial))\n        templates = (\n            \'ajax_select/autocompleteselect_%s.html\' % self.channel,\n            \'ajax_select/autocompleteselect.html\')\n        out = render_to_string(templates, context)\n        return mark_safe(out)\n\n    def value_from_datadict(self, data, files, name):\n        return data.get(name, None)\n\n    def id_for_label(self, id_):\n        return \'%s_text\' % id_\n\n\nclass AutoCompleteSelectField(forms.fields.CharField):\n\n    """Form field to select a Model for a ForeignKey db field."""\n\n    channel = None\n\n    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n\n        widget_kwargs = dict(\n            channel=channel,\n            help_text=kwargs.get(\'help_text\', _(as_default_help)),\n            show_help_text=kwargs.pop(\'show_help_text\', True),\n            plugin_options=kwargs.pop(\'plugin_options\', {})\n        )\n        widget_kwargs.update(kwargs.pop(\'widget_options\', {}))\n        kwargs["widget"] = AutoCompleteSelectWidget(**widget_kwargs)\n        super(AutoCompleteSelectField, self).__init__(max_length=255, *args, **kwargs)\n\n    def clean(self, value):\n        if value:\n            lookup = registry.get(self.channel)\n            objs = lookup.get_objects([value])\n            if len(objs) != 1:\n                # someone else might have deleted it while you were editing\n                # or your channel is faulty\n                # out of the scope of this field to do anything more than tell you it doesn\'t exist\n                raise forms.ValidationError("%s cannot find object: %s" % (lookup, value))\n            return objs[0]\n        else:\n            if self.required:\n                raise forms.ValidationError(self.error_messages[\'required\'])\n            return None\n\n    def check_can_add(self, user, model):\n        _check_can_add(self, user, model)\n\n    def has_changed(self, initial, data):\n        # 1 vs u\'1\'\n        initial_value = initial if initial is not None else \'\'\n        data_value = data if data is not None else \'\'\n        return text_type(initial_value) != text_type(data_value)\n\n\n####################################################################################\n\n\nclass AutoCompleteSelectMultipleWidget(forms.widgets.SelectMultiple):\n\n    """Widget to select multiple models for a ManyToMany db field."""\n\n    media = property(_media)\n\n    add_link = None\n\n    def __init__(self,\n                 channel,\n                 help_text=\'\',\n                 show_help_text=True,\n                 plugin_options=None,\n                 *args,\n                 **kwargs):\n        super(AutoCompleteSelectMultipleWidget, self).__init__(*args, **kwargs)\n        self.channel = channel\n\n        self.help_text = help_text\n        self.show_help_text = show_help_text\n        self.plugin_options = plugin_options or {}\n\n    def render(self, name, value, attrs=None):\n\n        if value is None:\n            value = []\n\n        final_attrs = self.build_attrs(attrs)\n        self.html_id = final_attrs.pop(\'id\', name)\n\n        lookup = registry.get(self.channel)\n\n        if isinstance(value, QuerySet):\n            objects = value\n        else:\n            objects = lookup.get_objects(value)\n\n        current_ids = pack_ids([obj.pk for obj in objects])\n\n        # text repr of currently selected items\n        initial = [\n            [lookup.format_item_display(obj), obj.pk]\n            for obj in objects\n        ]\n\n        if self.show_help_text:\n            help_text = self.help_text\n        else:\n            help_text = \'\'\n\n        context = {\n            \'name\': name,\n            \'html_id\': self.html_id,\n            \'current\': value,\n            \'current_ids\': current_ids,\n            \'current_reprs\': mark_safe(json.dumps(initial)),\n            \'help_text\': help_text,\n            \'extra_attrs\': mark_safe(flatatt(final_attrs)),\n            \'func_slug\': self.html_id.replace("-", ""),\n            \'add_link\': self.add_link,\n        }\n        context.update(make_plugin_options(lookup, self.channel, self.plugin_options, initial))\n        templates = (\'ajax_select/autocompleteselectmultiple_%s.html\' % self.channel,\n                    \'ajax_select/autocompleteselectmultiple.html\')\n        out = render_to_string(templates, context)\n        return mark_safe(out)\n\n    def value_from_datadict(self, data, files, name):\n        # eg. \'members\': [\'|229|4688|190|\']\n        return [val for val in data.get(name, \'\').split(\'|\') if val]\n\n    def id_for_label(self, id_):\n        return \'%s_text\' % id_\n\n\nclass AutoCompleteSelectMultipleField(forms.fields.CharField):\n\n    """ form field to select multiple models for a ManyToMany db field """\n\n    channel = None\n\n    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n\n        help_text = kwargs.get(\'help_text\')\n        show_help_text = kwargs.pop(\'show_help_text\', False)\n\n        if not (help_text is None):\n            # \'\' will cause translation to fail\n            # should be \'\'\n            if isinstance(help_text, str):\n                help_text = force_text(help_text)\n            # django admin appends "Hold down "Control",..." to the help text\n            # regardless of which widget is used. so even when you specify an explicit\n            # help text it appends this other default text onto the end.\n            # This monkey patches the help text to remove that\n            if help_text != \'\':\n                if not isinstance(help_text, text_type):\n                    # ideally this could check request.LANGUAGE_CODE\n                    translated = help_text.translate(settings.LANGUAGE_CODE)\n                else:\n                    translated = help_text\n                dh = \'Hold down "Control", or "Command" on a Mac, to select more than one.\'\n                django_default_help = _(dh).translate(settings.LANGUAGE_CODE)\n                if django_default_help in translated:\n                    cleaned_help = translated.replace(django_default_help, \'\').strip()\n                    # probably will not show up in translations\n                    if cleaned_help:\n                        help_text = cleaned_help\n                    else:\n                        help_text = ""\n                        show_help_text = False\n        else:\n            help_text = _(as_default_help)\n\n        # django admin will also show help text outside of the display\n        # area of the widget.  this results in duplicated help.\n        # it should just let the widget do the rendering\n        # so by default do not show it in widget\n        # if using in a normal form then set to True when creating the field\n        widget_kwargs = {\n            \'channel\': channel,\n            \'help_text\': help_text,\n            \'show_help_text\': show_help_text,\n            \'plugin_options\': kwargs.pop(\'plugin_options\', {})\n        }\n        widget_kwargs.update(kwargs.pop(\'widget_options\', {}))\n        kwargs[\'widget\'] = AutoCompleteSelectMultipleWidget(**widget_kwargs)\n        kwargs[\'help_text\'] = help_text\n\n        super(AutoCompleteSelectMultipleField, self).__init__(*args, **kwargs)\n\n    def clean(self, value):\n        if not value and self.required:\n            raise forms.ValidationError(self.error_messages[\'required\'])\n        return value  # a list of primary keys from widget value_from_datadict\n\n    def check_can_add(self, user, model):\n        _check_can_add(self, user, model)\n\n    def has_changed(self, initial_value, data_value):\n        # [1, 2] vs [u\'1\', u\'2\']\n        ivs = [text_type(v) for v in (initial_value or [])]\n        dvs = [text_type(v) for v in (data_value or [])]\n        return ivs != dvs\n\n####################################################################################\n\n\nclass AutoCompleteWidget(forms.TextInput):\n\n    """\n    Widget to select a search result and enter the result as raw text in the text input field.\n    the user may also simply enter text and ignore any auto complete suggestions.\n    """\n\n    media = property(_media)\n\n    channel = None\n    help_text = \'\'\n    html_id = \'\'\n\n    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n        self.help_text = kwargs.pop(\'help_text\', \'\')\n        self.show_help_text = kwargs.pop(\'show_help_text\', True)\n        self.plugin_options = kwargs.pop(\'plugin_options\', {})\n\n        super(AutoCompleteWidget, self).__init__(*args, **kwargs)\n\n    def render(self, name, value, attrs=None):\n\n        initial = value or \'\'\n\n        final_attrs = self.build_attrs(attrs)\n        self.html_id = final_attrs.pop(\'id\', name)\n\n        lookup = registry.get(self.channel)\n        if self.show_help_text:\n            help_text = self.help_text\n        else:\n            help_text = \'\'\n\n        context = {\n            \'current_repr\': initial,\n            \'current_id\': initial,\n            \'help_text\': help_text,\n            \'html_id\': self.html_id,\n            \'name\': name,\n            \'extra_attrs\': mark_safe(flatatt(final_attrs)),\n            \'func_slug\': self.html_id.replace("-", ""),\n        }\n        context.update(make_plugin_options(lookup, self.channel, self.plugin_options, initial))\n        templates = (\'ajax_select/autocomplete_%s.html\' % self.channel,\n                     \'ajax_select/autocomplete.html\')\n        return mark_safe(render_to_string(templates, context))\n\n\nclass AutoCompleteField(forms.CharField):\n    """\n    A CharField that uses an AutoCompleteWidget to lookup matching and stores the result as plain text.\n    """\n    channel = None\n\n    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n\n        widget_kwargs = dict(\n            help_text=kwargs.get(\'help_text\', _(as_default_help)),\n            show_help_text=kwargs.pop(\'show_help_text\', True),\n            plugin_options=kwargs.pop(\'plugin_options\', {})\n        )\n        widget_kwargs.update(kwargs.pop(\'widget_options\', {}))\n        if \'attrs\' in kwargs:\n            widget_kwargs[\'attrs\'] = kwargs.pop(\'attrs\')\n        widget = AutoCompleteWidget(channel, **widget_kwargs)\n\n        defaults = {\'max_length\': 255, \'widget\': widget}\n        defaults.update(kwargs)\n\n        super(AutoCompleteField, self).__init__(*args, **defaults)\n\n\n####################################################################################\n\ndef _check_can_add(self, user, related_model):\n    """\n    Check if the User can create a related_model.\n\n    If the LookupChannel implements check_can_add() then use this.\n\n    Else uses Django\'s default permission system.\n\n    If it can add, then enable the widget to show the green + link\n    """\n    lookup = registry.get(self.channel)\n    if hasattr(lookup, \'can_add\'):\n        can_add = lookup.can_add(user, related_model)\n    else:\n        ctype = ContentType.objects.get_for_model(related_model)\n        can_add = user.has_perm("%s.add_%s" % (ctype.app_label, ctype.model))\n    if can_add:\n        app_label = related_model._meta.app_label\n        model = related_model._meta.object_name.lower()\n        self.widget.add_link = reverse(\'admin:%s_%s_add\' % (app_label, model)) + \'?_popup=1\'\n\n\ndef autoselect_fields_check_can_add(form, model, user):\n    """\n    Check the form\'s fields for any autoselect fields and enable their\n    widgets with green + button if permissions allow then to create the related_model.\n    """\n    for name, form_field in form.declared_fields.items():\n        if isinstance(form_field, (AutoCompleteSelectMultipleField, AutoCompleteSelectField)):\n            db_field = model._meta.get_field(name)\n            form_field.check_can_add(user, db_field.rel.to)\n\n\ndef make_plugin_options(lookup, channel_name, widget_plugin_options, initial):\n    """ Make a JSON dumped dict of all options for the jQuery ui plugin."""\n    po = {}\n    if initial:\n        po[\'initial\'] = initial\n    po.update(getattr(lookup, \'plugin_options\', {}))\n    po.update(widget_plugin_options)\n    if not po.get(\'source\'):\n        po[\'source\'] = reverse(\'ajax_lookup\', kwargs={\'channel\': channel_name})\n\n    # allow html unless explicitly set\n    if po.get(\'html\') is None:\n        po[\'html\'] = True\n\n    return {\n        \'plugin_options\': mark_safe(json.dumps(po)),\n        \'data_plugin_options\': force_escape(json.dumps(po))\n    }\n\n\ndef pack_ids(ids):\n    if ids:\n        # |pk|pk| of current\n        return "|" + "|".join(str(pk) for pk in ids) + "|"\n    else:\n        return "|"\n'
u"1418,def _media(self):\n    # unless AJAX_SELECT_BOOTSTRAP == False\n    # then load jquery and jquery ui + default css\n    # where needed\n    js = ('ajax_select/js/bootstrap.js', 'ajax_select/js/ajax_select.js')\n    try:\n        if not settings.AJAX_SELECT_BOOTSTRAP:\n            js = ('ajax_select/js/ajax_select.js',)\n    except AttributeError:\n        pass\n    return forms.Media(css={'all': ('ajax_select/css/ajax_select.css',)}, js=js)\n"
u'1419,class AutoCompleteSelectWidget(forms.widgets.TextInput):\n\n    """Widget to search for a model and return it as text for use in a CharField."""\n\n    media = property(_media)\n\n    add_link = None\n\n    def __init__(self,\n                 channel,\n                 help_text=\'\',\n                 show_help_text=True,\n                 plugin_options=None,\n                 *args,\n                 **kwargs):\n        self.plugin_options = plugin_options or {}\n        super(forms.widgets.TextInput, self).__init__(*args, **kwargs)\n        self.channel = channel\n        self.help_text = help_text\n        self.show_help_text = show_help_text\n\n    def render(self, name, value, attrs=None):\n        value = value or \'\'\n        # Always ignore required attribute when rendering HTML fields\n        attrs.pop(\'required\', None)\n        final_attrs = self.build_attrs(attrs)\n        self.html_id = final_attrs.pop(\'id\', name)\n\n        current_repr = \'\'\n        initial = None\n        lookup = registry.get(self.channel)\n        if value:\n            objs = lookup.get_objects([value])\n            try:\n                obj = objs[0]\n            except IndexError:\n                raise Exception("%s cannot find object:%s" % (lookup, value))\n            current_repr = lookup.format_item_display(obj)\n            initial = [current_repr, obj.pk]\n\n        if self.show_help_text:\n            help_text = self.help_text\n        else:\n            help_text = \'\'\n\n        context = {\n            \'name\': name,\n            \'html_id\': self.html_id,\n            \'current_id\': value,\n            \'current_repr\': current_repr,\n            \'help_text\': help_text,\n            \'extra_attrs\': mark_safe(flatatt(final_attrs)),\n            \'func_slug\': self.html_id.replace("-", ""),\n            \'add_link\': self.add_link,\n        }\n        context.update(make_plugin_options(lookup, self.channel, self.plugin_options, initial))\n        templates = (\n            \'ajax_select/autocompleteselect_%s.html\' % self.channel,\n            \'ajax_select/autocompleteselect.html\')\n        out = render_to_string(templates, context)\n        return mark_safe(out)\n\n    def value_from_datadict(self, data, files, name):\n        return data.get(name, None)\n\n    def id_for_label(self, id_):\n        return \'%s_text\' % id_\n'
u'1420,class AutoCompleteSelectField(forms.fields.CharField):\n\n    """Form field to select a Model for a ForeignKey db field."""\n\n    channel = None\n\n    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n\n        widget_kwargs = dict(\n            channel=channel,\n            help_text=kwargs.get(\'help_text\', _(as_default_help)),\n            show_help_text=kwargs.pop(\'show_help_text\', True),\n            plugin_options=kwargs.pop(\'plugin_options\', {})\n        )\n        widget_kwargs.update(kwargs.pop(\'widget_options\', {}))\n        kwargs["widget"] = AutoCompleteSelectWidget(**widget_kwargs)\n        super(AutoCompleteSelectField, self).__init__(max_length=255, *args, **kwargs)\n\n    def clean(self, value):\n        if value:\n            lookup = registry.get(self.channel)\n            objs = lookup.get_objects([value])\n            if len(objs) != 1:\n                # someone else might have deleted it while you were editing\n                # or your channel is faulty\n                # out of the scope of this field to do anything more than tell you it doesn\'t exist\n                raise forms.ValidationError("%s cannot find object: %s" % (lookup, value))\n            return objs[0]\n        else:\n            if self.required:\n                raise forms.ValidationError(self.error_messages[\'required\'])\n            return None\n\n    def check_can_add(self, user, model):\n        _check_can_add(self, user, model)\n\n    def has_changed(self, initial, data):\n        # 1 vs u\'1\'\n        initial_value = initial if initial is not None else \'\'\n        data_value = data if data is not None else \'\'\n        return text_type(initial_value) != text_type(data_value)\n'
u'1421,class AutoCompleteSelectMultipleWidget(forms.widgets.SelectMultiple):\n\n    """Widget to select multiple models for a ManyToMany db field."""\n\n    media = property(_media)\n\n    add_link = None\n\n    def __init__(self,\n                 channel,\n                 help_text=\'\',\n                 show_help_text=True,\n                 plugin_options=None,\n                 *args,\n                 **kwargs):\n        super(AutoCompleteSelectMultipleWidget, self).__init__(*args, **kwargs)\n        self.channel = channel\n\n        self.help_text = help_text\n        self.show_help_text = show_help_text\n        self.plugin_options = plugin_options or {}\n\n    def render(self, name, value, attrs=None):\n\n        if value is None:\n            value = []\n\n        final_attrs = self.build_attrs(attrs)\n        self.html_id = final_attrs.pop(\'id\', name)\n\n        lookup = registry.get(self.channel)\n\n        if isinstance(value, QuerySet):\n            objects = value\n        else:\n            objects = lookup.get_objects(value)\n\n        current_ids = pack_ids([obj.pk for obj in objects])\n\n        # text repr of currently selected items\n        initial = [\n            [lookup.format_item_display(obj), obj.pk]\n            for obj in objects\n        ]\n\n        if self.show_help_text:\n            help_text = self.help_text\n        else:\n            help_text = \'\'\n\n        context = {\n            \'name\': name,\n            \'html_id\': self.html_id,\n            \'current\': value,\n            \'current_ids\': current_ids,\n            \'current_reprs\': mark_safe(json.dumps(initial)),\n            \'help_text\': help_text,\n            \'extra_attrs\': mark_safe(flatatt(final_attrs)),\n            \'func_slug\': self.html_id.replace("-", ""),\n            \'add_link\': self.add_link,\n        }\n        context.update(make_plugin_options(lookup, self.channel, self.plugin_options, initial))\n        templates = (\'ajax_select/autocompleteselectmultiple_%s.html\' % self.channel,\n                    \'ajax_select/autocompleteselectmultiple.html\')\n        out = render_to_string(templates, context)\n        return mark_safe(out)\n\n    def value_from_datadict(self, data, files, name):\n        # eg. \'members\': [\'|229|4688|190|\']\n        return [val for val in data.get(name, \'\').split(\'|\') if val]\n\n    def id_for_label(self, id_):\n        return \'%s_text\' % id_\n'
u'1422,class AutoCompleteSelectMultipleField(forms.fields.CharField):\n\n    """ form field to select multiple models for a ManyToMany db field """\n\n    channel = None\n\n    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n\n        help_text = kwargs.get(\'help_text\')\n        show_help_text = kwargs.pop(\'show_help_text\', False)\n\n        if not (help_text is None):\n            # \'\' will cause translation to fail\n            # should be \'\'\n            if isinstance(help_text, str):\n                help_text = force_text(help_text)\n            # django admin appends "Hold down "Control",..." to the help text\n            # regardless of which widget is used. so even when you specify an explicit\n            # help text it appends this other default text onto the end.\n            # This monkey patches the help text to remove that\n            if help_text != \'\':\n                if not isinstance(help_text, text_type):\n                    # ideally this could check request.LANGUAGE_CODE\n                    translated = help_text.translate(settings.LANGUAGE_CODE)\n                else:\n                    translated = help_text\n                dh = \'Hold down "Control", or "Command" on a Mac, to select more than one.\'\n                django_default_help = _(dh).translate(settings.LANGUAGE_CODE)\n                if django_default_help in translated:\n                    cleaned_help = translated.replace(django_default_help, \'\').strip()\n                    # probably will not show up in translations\n                    if cleaned_help:\n                        help_text = cleaned_help\n                    else:\n                        help_text = ""\n                        show_help_text = False\n        else:\n            help_text = _(as_default_help)\n\n        # django admin will also show help text outside of the display\n        # area of the widget.  this results in duplicated help.\n        # it should just let the widget do the rendering\n        # so by default do not show it in widget\n        # if using in a normal form then set to True when creating the field\n        widget_kwargs = {\n            \'channel\': channel,\n            \'help_text\': help_text,\n            \'show_help_text\': show_help_text,\n            \'plugin_options\': kwargs.pop(\'plugin_options\', {})\n        }\n        widget_kwargs.update(kwargs.pop(\'widget_options\', {}))\n        kwargs[\'widget\'] = AutoCompleteSelectMultipleWidget(**widget_kwargs)\n        kwargs[\'help_text\'] = help_text\n\n        super(AutoCompleteSelectMultipleField, self).__init__(*args, **kwargs)\n\n    def clean(self, value):\n        if not value and self.required:\n            raise forms.ValidationError(self.error_messages[\'required\'])\n        return value  # a list of primary keys from widget value_from_datadict\n\n    def check_can_add(self, user, model):\n        _check_can_add(self, user, model)\n\n    def has_changed(self, initial_value, data_value):\n        # [1, 2] vs [u\'1\', u\'2\']\n        ivs = [text_type(v) for v in (initial_value or [])]\n        dvs = [text_type(v) for v in (data_value or [])]\n        return ivs != dvs\n'
u'1423,class AutoCompleteWidget(forms.TextInput):\n\n    """\n    Widget to select a search result and enter the result as raw text in the text input field.\n    the user may also simply enter text and ignore any auto complete suggestions.\n    """\n\n    media = property(_media)\n\n    channel = None\n    help_text = \'\'\n    html_id = \'\'\n\n    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n        self.help_text = kwargs.pop(\'help_text\', \'\')\n        self.show_help_text = kwargs.pop(\'show_help_text\', True)\n        self.plugin_options = kwargs.pop(\'plugin_options\', {})\n\n        super(AutoCompleteWidget, self).__init__(*args, **kwargs)\n\n    def render(self, name, value, attrs=None):\n\n        initial = value or \'\'\n\n        final_attrs = self.build_attrs(attrs)\n        self.html_id = final_attrs.pop(\'id\', name)\n\n        lookup = registry.get(self.channel)\n        if self.show_help_text:\n            help_text = self.help_text\n        else:\n            help_text = \'\'\n\n        context = {\n            \'current_repr\': initial,\n            \'current_id\': initial,\n            \'help_text\': help_text,\n            \'html_id\': self.html_id,\n            \'name\': name,\n            \'extra_attrs\': mark_safe(flatatt(final_attrs)),\n            \'func_slug\': self.html_id.replace("-", ""),\n        }\n        context.update(make_plugin_options(lookup, self.channel, self.plugin_options, initial))\n        templates = (\'ajax_select/autocomplete_%s.html\' % self.channel,\n                     \'ajax_select/autocomplete.html\')\n        return mark_safe(render_to_string(templates, context))\n'
u'1424,class AutoCompleteField(forms.CharField):\n    """\n    A CharField that uses an AutoCompleteWidget to lookup matching and stores the result as plain text.\n    """\n    channel = None\n\n    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n\n        widget_kwargs = dict(\n            help_text=kwargs.get(\'help_text\', _(as_default_help)),\n            show_help_text=kwargs.pop(\'show_help_text\', True),\n            plugin_options=kwargs.pop(\'plugin_options\', {})\n        )\n        widget_kwargs.update(kwargs.pop(\'widget_options\', {}))\n        if \'attrs\' in kwargs:\n            widget_kwargs[\'attrs\'] = kwargs.pop(\'attrs\')\n        widget = AutoCompleteWidget(channel, **widget_kwargs)\n\n        defaults = {\'max_length\': 255, \'widget\': widget}\n        defaults.update(kwargs)\n\n        super(AutoCompleteField, self).__init__(*args, **defaults)\n'
u'1425,def _check_can_add(self, user, related_model):\n    """\n    Check if the User can create a related_model.\n\n    If the LookupChannel implements check_can_add() then use this.\n\n    Else uses Django\'s default permission system.\n\n    If it can add, then enable the widget to show the green + link\n    """\n    lookup = registry.get(self.channel)\n    if hasattr(lookup, \'can_add\'):\n        can_add = lookup.can_add(user, related_model)\n    else:\n        ctype = ContentType.objects.get_for_model(related_model)\n        can_add = user.has_perm("%s.add_%s" % (ctype.app_label, ctype.model))\n    if can_add:\n        app_label = related_model._meta.app_label\n        model = related_model._meta.object_name.lower()\n        self.widget.add_link = reverse(\'admin:%s_%s_add\' % (app_label, model)) + \'?_popup=1\'\n'
u'1426,def autoselect_fields_check_can_add(form, model, user):\n    """\n    Check the form\'s fields for any autoselect fields and enable their\n    widgets with green + button if permissions allow then to create the related_model.\n    """\n    for name, form_field in form.declared_fields.items():\n        if isinstance(form_field, (AutoCompleteSelectMultipleField, AutoCompleteSelectField)):\n            db_field = model._meta.get_field(name)\n            form_field.check_can_add(user, db_field.rel.to)\n'
u'1427,def make_plugin_options(lookup, channel_name, widget_plugin_options, initial):\n    """ Make a JSON dumped dict of all options for the jQuery ui plugin."""\n    po = {}\n    if initial:\n        po[\'initial\'] = initial\n    po.update(getattr(lookup, \'plugin_options\', {}))\n    po.update(widget_plugin_options)\n    if not po.get(\'source\'):\n        po[\'source\'] = reverse(\'ajax_lookup\', kwargs={\'channel\': channel_name})\n\n    # allow html unless explicitly set\n    if po.get(\'html\') is None:\n        po[\'html\'] = True\n\n    return {\n        \'plugin_options\': mark_safe(json.dumps(po)),\n        \'data_plugin_options\': force_escape(json.dumps(po))\n    }\n'
u'1428,def pack_ids(ids):\n    if ids:\n        # |pk|pk| of current\n        return "|" + "|".join(str(pk) for pk in ids) + "|"\n    else:\n        return "|"\n'
u"1429,    def __init__(self,\n                 channel,\n                 help_text='',\n                 show_help_text=True,\n                 plugin_options=None,\n                 *args,\n                 **kwargs):\n        self.plugin_options = plugin_options or {}\n        super(forms.widgets.TextInput, self).__init__(*args, **kwargs)\n        self.channel = channel\n        self.help_text = help_text\n        self.show_help_text = show_help_text\n"
u'1430,    def render(self, name, value, attrs=None):\n        value = value or \'\'\n        # Always ignore required attribute when rendering HTML fields\n        attrs.pop(\'required\', None)\n        final_attrs = self.build_attrs(attrs)\n        self.html_id = final_attrs.pop(\'id\', name)\n\n        current_repr = \'\'\n        initial = None\n        lookup = registry.get(self.channel)\n        if value:\n            objs = lookup.get_objects([value])\n            try:\n                obj = objs[0]\n            except IndexError:\n                raise Exception("%s cannot find object:%s" % (lookup, value))\n            current_repr = lookup.format_item_display(obj)\n            initial = [current_repr, obj.pk]\n\n        if self.show_help_text:\n            help_text = self.help_text\n        else:\n            help_text = \'\'\n\n        context = {\n            \'name\': name,\n            \'html_id\': self.html_id,\n            \'current_id\': value,\n            \'current_repr\': current_repr,\n            \'help_text\': help_text,\n            \'extra_attrs\': mark_safe(flatatt(final_attrs)),\n            \'func_slug\': self.html_id.replace("-", ""),\n            \'add_link\': self.add_link,\n        }\n        context.update(make_plugin_options(lookup, self.channel, self.plugin_options, initial))\n        templates = (\n            \'ajax_select/autocompleteselect_%s.html\' % self.channel,\n            \'ajax_select/autocompleteselect.html\')\n        out = render_to_string(templates, context)\n        return mark_safe(out)\n'
u'1431,    def value_from_datadict(self, data, files, name):\n        return data.get(name, None)\n'
u"1432,    def id_for_label(self, id_):\n        return '%s_text' % id_\n"
u'1433,    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n\n        widget_kwargs = dict(\n            channel=channel,\n            help_text=kwargs.get(\'help_text\', _(as_default_help)),\n            show_help_text=kwargs.pop(\'show_help_text\', True),\n            plugin_options=kwargs.pop(\'plugin_options\', {})\n        )\n        widget_kwargs.update(kwargs.pop(\'widget_options\', {}))\n        kwargs["widget"] = AutoCompleteSelectWidget(**widget_kwargs)\n        super(AutoCompleteSelectField, self).__init__(max_length=255, *args, **kwargs)\n'
u'1434,    def clean(self, value):\n        if value:\n            lookup = registry.get(self.channel)\n            objs = lookup.get_objects([value])\n            if len(objs) != 1:\n                # someone else might have deleted it while you were editing\n                # or your channel is faulty\n                # out of the scope of this field to do anything more than tell you it doesn\'t exist\n                raise forms.ValidationError("%s cannot find object: %s" % (lookup, value))\n            return objs[0]\n        else:\n            if self.required:\n                raise forms.ValidationError(self.error_messages[\'required\'])\n            return None\n'
u'1435,    def check_can_add(self, user, model):\n        _check_can_add(self, user, model)\n'
u"1436,    def has_changed(self, initial, data):\n        # 1 vs u'1'\n        initial_value = initial if initial is not None else ''\n        data_value = data if data is not None else ''\n        return text_type(initial_value) != text_type(data_value)\n"
u"1437,    def __init__(self,\n                 channel,\n                 help_text='',\n                 show_help_text=True,\n                 plugin_options=None,\n                 *args,\n                 **kwargs):\n        super(AutoCompleteSelectMultipleWidget, self).__init__(*args, **kwargs)\n        self.channel = channel\n\n        self.help_text = help_text\n        self.show_help_text = show_help_text\n        self.plugin_options = plugin_options or {}\n"
u'1438,    def render(self, name, value, attrs=None):\n\n        if value is None:\n            value = []\n\n        final_attrs = self.build_attrs(attrs)\n        self.html_id = final_attrs.pop(\'id\', name)\n\n        lookup = registry.get(self.channel)\n\n        if isinstance(value, QuerySet):\n            objects = value\n        else:\n            objects = lookup.get_objects(value)\n\n        current_ids = pack_ids([obj.pk for obj in objects])\n\n        # text repr of currently selected items\n        initial = [\n            [lookup.format_item_display(obj), obj.pk]\n            for obj in objects\n        ]\n\n        if self.show_help_text:\n            help_text = self.help_text\n        else:\n            help_text = \'\'\n\n        context = {\n            \'name\': name,\n            \'html_id\': self.html_id,\n            \'current\': value,\n            \'current_ids\': current_ids,\n            \'current_reprs\': mark_safe(json.dumps(initial)),\n            \'help_text\': help_text,\n            \'extra_attrs\': mark_safe(flatatt(final_attrs)),\n            \'func_slug\': self.html_id.replace("-", ""),\n            \'add_link\': self.add_link,\n        }\n        context.update(make_plugin_options(lookup, self.channel, self.plugin_options, initial))\n        templates = (\'ajax_select/autocompleteselectmultiple_%s.html\' % self.channel,\n                    \'ajax_select/autocompleteselectmultiple.html\')\n        out = render_to_string(templates, context)\n        return mark_safe(out)\n'
u"1439,    def value_from_datadict(self, data, files, name):\n        # eg. 'members': ['|229|4688|190|']\n        return [val for val in data.get(name, '').split('|') if val]\n"
u"1440,    def id_for_label(self, id_):\n        return '%s_text' % id_\n"
u'1441,    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n\n        help_text = kwargs.get(\'help_text\')\n        show_help_text = kwargs.pop(\'show_help_text\', False)\n\n        if not (help_text is None):\n            # \'\' will cause translation to fail\n            # should be \'\'\n            if isinstance(help_text, str):\n                help_text = force_text(help_text)\n            # django admin appends "Hold down "Control",..." to the help text\n            # regardless of which widget is used. so even when you specify an explicit\n            # help text it appends this other default text onto the end.\n            # This monkey patches the help text to remove that\n            if help_text != \'\':\n                if not isinstance(help_text, text_type):\n                    # ideally this could check request.LANGUAGE_CODE\n                    translated = help_text.translate(settings.LANGUAGE_CODE)\n                else:\n                    translated = help_text\n                dh = \'Hold down "Control", or "Command" on a Mac, to select more than one.\'\n                django_default_help = _(dh).translate(settings.LANGUAGE_CODE)\n                if django_default_help in translated:\n                    cleaned_help = translated.replace(django_default_help, \'\').strip()\n                    # probably will not show up in translations\n                    if cleaned_help:\n                        help_text = cleaned_help\n                    else:\n                        help_text = ""\n                        show_help_text = False\n        else:\n            help_text = _(as_default_help)\n\n        # django admin will also show help text outside of the display\n        # area of the widget.  this results in duplicated help.\n        # it should just let the widget do the rendering\n        # so by default do not show it in widget\n        # if using in a normal form then set to True when creating the field\n        widget_kwargs = {\n            \'channel\': channel,\n            \'help_text\': help_text,\n            \'show_help_text\': show_help_text,\n            \'plugin_options\': kwargs.pop(\'plugin_options\', {})\n        }\n        widget_kwargs.update(kwargs.pop(\'widget_options\', {}))\n        kwargs[\'widget\'] = AutoCompleteSelectMultipleWidget(**widget_kwargs)\n        kwargs[\'help_text\'] = help_text\n\n        super(AutoCompleteSelectMultipleField, self).__init__(*args, **kwargs)\n'
u"1442,    def clean(self, value):\n        if not value and self.required:\n            raise forms.ValidationError(self.error_messages['required'])\n        return value\n"
u'1443,    def check_can_add(self, user, model):\n        _check_can_add(self, user, model)\n'
u"1444,    def has_changed(self, initial_value, data_value):\n        # [1, 2] vs [u'1', u'2']\n        ivs = [text_type(v) for v in (initial_value or [])]\n        dvs = [text_type(v) for v in (data_value or [])]\n        return ivs != dvs\n"
u"1445,    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n        self.help_text = kwargs.pop('help_text', '')\n        self.show_help_text = kwargs.pop('show_help_text', True)\n        self.plugin_options = kwargs.pop('plugin_options', {})\n\n        super(AutoCompleteWidget, self).__init__(*args, **kwargs)\n"
u'1446,    def render(self, name, value, attrs=None):\n\n        initial = value or \'\'\n\n        final_attrs = self.build_attrs(attrs)\n        self.html_id = final_attrs.pop(\'id\', name)\n\n        lookup = registry.get(self.channel)\n        if self.show_help_text:\n            help_text = self.help_text\n        else:\n            help_text = \'\'\n\n        context = {\n            \'current_repr\': initial,\n            \'current_id\': initial,\n            \'help_text\': help_text,\n            \'html_id\': self.html_id,\n            \'name\': name,\n            \'extra_attrs\': mark_safe(flatatt(final_attrs)),\n            \'func_slug\': self.html_id.replace("-", ""),\n        }\n        context.update(make_plugin_options(lookup, self.channel, self.plugin_options, initial))\n        templates = (\'ajax_select/autocomplete_%s.html\' % self.channel,\n                     \'ajax_select/autocomplete.html\')\n        return mark_safe(render_to_string(templates, context))\n'
u"1447,    def __init__(self, channel, *args, **kwargs):\n        self.channel = channel\n\n        widget_kwargs = dict(\n            help_text=kwargs.get('help_text', _(as_default_help)),\n            show_help_text=kwargs.pop('show_help_text', True),\n            plugin_options=kwargs.pop('plugin_options', {})\n        )\n        widget_kwargs.update(kwargs.pop('widget_options', {}))\n        if 'attrs' in kwargs:\n            widget_kwargs['attrs'] = kwargs.pop('attrs')\n        widget = AutoCompleteWidget(channel, **widget_kwargs)\n\n        defaults = {'max_length': 255, 'widget': widget}\n        defaults.update(kwargs)\n\n        super(AutoCompleteField, self).__init__(*args, **defaults)\n"
u'1448,from django.db.models.fields.related import ForeignKey, ManyToManyField\nfrom django.forms.models import ModelForm\nfrom django.utils.text import capfirst\nfrom django.utils.encoding import force_text\nfrom django.utils.translation import ugettext_lazy as _\n\n\ndef make_ajax_form(model, fieldlist, superclass=ModelForm, show_help_text=False, **kwargs):\n    """Creates a ModelForm subclass with AutoComplete fields.\n\n    Args:\n        model (type): Model class for which you are making the ModelForm\n        fieldlist (dict): {field_name -> channel_name, ...}\n        superclass (type): optional ModelForm superclass\n        show_help_text (bool): suppress or show the widget help text\n\n    Returns:\n        ModelForm: a ModelForm suitable for use in an Admin\n\n    Usage::\n\n        from django.contrib import admin\n        from ajax_select import make_ajax_form\n        from yourapp.models import YourModel\n\n        @admin.register(YourModel)\n        class YourModelAdmin(Admin):\n\n            form = make_ajax_form(YourModel, {\n                \'contacts\': \'contact\',  # ManyToManyField\n                \'author\':\'contact\'      # ForeignKeyField\n            })\n\n    Where \'contacts\' is a ManyToManyField specifying to use the lookup channel \'contact\'\n    and \'author\' is a ForeignKeyField specifying here to also use the same lookup channel \'contact\'\n\n    """\n    # will support previous arg name for several versions before deprecating\n    # TODO: time to go\n    if \'show_m2m_help\' in kwargs:\n        show_help_text = kwargs.pop(\'show_m2m_help\')\n\n    class TheForm(superclass):\n\n        class Meta:\n            exclude = []\n\n        setattr(Meta, \'model\', model)\n        if hasattr(superclass, \'Meta\'):\n            if hasattr(superclass.Meta, \'fields\'):\n                setattr(Meta, \'fields\', superclass.Meta.fields)\n            if hasattr(superclass.Meta, \'exclude\'):\n                setattr(Meta, \'exclude\', superclass.Meta.exclude)\n            if hasattr(superclass.Meta, \'widgets\'):\n                setattr(Meta, \'widgets\', superclass.Meta.widgets)\n\n    for model_fieldname, channel in fieldlist.items():\n        f = make_ajax_field(model, model_fieldname, channel, show_help_text)\n\n        TheForm.declared_fields[model_fieldname] = f\n        TheForm.base_fields[model_fieldname] = f\n\n    return TheForm\n\n\ndef make_ajax_field(related_model, fieldname_on_model, channel, show_help_text=False, **kwargs):\n    """Makes an AutoComplete field for use in a Form.\n\n    Args:\n        related_model (Model): model of the related object\n        fieldname_on_model (str): field name on the model being edited\n        channel (str): channel name of a registered LookupChannel\n        show_help_text (bool): show or supress help text below the widget\n            Django admin will show help text below the widget, but not for ManyToMany inside of admin inlines\n            This setting will show the help text inside the widget itself.\n        kwargs: optional args\n\n            - help_text: default is the model db field\'s help_text.\n                            None will disable all help text\n            - label: default is the model db field\'s verbose name\n            - required: default is the model db field\'s (not) blank\n\n    Returns:\n        (AutoCompleteField, AutoCompleteSelectField, AutoCompleteSelectMultipleField): field\n    """\n    from ajax_select.fields import AutoCompleteField, \\\n                                   AutoCompleteSelectMultipleField, \\\n                                   AutoCompleteSelectField\n\n    field = related_model._meta.get_field(fieldname_on_model)\n    if \'label\' not in kwargs:\n        kwargs[\'label\'] = _(capfirst(force_text(field.verbose_name)))\n\n    if (\'help_text\' not in kwargs) and field.help_text:\n        kwargs[\'help_text\'] = field.help_text\n    if \'required\' not in kwargs:\n        kwargs[\'required\'] = not field.blank\n\n    kwargs[\'show_help_text\'] = show_help_text\n    if isinstance(field, ManyToManyField):\n        f = AutoCompleteSelectMultipleField(\n            channel,\n            **kwargs)\n    elif isinstance(field, ForeignKey):\n        f = AutoCompleteSelectField(\n            channel,\n            **kwargs)\n    else:\n        f = AutoCompleteField(\n            channel,\n            **kwargs)\n    return f\n'
u'1449,def make_ajax_form(model, fieldlist, superclass=ModelForm, show_help_text=False, **kwargs):\n    """Creates a ModelForm subclass with AutoComplete fields.\n\n    Args:\n        model (type): Model class for which you are making the ModelForm\n        fieldlist (dict): {field_name -> channel_name, ...}\n        superclass (type): optional ModelForm superclass\n        show_help_text (bool): suppress or show the widget help text\n\n    Returns:\n        ModelForm: a ModelForm suitable for use in an Admin\n\n    Usage::\n\n        from django.contrib import admin\n        from ajax_select import make_ajax_form\n        from yourapp.models import YourModel\n\n        @admin.register(YourModel)\n        class YourModelAdmin(Admin):\n\n            form = make_ajax_form(YourModel, {\n                \'contacts\': \'contact\',  # ManyToManyField\n                \'author\':\'contact\'      # ForeignKeyField\n            })\n\n    Where \'contacts\' is a ManyToManyField specifying to use the lookup channel \'contact\'\n    and \'author\' is a ForeignKeyField specifying here to also use the same lookup channel \'contact\'\n\n    """\n    # will support previous arg name for several versions before deprecating\n    # TODO: time to go\n    if \'show_m2m_help\' in kwargs:\n        show_help_text = kwargs.pop(\'show_m2m_help\')\n\n    class TheForm(superclass):\n\n        class Meta:\n            exclude = []\n\n        setattr(Meta, \'model\', model)\n        if hasattr(superclass, \'Meta\'):\n            if hasattr(superclass.Meta, \'fields\'):\n                setattr(Meta, \'fields\', superclass.Meta.fields)\n            if hasattr(superclass.Meta, \'exclude\'):\n                setattr(Meta, \'exclude\', superclass.Meta.exclude)\n            if hasattr(superclass.Meta, \'widgets\'):\n                setattr(Meta, \'widgets\', superclass.Meta.widgets)\n\n    for model_fieldname, channel in fieldlist.items():\n        f = make_ajax_field(model, model_fieldname, channel, show_help_text)\n\n        TheForm.declared_fields[model_fieldname] = f\n        TheForm.base_fields[model_fieldname] = f\n\n    return TheForm\n'
u'1450,def make_ajax_field(related_model, fieldname_on_model, channel, show_help_text=False, **kwargs):\n    """Makes an AutoComplete field for use in a Form.\n\n    Args:\n        related_model (Model): model of the related object\n        fieldname_on_model (str): field name on the model being edited\n        channel (str): channel name of a registered LookupChannel\n        show_help_text (bool): show or supress help text below the widget\n            Django admin will show help text below the widget, but not for ManyToMany inside of admin inlines\n            This setting will show the help text inside the widget itself.\n        kwargs: optional args\n\n            - help_text: default is the model db field\'s help_text.\n                            None will disable all help text\n            - label: default is the model db field\'s verbose name\n            - required: default is the model db field\'s (not) blank\n\n    Returns:\n        (AutoCompleteField, AutoCompleteSelectField, AutoCompleteSelectMultipleField): field\n    """\n    from ajax_select.fields import AutoCompleteField, \\\n                                   AutoCompleteSelectMultipleField, \\\n                                   AutoCompleteSelectField\n\n    field = related_model._meta.get_field(fieldname_on_model)\n    if \'label\' not in kwargs:\n        kwargs[\'label\'] = _(capfirst(force_text(field.verbose_name)))\n\n    if (\'help_text\' not in kwargs) and field.help_text:\n        kwargs[\'help_text\'] = field.help_text\n    if \'required\' not in kwargs:\n        kwargs[\'required\'] = not field.blank\n\n    kwargs[\'show_help_text\'] = show_help_text\n    if isinstance(field, ManyToManyField):\n        f = AutoCompleteSelectMultipleField(\n            channel,\n            **kwargs)\n    elif isinstance(field, ForeignKey):\n        f = AutoCompleteSelectField(\n            channel,\n            **kwargs)\n    else:\n        f = AutoCompleteField(\n            channel,\n            **kwargs)\n    return f\n'
u"1451,    class TheForm(superclass):\n\n        class Meta:\n            exclude = []\n\n        setattr(Meta, 'model', model)\n        if hasattr(superclass, 'Meta'):\n            if hasattr(superclass.Meta, 'fields'):\n                setattr(Meta, 'fields', superclass.Meta.fields)\n            if hasattr(superclass.Meta, 'exclude'):\n                setattr(Meta, 'exclude', superclass.Meta.exclude)\n            if hasattr(superclass.Meta, 'widgets'):\n                setattr(Meta, 'widgets', superclass.Meta.widgets)\n"
u'1452,        class Meta:\n            exclude = []\n'
u'1453,from django.core.exceptions import PermissionDenied\nfrom django.utils.encoding import force_text\nfrom django.utils.html import escape\n\n\nclass LookupChannel(object):\n\n    """\n    Subclass this, setting the model and implementing methods to taste.\n\n    Attributes:\n        model (Model): The Django Model that this lookup channel will search for.\n        plugin_options (dict): Options passed to jQuery UI plugin that are specific to this channel.\n        min_length (int): Minimum number of characters user types before a search is initiated.\n\n            This is passed to the jQuery plugin_options.\n            It is used in jQuery\'s UI when filtering results from its own cache.\n\n            It is also used in the django view to prevent expensive database queries.\n            Large datasets can choke if they search too often with small queries.\n            Better to demand at least 2 or 3 characters.\n    """\n\n    model = None\n    plugin_options = {}\n    min_length = 1\n\n    def get_query(self, q, request):\n        """\n        Return a QuerySet searching for the query string `q`.\n\n        Note that you may return any iterable so you can return a list or even use yield and turn this\n        method into a generator.\n\n        Args:\n            q (str, unicode): The query string to search for.\n            request (Request): This can be used to customize the search by User or to use additional GET variables.\n\n        Returns:\n            (QuerySet, list, generator): iterable of related_models\n        """\n        kwargs = {"%s__icontains" % self.search_field: q}\n        return self.model.objects.filter(**kwargs).order_by(self.search_field)\n\n    def get_result(self, obj):\n        """The text result of autocompleting the entered query.\n\n        For a partial string that the user typed in, each matched result is here converted to the fully completed text.\n\n        This is currently displayed only for a moment in the text field after the user has selected the item.\n        Then the item is displayed in the item_display deck and the text field is cleared.\n\n        Args:\n            obj (Model):\n        Returns:\n            str: The object as string\n        """\n        return escape(force_text(obj))\n\n    def format_match(self, obj):\n        """(HTML) Format item for displaying in the dropdown.\n\n        Args:\n            obj (Model):\n        Returns:\n            str: formatted string, may contain HTML.\n        """\n        return escape(force_text(obj))\n\n    def format_item_display(self, obj):\n        """ (HTML) format item for displaying item in the selected deck area.\n\n        Args:\n            obj (Model):\n        Returns:\n            str: formatted string, may contain HTML.\n        """\n        return escape(force_text(obj))\n\n    def get_objects(self, ids):\n        """This is used to retrieve the currently selected objects for either ManyToMany or ForeignKey.\n\n        Note that the order of the ids supplied for ManyToMany fields is dependent on how the\n        objects manager fetches it.\n        ie. what is returned by `YourModel.{fieldname}_set.all()`\n\n        In most situations (especially postgres) this order is indeterminate -- not the order that you originally\n        added them in the interface.\n        See :doc:`/Ordered-ManyToMany` for a solution to this.\n\n        Args:\n            ids (list): list of primary keys\n        Returns:\n            list: list of Model objects\n        """\n        # return objects in the same order as passed in here\n        pk_type = self.model._meta.pk.to_python\n        ids = [pk_type(pk) for pk in ids]\n        things = self.model.objects.in_bulk(ids)\n        return [things[aid] for aid in ids if aid in things]\n\n    def can_add(self, user, other_model):\n        """Check if the user has permission to add a ForeignKey or M2M model.\n\n        This enables the green popup + on the widget.\n        Default implentation is the standard django permission check.\n\n        Args:\n            user (User)\n            other_model (Model): the ForeignKey or M2M model to check if the User can add.\n        Returns:\n            bool\n        """\n        from django.contrib.contenttypes.models import ContentType\n        ctype = ContentType.objects.get_for_model(other_model)\n        return user.has_perm("%s.add_%s" % (ctype.app_label, ctype.model))\n\n    def check_auth(self, request):\n        """By default only request.user.is_staff have access.\n\n        This ensures that nobody can get your data by simply knowing the lookup URL.\n\n        This is called from the ajax_lookup view.\n\n        Public facing forms (outside of the Admin) should implement this to allow\n        non-staff to use this LookupChannel.\n\n        Args:\n            request (Request)\n        Raises:\n            PermissionDenied\n        """\n        if not request.user.is_staff:\n            raise PermissionDenied\n'
u'1454,class LookupChannel(object):\n\n    """\n    Subclass this, setting the model and implementing methods to taste.\n\n    Attributes:\n        model (Model): The Django Model that this lookup channel will search for.\n        plugin_options (dict): Options passed to jQuery UI plugin that are specific to this channel.\n        min_length (int): Minimum number of characters user types before a search is initiated.\n\n            This is passed to the jQuery plugin_options.\n            It is used in jQuery\'s UI when filtering results from its own cache.\n\n            It is also used in the django view to prevent expensive database queries.\n            Large datasets can choke if they search too often with small queries.\n            Better to demand at least 2 or 3 characters.\n    """\n\n    model = None\n    plugin_options = {}\n    min_length = 1\n\n    def get_query(self, q, request):\n        """\n        Return a QuerySet searching for the query string `q`.\n\n        Note that you may return any iterable so you can return a list or even use yield and turn this\n        method into a generator.\n\n        Args:\n            q (str, unicode): The query string to search for.\n            request (Request): This can be used to customize the search by User or to use additional GET variables.\n\n        Returns:\n            (QuerySet, list, generator): iterable of related_models\n        """\n        kwargs = {"%s__icontains" % self.search_field: q}\n        return self.model.objects.filter(**kwargs).order_by(self.search_field)\n\n    def get_result(self, obj):\n        """The text result of autocompleting the entered query.\n\n        For a partial string that the user typed in, each matched result is here converted to the fully completed text.\n\n        This is currently displayed only for a moment in the text field after the user has selected the item.\n        Then the item is displayed in the item_display deck and the text field is cleared.\n\n        Args:\n            obj (Model):\n        Returns:\n            str: The object as string\n        """\n        return escape(force_text(obj))\n\n    def format_match(self, obj):\n        """(HTML) Format item for displaying in the dropdown.\n\n        Args:\n            obj (Model):\n        Returns:\n            str: formatted string, may contain HTML.\n        """\n        return escape(force_text(obj))\n\n    def format_item_display(self, obj):\n        """ (HTML) format item for displaying item in the selected deck area.\n\n        Args:\n            obj (Model):\n        Returns:\n            str: formatted string, may contain HTML.\n        """\n        return escape(force_text(obj))\n\n    def get_objects(self, ids):\n        """This is used to retrieve the currently selected objects for either ManyToMany or ForeignKey.\n\n        Note that the order of the ids supplied for ManyToMany fields is dependent on how the\n        objects manager fetches it.\n        ie. what is returned by `YourModel.{fieldname}_set.all()`\n\n        In most situations (especially postgres) this order is indeterminate -- not the order that you originally\n        added them in the interface.\n        See :doc:`/Ordered-ManyToMany` for a solution to this.\n\n        Args:\n            ids (list): list of primary keys\n        Returns:\n            list: list of Model objects\n        """\n        # return objects in the same order as passed in here\n        pk_type = self.model._meta.pk.to_python\n        ids = [pk_type(pk) for pk in ids]\n        things = self.model.objects.in_bulk(ids)\n        return [things[aid] for aid in ids if aid in things]\n\n    def can_add(self, user, other_model):\n        """Check if the user has permission to add a ForeignKey or M2M model.\n\n        This enables the green popup + on the widget.\n        Default implentation is the standard django permission check.\n\n        Args:\n            user (User)\n            other_model (Model): the ForeignKey or M2M model to check if the User can add.\n        Returns:\n            bool\n        """\n        from django.contrib.contenttypes.models import ContentType\n        ctype = ContentType.objects.get_for_model(other_model)\n        return user.has_perm("%s.add_%s" % (ctype.app_label, ctype.model))\n\n    def check_auth(self, request):\n        """By default only request.user.is_staff have access.\n\n        This ensures that nobody can get your data by simply knowing the lookup URL.\n\n        This is called from the ajax_lookup view.\n\n        Public facing forms (outside of the Admin) should implement this to allow\n        non-staff to use this LookupChannel.\n\n        Args:\n            request (Request)\n        Raises:\n            PermissionDenied\n        """\n        if not request.user.is_staff:\n            raise PermissionDenied\n'
u'1455,    def get_query(self, q, request):\n        """\n        Return a QuerySet searching for the query string `q`.\n\n        Note that you may return any iterable so you can return a list or even use yield and turn this\n        method into a generator.\n\n        Args:\n            q (str, unicode): The query string to search for.\n            request (Request): This can be used to customize the search by User or to use additional GET variables.\n\n        Returns:\n            (QuerySet, list, generator): iterable of related_models\n        """\n        kwargs = {"%s__icontains" % self.search_field: q}\n        return self.model.objects.filter(**kwargs).order_by(self.search_field)\n'
u'1456,    def get_result(self, obj):\n        """The text result of autocompleting the entered query.\n\n        For a partial string that the user typed in, each matched result is here converted to the fully completed text.\n\n        This is currently displayed only for a moment in the text field after the user has selected the item.\n        Then the item is displayed in the item_display deck and the text field is cleared.\n\n        Args:\n            obj (Model):\n        Returns:\n            str: The object as string\n        """\n        return escape(force_text(obj))\n'
u'1457,    def format_match(self, obj):\n        """(HTML) Format item for displaying in the dropdown.\n\n        Args:\n            obj (Model):\n        Returns:\n            str: formatted string, may contain HTML.\n        """\n        return escape(force_text(obj))\n'
u'1458,    def format_item_display(self, obj):\n        """ (HTML) format item for displaying item in the selected deck area.\n\n        Args:\n            obj (Model):\n        Returns:\n            str: formatted string, may contain HTML.\n        """\n        return escape(force_text(obj))\n'
u'1459,    def get_objects(self, ids):\n        """This is used to retrieve the currently selected objects for either ManyToMany or ForeignKey.\n\n        Note that the order of the ids supplied for ManyToMany fields is dependent on how the\n        objects manager fetches it.\n        ie. what is returned by `YourModel.{fieldname}_set.all()`\n\n        In most situations (especially postgres) this order is indeterminate -- not the order that you originally\n        added them in the interface.\n        See :doc:`/Ordered-ManyToMany` for a solution to this.\n\n        Args:\n            ids (list): list of primary keys\n        Returns:\n            list: list of Model objects\n        """\n        # return objects in the same order as passed in here\n        pk_type = self.model._meta.pk.to_python\n        ids = [pk_type(pk) for pk in ids]\n        things = self.model.objects.in_bulk(ids)\n        return [things[aid] for aid in ids if aid in things]\n'
u'1460,    def can_add(self, user, other_model):\n        """Check if the user has permission to add a ForeignKey or M2M model.\n\n        This enables the green popup + on the widget.\n        Default implentation is the standard django permission check.\n\n        Args:\n            user (User)\n            other_model (Model): the ForeignKey or M2M model to check if the User can add.\n        Returns:\n            bool\n        """\n        from django.contrib.contenttypes.models import ContentType\n        ctype = ContentType.objects.get_for_model(other_model)\n        return user.has_perm("%s.add_%s" % (ctype.app_label, ctype.model))\n'
u'1461,    def check_auth(self, request):\n        """By default only request.user.is_staff have access.\n\n        This ensures that nobody can get your data by simply knowing the lookup URL.\n\n        This is called from the ajax_lookup view.\n\n        Public facing forms (outside of the Admin) should implement this to allow\n        non-staff to use this LookupChannel.\n\n        Args:\n            request (Request)\n        Raises:\n            PermissionDenied\n        """\n        if not request.user.is_staff:\n            raise PermissionDenied\n'
u'1462,"""\nBlank file so that Django recognizes the app.\n\nThis is only required for Django < 1.7\n"""\n'
u'1463,from django.core.exceptions import ImproperlyConfigured\nfrom django.conf import settings\n\n\nclass LookupChannelRegistry(object):\n\n    """\n    Registry for LookupChannels activated for your django project.\n\n    This includes any installed apps that contain lookup.py modules (django 1.7+)\n    and any lookups that are explicitly declared in `settings.AJAX_LOOKUP_CHANNELS`\n    """\n    _registry = {}\n\n    def load_channels(self):\n        """\n        Called when loading the application. Cannot be called a second time,\n        (eg. for testing) as Django will not re-import and re-register anything.\n        """\n        self._registry = {}\n        try:\n            from django.utils.module_loading import autodiscover_modules\n        except ImportError:\n            pass\n        else:\n            autodiscover_modules(\'lookups\')\n\n        if hasattr(settings, \'AJAX_LOOKUP_CHANNELS\'):\n            self.register(settings.AJAX_LOOKUP_CHANNELS)\n\n    def register(self, lookup_specs):\n        """Register a set of lookup definitions.\n\n        Args:\n            lookup_specs (dict): One or more LookupChannel specifications\n                - `{\'channel\': LookupChannelSubclass}`\n                - `{\'channel\': (\'module.of.lookups\', \'MyLookupClass\')}`\n                - `{\'channel\': {\'model\': \'MyModelToBeLookedUp\', \'search_field\': \'field_to_search\'}}`\n        """\n        for channel, spec in lookup_specs.items():\n            if spec is None:  # unset\n                if channel in self._registry:\n                    del self._registry[channel]\n            else:\n                self._registry[channel] = spec\n\n    def get(self, channel):\n        """Find the LookupChannel class for the named channel and instantiate it.\n\n        Args:\n            channel (string):  - name that the lookup channel was registered at\n        Returns:\n            LookupChannel\n        Raises:\n            ImproperlyConfigured - if channel is not found.\n            Exception - invalid lookup_spec was stored in registery\n        """\n        from ajax_select import LookupChannel\n\n        try:\n            lookup_spec = self._registry[channel]\n        except KeyError:\n            raise ImproperlyConfigured(\n                "No ajax_select LookupChannel named %(channel)r is registered." % {\'channel\': channel})\n\n        if (type(lookup_spec) is type) and issubclass(lookup_spec, LookupChannel):\n            return lookup_spec()\n            # damnit python.\n            # ideally this would match regardless of how you imported the parent class\n            # but these are different classes:\n            # from ajax_select.lookup_channel import LookupChannel\n            # from ajax_select import LookupChannel\n        elif isinstance(lookup_spec, dict):\n            # \'channel\' : dict(model=\'app.model\', search_field=\'title\' )\n            #  generate a simple channel dynamically\n            return self.make_channel(lookup_spec[\'model\'], lookup_spec[\'search_field\'])\n        elif isinstance(lookup_spec, tuple):\n            # a tuple\n            # \'channel\' : (\'app.module\',\'LookupClass\')\n            #  from app.module load LookupClass and instantiate\n            lookup_module = __import__(lookup_spec[0], {}, {}, [\'\'])\n            lookup_class = getattr(lookup_module, lookup_spec[1])\n            return lookup_class()\n        else:\n            raise Exception("Invalid lookup spec: %s" % lookup_spec)\n\n    def is_registered(self, channel):\n        return channel in self._registry\n\n    def make_channel(self, app_model, arg_search_field):\n        """Automatically make a LookupChannel.\n\n        Args:\n            app_model (str):   app_name.ModelName\n            arg_search_field (str):  the field to search against and to display in search results\n        Returns:\n            LookupChannel\n        """\n        from ajax_select import LookupChannel\n        app_label, model_name = app_model.split(".")\n\n        class MadeLookupChannel(LookupChannel):\n\n            model = get_model(app_label, model_name)\n            search_field = arg_search_field\n\n        return MadeLookupChannel()\n\n\nregistry = LookupChannelRegistry()\n\n\ndef get_model(app_label, model_name):\n    """Loads the model given an \'app_label\' \'ModelName\'"""\n    try:\n        # django >= 1.7\n        from django.apps import apps\n    except ImportError:\n        # django < 1.7\n        from django.db import models\n        return models.get_model(app_label, model_name)\n    else:\n        return apps.get_model(app_label, model_name)\n\n\ndef can_autodiscover():\n    try:\n        from django.apps import AppConfig  # noqa\n    except ImportError:\n        return False\n    return True\n\n\ndef register(channel):\n    """Decorator to register a LookupClass.\n\n    Example::\n        from ajax_select import LookupChannel, register\n\n        @register(\'agent\')\n        class AgentLookup(LookupClass):\n\n            def get_query(self):\n                ...\n            def format_item(self):\n                ...\n\n    """\n\n    def _wrapper(lookup_class):\n        if not channel:\n            raise ValueError(\'Lookup Channel must have a channel name\')\n\n        registry.register({channel: lookup_class})\n\n        return lookup_class\n\n    return _wrapper\n'
u'1464,class LookupChannelRegistry(object):\n\n    """\n    Registry for LookupChannels activated for your django project.\n\n    This includes any installed apps that contain lookup.py modules (django 1.7+)\n    and any lookups that are explicitly declared in `settings.AJAX_LOOKUP_CHANNELS`\n    """\n    _registry = {}\n\n    def load_channels(self):\n        """\n        Called when loading the application. Cannot be called a second time,\n        (eg. for testing) as Django will not re-import and re-register anything.\n        """\n        self._registry = {}\n        try:\n            from django.utils.module_loading import autodiscover_modules\n        except ImportError:\n            pass\n        else:\n            autodiscover_modules(\'lookups\')\n\n        if hasattr(settings, \'AJAX_LOOKUP_CHANNELS\'):\n            self.register(settings.AJAX_LOOKUP_CHANNELS)\n\n    def register(self, lookup_specs):\n        """Register a set of lookup definitions.\n\n        Args:\n            lookup_specs (dict): One or more LookupChannel specifications\n                - `{\'channel\': LookupChannelSubclass}`\n                - `{\'channel\': (\'module.of.lookups\', \'MyLookupClass\')}`\n                - `{\'channel\': {\'model\': \'MyModelToBeLookedUp\', \'search_field\': \'field_to_search\'}}`\n        """\n        for channel, spec in lookup_specs.items():\n            if spec is None:  # unset\n                if channel in self._registry:\n                    del self._registry[channel]\n            else:\n                self._registry[channel] = spec\n\n    def get(self, channel):\n        """Find the LookupChannel class for the named channel and instantiate it.\n\n        Args:\n            channel (string):  - name that the lookup channel was registered at\n        Returns:\n            LookupChannel\n        Raises:\n            ImproperlyConfigured - if channel is not found.\n            Exception - invalid lookup_spec was stored in registery\n        """\n        from ajax_select import LookupChannel\n\n        try:\n            lookup_spec = self._registry[channel]\n        except KeyError:\n            raise ImproperlyConfigured(\n                "No ajax_select LookupChannel named %(channel)r is registered." % {\'channel\': channel})\n\n        if (type(lookup_spec) is type) and issubclass(lookup_spec, LookupChannel):\n            return lookup_spec()\n            # damnit python.\n            # ideally this would match regardless of how you imported the parent class\n            # but these are different classes:\n            # from ajax_select.lookup_channel import LookupChannel\n            # from ajax_select import LookupChannel\n        elif isinstance(lookup_spec, dict):\n            # \'channel\' : dict(model=\'app.model\', search_field=\'title\' )\n            #  generate a simple channel dynamically\n            return self.make_channel(lookup_spec[\'model\'], lookup_spec[\'search_field\'])\n        elif isinstance(lookup_spec, tuple):\n            # a tuple\n            # \'channel\' : (\'app.module\',\'LookupClass\')\n            #  from app.module load LookupClass and instantiate\n            lookup_module = __import__(lookup_spec[0], {}, {}, [\'\'])\n            lookup_class = getattr(lookup_module, lookup_spec[1])\n            return lookup_class()\n        else:\n            raise Exception("Invalid lookup spec: %s" % lookup_spec)\n\n    def is_registered(self, channel):\n        return channel in self._registry\n\n    def make_channel(self, app_model, arg_search_field):\n        """Automatically make a LookupChannel.\n\n        Args:\n            app_model (str):   app_name.ModelName\n            arg_search_field (str):  the field to search against and to display in search results\n        Returns:\n            LookupChannel\n        """\n        from ajax_select import LookupChannel\n        app_label, model_name = app_model.split(".")\n\n        class MadeLookupChannel(LookupChannel):\n\n            model = get_model(app_label, model_name)\n            search_field = arg_search_field\n\n        return MadeLookupChannel()\n'
u'1465,def get_model(app_label, model_name):\n    """Loads the model given an \'app_label\' \'ModelName\'"""\n    try:\n        # django >= 1.7\n        from django.apps import apps\n    except ImportError:\n        # django < 1.7\n        from django.db import models\n        return models.get_model(app_label, model_name)\n    else:\n        return apps.get_model(app_label, model_name)\n'
u'1466,def can_autodiscover():\n    try:\n        from django.apps import AppConfig  # noqa\n    except ImportError:\n        return False\n    return True\n'
u'1467,def register(channel):\n    """Decorator to register a LookupClass.\n\n    Example::\n        from ajax_select import LookupChannel, register\n\n        @register(\'agent\')\n        class AgentLookup(LookupClass):\n\n            def get_query(self):\n                ...\n            def format_item(self):\n                ...\n\n    """\n\n    def _wrapper(lookup_class):\n        if not channel:\n            raise ValueError(\'Lookup Channel must have a channel name\')\n\n        registry.register({channel: lookup_class})\n\n        return lookup_class\n\n    return _wrapper\n'
u'1468,    def load_channels(self):\n        """\n        Called when loading the application. Cannot be called a second time,\n        (eg. for testing) as Django will not re-import and re-register anything.\n        """\n        self._registry = {}\n        try:\n            from django.utils.module_loading import autodiscover_modules\n        except ImportError:\n            pass\n        else:\n            autodiscover_modules(\'lookups\')\n\n        if hasattr(settings, \'AJAX_LOOKUP_CHANNELS\'):\n            self.register(settings.AJAX_LOOKUP_CHANNELS)\n'
u'1469,    def register(self, lookup_specs):\n        """Register a set of lookup definitions.\n\n        Args:\n            lookup_specs (dict): One or more LookupChannel specifications\n                - `{\'channel\': LookupChannelSubclass}`\n                - `{\'channel\': (\'module.of.lookups\', \'MyLookupClass\')}`\n                - `{\'channel\': {\'model\': \'MyModelToBeLookedUp\', \'search_field\': \'field_to_search\'}}`\n        """\n        for channel, spec in lookup_specs.items():\n            if spec is None:  # unset\n                if channel in self._registry:\n                    del self._registry[channel]\n            else:\n                self._registry[channel] = spec\n'
u'1470,    def get(self, channel):\n        """Find the LookupChannel class for the named channel and instantiate it.\n\n        Args:\n            channel (string):  - name that the lookup channel was registered at\n        Returns:\n            LookupChannel\n        Raises:\n            ImproperlyConfigured - if channel is not found.\n            Exception - invalid lookup_spec was stored in registery\n        """\n        from ajax_select import LookupChannel\n\n        try:\n            lookup_spec = self._registry[channel]\n        except KeyError:\n            raise ImproperlyConfigured(\n                "No ajax_select LookupChannel named %(channel)r is registered." % {\'channel\': channel})\n\n        if (type(lookup_spec) is type) and issubclass(lookup_spec, LookupChannel):\n            return lookup_spec()\n            # damnit python.\n            # ideally this would match regardless of how you imported the parent class\n            # but these are different classes:\n            # from ajax_select.lookup_channel import LookupChannel\n            # from ajax_select import LookupChannel\n        elif isinstance(lookup_spec, dict):\n            # \'channel\' : dict(model=\'app.model\', search_field=\'title\' )\n            #  generate a simple channel dynamically\n            return self.make_channel(lookup_spec[\'model\'], lookup_spec[\'search_field\'])\n        elif isinstance(lookup_spec, tuple):\n            # a tuple\n            # \'channel\' : (\'app.module\',\'LookupClass\')\n            #  from app.module load LookupClass and instantiate\n            lookup_module = __import__(lookup_spec[0], {}, {}, [\'\'])\n            lookup_class = getattr(lookup_module, lookup_spec[1])\n            return lookup_class()\n        else:\n            raise Exception("Invalid lookup spec: %s" % lookup_spec)\n'
u'1471,    def is_registered(self, channel):\n        return channel in self._registry\n'
u'1472,    def make_channel(self, app_model, arg_search_field):\n        """Automatically make a LookupChannel.\n\n        Args:\n            app_model (str):   app_name.ModelName\n            arg_search_field (str):  the field to search against and to display in search results\n        Returns:\n            LookupChannel\n        """\n        from ajax_select import LookupChannel\n        app_label, model_name = app_model.split(".")\n\n        class MadeLookupChannel(LookupChannel):\n\n            model = get_model(app_label, model_name)\n            search_field = arg_search_field\n\n        return MadeLookupChannel()\n'
u"1473,    def _wrapper(lookup_class):\n        if not channel:\n            raise ValueError('Lookup Channel must have a channel name')\n\n        registry.register({channel: lookup_class})\n\n        return lookup_class\n"
u'1474,        class MadeLookupChannel(LookupChannel):\n\n            model = get_model(app_label, model_name)\n            search_field = arg_search_field\n'
u"1475,from django.conf.urls import url\nfrom ajax_select import views\n\nurlpatterns = [\n    url(r'^ajax_lookup/(?P<channel>[-\\w]+)$',\n        views.ajax_lookup,\n        name='ajax_lookup')\n]\n"
u'1476,import json\nfrom django.http import HttpResponse\nfrom django.utils.encoding import force_text\nfrom ajax_select import registry\n\n\ndef ajax_lookup(request, channel):\n\n    """Load the named lookup channel and lookup matching models.\n\n    GET or POST should contain \'term\'\n\n    Returns:\n        HttpResponse - JSON: `[{pk: value: match: repr:}, ...]`\n    Raises:\n        PermissionDenied - depending on the LookupChannel\'s implementation of check_auth\n    """\n\n    # it should come in as GET unless global $.ajaxSetup({type:"POST"}) has been set\n    # in which case we\'ll support POST\n    if request.method == "GET":\n        # we could also insist on an ajax request\n        if \'term\' not in request.GET:\n            return HttpResponse(\'\')\n        query = request.GET[\'term\']\n    else:\n        if \'term\' not in request.POST:\n            return HttpResponse(\'\')  # suspicious\n        query = request.POST[\'term\']\n\n    lookup = registry.get(channel)\n    if hasattr(lookup, \'check_auth\'):\n        lookup.check_auth(request)\n\n    if len(query) >= getattr(lookup, \'min_length\', 1):\n        instances = lookup.get_query(query, request)\n    else:\n        instances = []\n\n    results = json.dumps([\n        {\n            \'pk\': force_text(getattr(item, \'pk\', None)),\n            \'value\': lookup.get_result(item),\n            \'match\': lookup.format_match(item),\n            \'repr\': lookup.format_item_display(item)\n        } for item in instances\n    ])\n\n    response = HttpResponse(results, content_type=\'application/json\')\n    response[\'Cache-Control\'] = \'max-age=0, must-revalidate, no-store, no-cache;\'\n    return response\n'
u'1477,def ajax_lookup(request, channel):\n\n    """Load the named lookup channel and lookup matching models.\n\n    GET or POST should contain \'term\'\n\n    Returns:\n        HttpResponse - JSON: `[{pk: value: match: repr:}, ...]`\n    Raises:\n        PermissionDenied - depending on the LookupChannel\'s implementation of check_auth\n    """\n\n    # it should come in as GET unless global $.ajaxSetup({type:"POST"}) has been set\n    # in which case we\'ll support POST\n    if request.method == "GET":\n        # we could also insist on an ajax request\n        if \'term\' not in request.GET:\n            return HttpResponse(\'\')\n        query = request.GET[\'term\']\n    else:\n        if \'term\' not in request.POST:\n            return HttpResponse(\'\')  # suspicious\n        query = request.POST[\'term\']\n\n    lookup = registry.get(channel)\n    if hasattr(lookup, \'check_auth\'):\n        lookup.check_auth(request)\n\n    if len(query) >= getattr(lookup, \'min_length\', 1):\n        instances = lookup.get_query(query, request)\n    else:\n        instances = []\n\n    results = json.dumps([\n        {\n            \'pk\': force_text(getattr(item, \'pk\', None)),\n            \'value\': lookup.get_result(item),\n            \'match\': lookup.format_match(item),\n            \'repr\': lookup.format_item_display(item)\n        } for item in instances\n    ])\n\n    response = HttpResponse(results, content_type=\'application/json\')\n    response[\'Cache-Control\'] = \'max-age=0, must-revalidate, no-store, no-cache;\'\n    return response\n'
u'1478,#!/usr/bin/env python\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from ez_setup import use_setuptools\n    use_setuptools()\n    from setuptools import setup\n\nsetup(\n    name=\'15five-django-ajax-selects\',\n    version=\'1.5.2.155\',\n    description=\'Edit ForeignKey, ManyToManyField and CharField in Django Admin using jQuery UI AutoComplete.\',\n    author=\'Chris Sattinger\',\n    author_email=\'crucialfelix@gmail.com\',\n    url=\'https://github.com/crucialfelix/django-ajax-selects/\',\n    packages=[\'ajax_select\'],\n    package_data={\'ajax_select\':\n        [\n            \'*.py\',\n            \'*.txt\',\n            \'*.md\',\n            \'static/ajax_select/css/*\',\n            \'static/ajax_select/images/*\',\n            \'static/ajax_select/js/*\',\n            \'templates/ajax_select/*.html\'\n        ]\n    },\n    include_package_data=True,\n    zip_safe=False,\n    license="MIT",\n    classifiers=[\n        "Programming Language :: Python",\n        "Programming Language :: Python :: 2",\n        "Programming Language :: Python :: 3",\n        "Development Status :: 5 - Production/Stable",\n        \'Environment :: Web Environment\',\n        "Intended Audience :: Developers",\n        "License :: OSI Approved :: MIT License",\n        "Operating System :: OS Independent",\n        "Topic :: Software Development :: Libraries :: Python Modules",\n        "Topic :: Software Development :: User Interfaces",\n        "Framework :: Django",\n    ],\n    long_description="""\\\nEdit ForeignKey, ManyToManyField and CharField in Django Admin using jQuery UI AutoComplete.\n\n- Customize search query\n- Query other resources besides Django ORM\n- Format results with HTML\n- Customize styling\n- Customize security policy\n- Add additional custom UI alongside widget\n- Integrate with other UI elements elsewhere on the page using the javascript API\n- Works in Admin as well as in normal views\n\n- Django >=1.6, <=1.10\n- Python >=2.7, <=3.5\n"""\n)\n'
u'1479,\nfrom django.contrib import admin\nfrom ajax_select.admin import AjaxSelectAdmin, AjaxSelectAdminTabularInline\nfrom tests.models import Author, Book, Person\nfrom tests.test_integration import BookForm\n\n\nclass BookAdmin(AjaxSelectAdmin):\n    form = BookForm\nadmin.site.register(Book, BookAdmin)\n\n\nclass BookInline(AjaxSelectAdminTabularInline):\n\n    model = Book\n    form = BookForm\n    extra = 2\n\n\nclass AuthorAdmin(AjaxSelectAdmin):\n\n    inlines = [\n        BookInline\n    ]\n\nadmin.site.register(Author, AuthorAdmin)\n\n\nclass PersonAdmin(admin.ModelAdmin):\n    pass\nadmin.site.register(Person, PersonAdmin)\n'
u'1480,class BookAdmin(AjaxSelectAdmin):\n    form = BookForm\n'
u'1481,class BookInline(AjaxSelectAdminTabularInline):\n\n    model = Book\n    form = BookForm\n    extra = 2\n'
u'1482,class AuthorAdmin(AjaxSelectAdmin):\n\n    inlines = [\n        BookInline\n    ]\n'
u'1483,class PersonAdmin(admin.ModelAdmin):\n    pass\n'
u'1484,"""\nTesting the register and autoloading.\n\nShould not be used by other tests.\n"""\nfrom django.utils.html import escape\nfrom django.contrib.auth.models import User\nfrom tests.models import Person, Author\nimport ajax_select\n\n\n@ajax_select.register(\'person\')\nclass PersonLookup(ajax_select.LookupChannel):\n\n    model = Person\n\n    def get_query(self, q, request):\n        return self.model.objects.filter(name__icontains=q)\n\n    def get_result(self, obj):\n        return obj.name\n\n    def format_match(self, obj):\n        return "%s<div><i>%s</i></div>" % (escape(obj.name), escape(obj.email))\n\n    def format_item_display(self, obj):\n        return "%s<div><i>%s</i></div>" % (escape(obj.name), escape(obj.email))\n\n\n@ajax_select.register(\'user\')\nclass UserLookup(ajax_select.LookupChannel):\n\n    """\n    Test if you can unset a lookup provided by a third-party application.\n    In this case it exposes User without any auth checking\n    and somebody could manually check the ajax URL and find out\n    if a user email exists.\n    So you might want to turn this channel off\n    by settings.AJAX_LOOKUP_CHANNELS[\'user\'] = None\n    """\n\n    model = User\n\n    def get_query(self, q, request):\n        return self.model.objects.filter(email=q)\n\n\n@ajax_select.register(\'name\')\nclass NameLookup(ajax_select.LookupChannel):\n\n    def get_query(self, q, request):\n        return [\'Joseph Simmons\', \'Darryl McDaniels\', \'Jam Master Jay\']\n\n\n@ajax_select.register(\'author\')\nclass AuthorLookup(ajax_select.LookupChannel):\n\n    model = Author\n'
u'1485,@ajax_select.register(\'person\')\nclass PersonLookup(ajax_select.LookupChannel):\n\n    model = Person\n\n    def get_query(self, q, request):\n        return self.model.objects.filter(name__icontains=q)\n\n    def get_result(self, obj):\n        return obj.name\n\n    def format_match(self, obj):\n        return "%s<div><i>%s</i></div>" % (escape(obj.name), escape(obj.email))\n\n    def format_item_display(self, obj):\n        return "%s<div><i>%s</i></div>" % (escape(obj.name), escape(obj.email))\n'
u'1486,@ajax_select.register(\'user\')\nclass UserLookup(ajax_select.LookupChannel):\n\n    """\n    Test if you can unset a lookup provided by a third-party application.\n    In this case it exposes User without any auth checking\n    and somebody could manually check the ajax URL and find out\n    if a user email exists.\n    So you might want to turn this channel off\n    by settings.AJAX_LOOKUP_CHANNELS[\'user\'] = None\n    """\n\n    model = User\n\n    def get_query(self, q, request):\n        return self.model.objects.filter(email=q)\n'
u"1487,@ajax_select.register('name')\nclass NameLookup(ajax_select.LookupChannel):\n\n    def get_query(self, q, request):\n        return ['Joseph Simmons', 'Darryl McDaniels', 'Jam Master Jay']\n"
u"1488,@ajax_select.register('author')\nclass AuthorLookup(ajax_select.LookupChannel):\n\n    model = Author\n"
u'1489,    def get_query(self, q, request):\n        return self.model.objects.filter(name__icontains=q)\n'
u'1490,    def get_result(self, obj):\n        return obj.name\n'
u'1491,    def format_match(self, obj):\n        return "%s<div><i>%s</i></div>" % (escape(obj.name), escape(obj.email))\n'
u'1492,    def format_item_display(self, obj):\n        return "%s<div><i>%s</i></div>" % (escape(obj.name), escape(obj.email))\n'
u'1493,    def get_query(self, q, request):\n        return self.model.objects.filter(email=q)\n'
u"1494,    def get_query(self, q, request):\n        return ['Joseph Simmons', 'Darryl McDaniels', 'Jam Master Jay']\n"
u'1495,\nfrom django.db import models\n\n\nclass Person(models.Model):\n\n    name = models.CharField(max_length=50)\n    email = models.EmailField(null=True, blank=True)\n\n    class Meta:\n        app_label = \'tests\'\n\n\nclass Author(models.Model):\n\n    name = models.CharField(max_length=50)\n\n    class Meta:\n        app_label = \'tests\'\n\n\nclass Book(models.Model):\n\n    """ Book has no admin, its an inline in the Author admin"""\n\n    author = models.ForeignKey(Author, null=True)\n    name = models.CharField(max_length=50)\n    mentions_persons = models.ManyToManyField(Person, help_text="MENTIONS PERSONS HELP TEXT")\n\n    class Meta:\n        app_label = \'tests\'\n'
u"1496,class Person(models.Model):\n\n    name = models.CharField(max_length=50)\n    email = models.EmailField(null=True, blank=True)\n\n    class Meta:\n        app_label = 'tests'\n"
u"1497,class Author(models.Model):\n\n    name = models.CharField(max_length=50)\n\n    class Meta:\n        app_label = 'tests'\n"
u'1498,class Book(models.Model):\n\n    """ Book has no admin, its an inline in the Author admin"""\n\n    author = models.ForeignKey(Author, null=True)\n    name = models.CharField(max_length=50)\n    mentions_persons = models.ManyToManyField(Person, help_text="MENTIONS PERSONS HELP TEXT")\n\n    class Meta:\n        app_label = \'tests\'\n'
u"1499,    class Meta:\n        app_label = 'tests'\n"
u"1500,    class Meta:\n        app_label = 'tests'\n"
u"1501,    class Meta:\n        app_label = 'tests'\n"
u'1502,"""Testing if lookups that are not in a file named lookups.py can be loaded correctly."""\n\nimport ajax_select\nfrom tests.models import Book\n\n\nclass BookLookup(ajax_select.LookupChannel):\n\n    model = Book\n'
u'1503,class BookLookup(ajax_select.LookupChannel):\n\n    model = Book\n'
u'1504,DEBUG = True\nUSE_TZ = True\nDATABASES = {\n    "default": {\n        "ENGINE": "django.db.backends.sqlite3",\n    }\n}\nROOT_URLCONF = "tests.urls"\nINSTALLED_APPS = [\n    "django.contrib.auth",\n    "django.contrib.contenttypes",\n    "django.contrib.sites",\n    \'django.contrib.messages\',\n    \'django.contrib.sessions\',\n    \'django.contrib.admin\',\n    \'django.contrib.staticfiles\',\n    "ajax_select",\n    "tests"\n]\nSITE_ID = 1\nMIDDLEWARE_CLASSES = (\n    \'django.contrib.sessions.middleware.SessionMiddleware\',\n    \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n    \'django.contrib.messages.middleware.MessageMiddleware\'\n)\nSTATIC_URL = \'/static/\'\nSECRET_KEY = \'inyd5fc5pymlsv@hwoc5+3_6*cm0erlxzv6i-wl0jm_kt-6rp9\'\n\nAJAX_LOOKUP_CHANNELS = {\n    # tuple points to a module and class to load\n    \'book\': (\'tests.other_lookups\', \'BookLookup\'),\n    # dict specifies an automatically constructed LookupChannel\n    \'author\': {\'model\': \'tests.Author\', \'search_field\': \'name\'},\n    # unset a channel that a third-party app specified\n    \'user\': None,\n    \'was-never-a-channel\': None\n    # LookupChannels in lookups.py are auto-loaded\n}\n\nTEMPLATES = [\n    {\n        \'BACKEND\': \'django.template.backends.django.DjangoTemplates\',\n        \'DIRS\': [\n            # insert your TEMPLATE_DIRS here\n        ],\n        \'APP_DIRS\': True,\n        \'OPTIONS\': {\n            \'context_processors\': [\n                # Insert your TEMPLATE_CONTEXT_PROCESSORS here or use this\n                # list if you haven\'t customized them:\n                \'django.contrib.auth.context_processors.auth\',\n                \'django.template.context_processors.debug\',\n                \'django.template.context_processors.i18n\',\n                \'django.template.context_processors.media\',\n                \'django.template.context_processors.static\',\n                \'django.template.context_processors.tz\',\n                \'django.contrib.messages.context_processors.messages\',\n            ],\n        },\n    },\n]\n'
u"1505,from django.test import TestCase\nfrom ajax_select import fields\nfrom tests.models import Book\n\n\nclass TestAutoCompleteSelectWidget(TestCase):\n\n    def test_render(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectWidget(channel)\n        out = widget.render('book', None)\n        self.assertTrue('autocompleteselect' in out)\n\n    def test_render_with_value(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectWidget(channel)\n        book = Book.objects.create(name='book')\n        out = widget.render('book', book.pk)\n        self.assertTrue('autocompleteselect' in out)\n\n\nclass TestAutoCompleteSelectMultipleWidget(TestCase):\n\n    def test_render(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectMultipleWidget(channel)\n        out = widget.render('book', None)\n        self.assertTrue('autocompleteselectmultiple' in out)\n\n    def test_render_with_query_set(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectMultipleWidget(channel)\n        Book.objects.create(name='book')\n        out = widget.render('book', Book.objects.all())\n        self.assertTrue('autocompleteselectmultiple' in out)\n\n\nclass TestAutoCompleteWidget(TestCase):\n\n    def test_render(self):\n        channel = 'book'\n        widget = fields.AutoCompleteWidget(channel)\n        out = widget.render('book', None)\n        self.assertTrue('autocomplete' in out)\n\n\nclass TestAutoCompleteSelectField(TestCase):\n\n    def test_has_changed(self):\n        field = fields.AutoCompleteSelectField('book')\n        self.assertFalse(field.has_changed(1, '1'))\n        self.assertFalse(field.has_changed('abc', 'abc'))\n        self.assertTrue(field.has_changed(1, '2'))\n        self.assertFalse(field.has_changed(None, ''))\n        self.assertFalse(field.has_changed(None, None))\n        self.assertFalse(field.has_changed('', None))\n\n\nclass TestAutoCompleteSelectMultipleField(TestCase):\n\n    def test_has_changed(self):\n        field = fields.AutoCompleteSelectMultipleField('book')\n        self.assertFalse(field.has_changed([1], ['1']))\n        self.assertFalse(field.has_changed(['abc'], ['abc']))\n        self.assertTrue(field.has_changed([1], ['2']))\n\n    def test_has_changed_blank_input(self):\n        field = fields.AutoCompleteSelectMultipleField('book')\n        self.assertTrue(field.has_changed(None, ['1']))\n        self.assertFalse(field.has_changed(None, []))\n"
u"1506,class TestAutoCompleteSelectWidget(TestCase):\n\n    def test_render(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectWidget(channel)\n        out = widget.render('book', None)\n        self.assertTrue('autocompleteselect' in out)\n\n    def test_render_with_value(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectWidget(channel)\n        book = Book.objects.create(name='book')\n        out = widget.render('book', book.pk)\n        self.assertTrue('autocompleteselect' in out)\n"
u"1507,class TestAutoCompleteSelectMultipleWidget(TestCase):\n\n    def test_render(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectMultipleWidget(channel)\n        out = widget.render('book', None)\n        self.assertTrue('autocompleteselectmultiple' in out)\n\n    def test_render_with_query_set(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectMultipleWidget(channel)\n        Book.objects.create(name='book')\n        out = widget.render('book', Book.objects.all())\n        self.assertTrue('autocompleteselectmultiple' in out)\n"
u"1508,class TestAutoCompleteWidget(TestCase):\n\n    def test_render(self):\n        channel = 'book'\n        widget = fields.AutoCompleteWidget(channel)\n        out = widget.render('book', None)\n        self.assertTrue('autocomplete' in out)\n"
u"1509,class TestAutoCompleteSelectField(TestCase):\n\n    def test_has_changed(self):\n        field = fields.AutoCompleteSelectField('book')\n        self.assertFalse(field.has_changed(1, '1'))\n        self.assertFalse(field.has_changed('abc', 'abc'))\n        self.assertTrue(field.has_changed(1, '2'))\n        self.assertFalse(field.has_changed(None, ''))\n        self.assertFalse(field.has_changed(None, None))\n        self.assertFalse(field.has_changed('', None))\n"
u"1510,class TestAutoCompleteSelectMultipleField(TestCase):\n\n    def test_has_changed(self):\n        field = fields.AutoCompleteSelectMultipleField('book')\n        self.assertFalse(field.has_changed([1], ['1']))\n        self.assertFalse(field.has_changed(['abc'], ['abc']))\n        self.assertTrue(field.has_changed([1], ['2']))\n\n    def test_has_changed_blank_input(self):\n        field = fields.AutoCompleteSelectMultipleField('book')\n        self.assertTrue(field.has_changed(None, ['1']))\n        self.assertFalse(field.has_changed(None, []))\n"
u"1511,    def test_render(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectWidget(channel)\n        out = widget.render('book', None)\n        self.assertTrue('autocompleteselect' in out)\n"
u"1512,    def test_render_with_value(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectWidget(channel)\n        book = Book.objects.create(name='book')\n        out = widget.render('book', book.pk)\n        self.assertTrue('autocompleteselect' in out)\n"
u"1513,    def test_render(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectMultipleWidget(channel)\n        out = widget.render('book', None)\n        self.assertTrue('autocompleteselectmultiple' in out)\n"
u"1514,    def test_render_with_query_set(self):\n        channel = 'book'\n        widget = fields.AutoCompleteSelectMultipleWidget(channel)\n        Book.objects.create(name='book')\n        out = widget.render('book', Book.objects.all())\n        self.assertTrue('autocompleteselectmultiple' in out)\n"
u"1515,    def test_render(self):\n        channel = 'book'\n        widget = fields.AutoCompleteWidget(channel)\n        out = widget.render('book', None)\n        self.assertTrue('autocomplete' in out)\n"
u"1516,    def test_has_changed(self):\n        field = fields.AutoCompleteSelectField('book')\n        self.assertFalse(field.has_changed(1, '1'))\n        self.assertFalse(field.has_changed('abc', 'abc'))\n        self.assertTrue(field.has_changed(1, '2'))\n        self.assertFalse(field.has_changed(None, ''))\n        self.assertFalse(field.has_changed(None, None))\n        self.assertFalse(field.has_changed('', None))\n"
u"1517,    def test_has_changed(self):\n        field = fields.AutoCompleteSelectMultipleField('book')\n        self.assertFalse(field.has_changed([1], ['1']))\n        self.assertFalse(field.has_changed(['abc'], ['abc']))\n        self.assertTrue(field.has_changed([1], ['2']))\n"
u"1518,    def test_has_changed_blank_input(self):\n        field = fields.AutoCompleteSelectMultipleField('book')\n        self.assertTrue(field.has_changed(None, ['1']))\n        self.assertFalse(field.has_changed(None, []))\n"
u'1519,"""\nTest render and submit from the highest Django API level\nso we are testing with exactly what Django gives.\n\nSpecific errors that are discovered through these tests\nshould be unit tested in test_fields.py\n"""\nfrom __future__ import unicode_literals\nimport django\nfrom django.forms.models import ModelForm\nfrom django.test import TestCase, Client\nfrom django.core.urlresolvers import reverse\nfrom django.contrib.auth.models import User\n\nfrom tests.models import Book, Author, Person\nfrom ajax_select import fields\n\n# Other versions will autoload\nif django.VERSION[1] < 7:\n    from tests import lookups  # noqa\n\n# ---------------  setup ----------------------------------- #\n\n\nclass BookForm(ModelForm):\n\n    class Meta:\n        model = Book\n        fields = [\'name\', \'author\', \'mentions_persons\']\n\n    name = fields.AutoCompleteField(\'name\')\n    author = fields.AutoCompleteSelectField(\'author\')\n    mentions_persons = fields.AutoCompleteSelectMultipleField(\'person\')\n\n\n# ---------------  tests ----------------------------------- #\n\nclass TestBookForm(TestCase):\n\n    def test_render_no_data(self):\n        form = BookForm()\n        out = form.as_p()\n        # print(out)\n        self.assertTrue(\'autocomplete\' in out)\n        self.assertTrue(\'autocompleteselect\' in out)\n        self.assertTrue(\'autocompleteselectmultiple\' in out)\n\n    def _make_instance(self):\n        author = Author.objects.create(name="author")\n        book = Book.objects.create(name="book", author=author)\n        book.mentions_persons = [Person.objects.create(name=\'person\')]\n        return book\n\n    def _book_data(self, book):\n        persons_pks = [person.pk for person in book.mentions_persons.all()]\n        mentions_persons = fields.pack_ids(persons_pks)\n\n        return {\n            \'author\': str(book.author.pk),\n            \'name\': book.name,\n            \'mentions_persons\': mentions_persons\n        }\n\n    def test_render_instance(self):\n        book = self._make_instance()\n        form = BookForm(instance=book)\n        out = form.as_p()\n        # print(out)\n        self.assertTrue(\'autocomplete\' in out)\n        self.assertTrue(\'autocompleteselect\' in out)\n        self.assertTrue(\'autocompleteselectmultiple\' in out)\n\n    def test_render_with_data(self):\n        """\n        Rendering a form with data already in it\n        because it is pre-filled or had errors and is redisplaying.\n        """\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        out = form.as_p()\n        # print(out)\n        # should have the values in there somewhere\n        self.assertTrue(\'autocomplete\' in out)\n        self.assertTrue(\'autocompleteselect\' in out)\n        self.assertTrue(\'autocompleteselectmultiple\' in out)\n\n    def test_render_with_initial(self):\n        book = self._make_instance()\n        # this is data for the form submit\n        data = self._book_data(book)\n        # initial wants the pks\n        data[\'mentions_persons\'] = [p.pk for p in book.mentions_persons.all()]\n        form = BookForm(initial=data)\n        out = form.as_p()\n        # print(out)\n        # should have the values in there somewhere\n        self.assertTrue(\'autocomplete\' in out)\n        self.assertTrue(\'autocompleteselect\' in out)\n        self.assertTrue(\'autocompleteselectmultiple\' in out)\n\n    def test_is_valid(self):\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        self.assertTrue(form.is_valid())\n\n    def test_full_clean(self):\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        form.full_clean()\n        data = form.cleaned_data\n        # {u\'author\': <Author: Author object>, u\'name\': u\'book\', u\'mentions_persons\': [u\'1\']}\n        self.assertEqual(data[\'author\'], book.author)\n        self.assertEqual(data[\'name\'], book.name)\n        # why aren\'t they instances ?\n        self.assertEqual(data[\'mentions_persons\'], [str(p.pk) for p in book.mentions_persons.all()])\n\n    def test_save(self):\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        saved = form.save()\n        self.assertTrue(saved.pk is not None)\n\n    # def test_save_instance(self):\n    #     book = self._make_instance()\n    #     form = BookForm(instance=book)\n    #     import pdb; pdb.set_trace()\n    #     if form.is_valid():\n    #         saved = form.save()\n    #     else:\n    #         print(form.errors)\n    #         saved = None\n    #     self.assertTrue(saved is not None)\n    #     self.assertEqual(saved.pk, book.pk)\n\n\nclass TestAdmin(TestCase):\n\n    def setUp(self):\n        self.user = User.objects.create_superuser(\'admin\', \'admin@example.com\', \'password\')\n        self.client = Client()\n        ok = self.client.login(username=\'admin\', password=\'password\')\n        if not ok:\n            raise Exception("Failed to log in")\n\n\nclass TestBookAdmin(TestAdmin):\n\n    """\n    Test the admins in tests/admin.py\n    """\n\n    def test_get_blank(self):\n        app_label = \'tests\'\n        model = \'book\'\n        response = self.client.get(reverse(\'admin:%s_%s_add\' % (app_label, model)))\n        content = str(response.content)\n        # print(content)\n\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(\'/static/ajax_select/js/ajax_select.js\' in content)\n        self.assertTrue(\'autocompleteselectmultiple\' in content)\n        self.assertTrue(\'autocompleteselect\' in content)\n        self.assertTrue(\'autocomplete\' in content)\n        self.assertTrue(\'/admin/tests/author/add/?_popup=1\' in content)\n        self.assertTrue(\'/admin/tests/person/add/?_popup=1\' in content)\n\n\nclass TestAuthorAdmin(TestAdmin):\n\n    """\n    Test an admin with inlines\n    """\n\n    def test_get_blank(self):\n        app_label = \'tests\'\n        model = \'author\'\n        response = self.client.get(reverse(\'admin:%s_%s_add\' % (app_label, model)))\n        content = str(response.content)\n        # print(content)\n\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(\'book_set-1-mentions_persons\' in content)\n'
u"1520,class BookForm(ModelForm):\n\n    class Meta:\n        model = Book\n        fields = ['name', 'author', 'mentions_persons']\n\n    name = fields.AutoCompleteField('name')\n    author = fields.AutoCompleteSelectField('author')\n    mentions_persons = fields.AutoCompleteSelectMultipleField('person')\n"
u'1521,class TestBookForm(TestCase):\n\n    def test_render_no_data(self):\n        form = BookForm()\n        out = form.as_p()\n        # print(out)\n        self.assertTrue(\'autocomplete\' in out)\n        self.assertTrue(\'autocompleteselect\' in out)\n        self.assertTrue(\'autocompleteselectmultiple\' in out)\n\n    def _make_instance(self):\n        author = Author.objects.create(name="author")\n        book = Book.objects.create(name="book", author=author)\n        book.mentions_persons = [Person.objects.create(name=\'person\')]\n        return book\n\n    def _book_data(self, book):\n        persons_pks = [person.pk for person in book.mentions_persons.all()]\n        mentions_persons = fields.pack_ids(persons_pks)\n\n        return {\n            \'author\': str(book.author.pk),\n            \'name\': book.name,\n            \'mentions_persons\': mentions_persons\n        }\n\n    def test_render_instance(self):\n        book = self._make_instance()\n        form = BookForm(instance=book)\n        out = form.as_p()\n        # print(out)\n        self.assertTrue(\'autocomplete\' in out)\n        self.assertTrue(\'autocompleteselect\' in out)\n        self.assertTrue(\'autocompleteselectmultiple\' in out)\n\n    def test_render_with_data(self):\n        """\n        Rendering a form with data already in it\n        because it is pre-filled or had errors and is redisplaying.\n        """\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        out = form.as_p()\n        # print(out)\n        # should have the values in there somewhere\n        self.assertTrue(\'autocomplete\' in out)\n        self.assertTrue(\'autocompleteselect\' in out)\n        self.assertTrue(\'autocompleteselectmultiple\' in out)\n\n    def test_render_with_initial(self):\n        book = self._make_instance()\n        # this is data for the form submit\n        data = self._book_data(book)\n        # initial wants the pks\n        data[\'mentions_persons\'] = [p.pk for p in book.mentions_persons.all()]\n        form = BookForm(initial=data)\n        out = form.as_p()\n        # print(out)\n        # should have the values in there somewhere\n        self.assertTrue(\'autocomplete\' in out)\n        self.assertTrue(\'autocompleteselect\' in out)\n        self.assertTrue(\'autocompleteselectmultiple\' in out)\n\n    def test_is_valid(self):\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        self.assertTrue(form.is_valid())\n\n    def test_full_clean(self):\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        form.full_clean()\n        data = form.cleaned_data\n        # {u\'author\': <Author: Author object>, u\'name\': u\'book\', u\'mentions_persons\': [u\'1\']}\n        self.assertEqual(data[\'author\'], book.author)\n        self.assertEqual(data[\'name\'], book.name)\n        # why aren\'t they instances ?\n        self.assertEqual(data[\'mentions_persons\'], [str(p.pk) for p in book.mentions_persons.all()])\n\n    def test_save(self):\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        saved = form.save()\n        self.assertTrue(saved.pk is not None)\n'
u'1522,class TestAdmin(TestCase):\n\n    def setUp(self):\n        self.user = User.objects.create_superuser(\'admin\', \'admin@example.com\', \'password\')\n        self.client = Client()\n        ok = self.client.login(username=\'admin\', password=\'password\')\n        if not ok:\n            raise Exception("Failed to log in")\n'
u'1523,class TestBookAdmin(TestAdmin):\n\n    """\n    Test the admins in tests/admin.py\n    """\n\n    def test_get_blank(self):\n        app_label = \'tests\'\n        model = \'book\'\n        response = self.client.get(reverse(\'admin:%s_%s_add\' % (app_label, model)))\n        content = str(response.content)\n        # print(content)\n\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(\'/static/ajax_select/js/ajax_select.js\' in content)\n        self.assertTrue(\'autocompleteselectmultiple\' in content)\n        self.assertTrue(\'autocompleteselect\' in content)\n        self.assertTrue(\'autocomplete\' in content)\n        self.assertTrue(\'/admin/tests/author/add/?_popup=1\' in content)\n        self.assertTrue(\'/admin/tests/person/add/?_popup=1\' in content)\n'
u'1524,class TestAuthorAdmin(TestAdmin):\n\n    """\n    Test an admin with inlines\n    """\n\n    def test_get_blank(self):\n        app_label = \'tests\'\n        model = \'author\'\n        response = self.client.get(reverse(\'admin:%s_%s_add\' % (app_label, model)))\n        content = str(response.content)\n        # print(content)\n\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(\'book_set-1-mentions_persons\' in content)\n'
u"1525,    class Meta:\n        model = Book\n        fields = ['name', 'author', 'mentions_persons']\n"
u"1526,    def test_render_no_data(self):\n        form = BookForm()\n        out = form.as_p()\n        # print(out)\n        self.assertTrue('autocomplete' in out)\n        self.assertTrue('autocompleteselect' in out)\n        self.assertTrue('autocompleteselectmultiple' in out)\n"
u'1527,    def _make_instance(self):\n        author = Author.objects.create(name="author")\n        book = Book.objects.create(name="book", author=author)\n        book.mentions_persons = [Person.objects.create(name=\'person\')]\n        return book\n'
u"1528,    def _book_data(self, book):\n        persons_pks = [person.pk for person in book.mentions_persons.all()]\n        mentions_persons = fields.pack_ids(persons_pks)\n\n        return {\n            'author': str(book.author.pk),\n            'name': book.name,\n            'mentions_persons': mentions_persons\n        }\n"
u"1529,    def test_render_instance(self):\n        book = self._make_instance()\n        form = BookForm(instance=book)\n        out = form.as_p()\n        # print(out)\n        self.assertTrue('autocomplete' in out)\n        self.assertTrue('autocompleteselect' in out)\n        self.assertTrue('autocompleteselectmultiple' in out)\n"
u'1530,    def test_render_with_data(self):\n        """\n        Rendering a form with data already in it\n        because it is pre-filled or had errors and is redisplaying.\n        """\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        out = form.as_p()\n        # print(out)\n        # should have the values in there somewhere\n        self.assertTrue(\'autocomplete\' in out)\n        self.assertTrue(\'autocompleteselect\' in out)\n        self.assertTrue(\'autocompleteselectmultiple\' in out)\n'
u"1531,    def test_render_with_initial(self):\n        book = self._make_instance()\n        # this is data for the form submit\n        data = self._book_data(book)\n        # initial wants the pks\n        data['mentions_persons'] = [p.pk for p in book.mentions_persons.all()]\n        form = BookForm(initial=data)\n        out = form.as_p()\n        # print(out)\n        # should have the values in there somewhere\n        self.assertTrue('autocomplete' in out)\n        self.assertTrue('autocompleteselect' in out)\n        self.assertTrue('autocompleteselectmultiple' in out)\n"
u'1532,    def test_is_valid(self):\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        self.assertTrue(form.is_valid())\n'
u"1533,    def test_full_clean(self):\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        form.full_clean()\n        data = form.cleaned_data\n        # {u'author': <Author: Author object>, u'name': u'book', u'mentions_persons': [u'1']}\n        self.assertEqual(data['author'], book.author)\n        self.assertEqual(data['name'], book.name)\n        # why aren't they instances ?\n        self.assertEqual(data['mentions_persons'], [str(p.pk) for p in book.mentions_persons.all()])\n"
u'1534,    def test_save(self):\n        book = self._make_instance()\n        form = BookForm(data=self._book_data(book))\n        saved = form.save()\n        self.assertTrue(saved.pk is not None)\n'
u'1535,    def setUp(self):\n        self.user = User.objects.create_superuser(\'admin\', \'admin@example.com\', \'password\')\n        self.client = Client()\n        ok = self.client.login(username=\'admin\', password=\'password\')\n        if not ok:\n            raise Exception("Failed to log in")\n'
u"1536,    def test_get_blank(self):\n        app_label = 'tests'\n        model = 'book'\n        response = self.client.get(reverse('admin:%s_%s_add' % (app_label, model)))\n        content = str(response.content)\n        # print(content)\n\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue('/static/ajax_select/js/ajax_select.js' in content)\n        self.assertTrue('autocompleteselectmultiple' in content)\n        self.assertTrue('autocompleteselect' in content)\n        self.assertTrue('autocomplete' in content)\n        self.assertTrue('/admin/tests/author/add/?_popup=1' in content)\n        self.assertTrue('/admin/tests/person/add/?_popup=1' in content)\n"
u"1537,    def test_get_blank(self):\n        app_label = 'tests'\n        model = 'author'\n        response = self.client.get(reverse('admin:%s_%s_add' % (app_label, model)))\n        content = str(response.content)\n        # print(content)\n\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue('book_set-1-mentions_persons' in content)\n"
u'1538,\nfrom django.test import TestCase\nimport ajax_select\nfrom ajax_select.registry import can_autodiscover\n\n\nclass TestRegistry(TestCase):\n\n    def test_lookup_py_is_autoloaded(self):\n        """Django >= 1.7 autoloads tests/lookups.py"""\n        is_registered = ajax_select.registry.is_registered(\'person\')\n        if can_autodiscover():\n            self.assertTrue(is_registered)\n        else:\n            # person is not in settings and this django will not autoload lookups.py\n            # self.assertFalse(is_registered)\n            # test_integration is more important and requires that lookup.py be loaded\n            # Will drop support for 1.6 soon anyway and we know that it does work\n            pass\n\n    def test_back_compatible_loads_by_settings(self):\n        """a module and class specified in settings"""\n        self.assertTrue(ajax_select.registry.is_registered(\'book\'))\n\n    def test_autoconstruct_from_spec(self):\n        """a dict in settings specifying model and lookup fields"""\n        self.assertTrue(ajax_select.registry.is_registered(\'author\'))\n\n    def test_unsetting_a_channel(self):\n        """settings can unset a channel that was specified in a lookups.py"""\n        # self.assertFalse(ajax_select.registry.is_registered(\'user\'))\n        self.assertFalse(ajax_select.registry.is_registered(\'was-never-a-channel\'))\n'
u'1539,class TestRegistry(TestCase):\n\n    def test_lookup_py_is_autoloaded(self):\n        """Django >= 1.7 autoloads tests/lookups.py"""\n        is_registered = ajax_select.registry.is_registered(\'person\')\n        if can_autodiscover():\n            self.assertTrue(is_registered)\n        else:\n            # person is not in settings and this django will not autoload lookups.py\n            # self.assertFalse(is_registered)\n            # test_integration is more important and requires that lookup.py be loaded\n            # Will drop support for 1.6 soon anyway and we know that it does work\n            pass\n\n    def test_back_compatible_loads_by_settings(self):\n        """a module and class specified in settings"""\n        self.assertTrue(ajax_select.registry.is_registered(\'book\'))\n\n    def test_autoconstruct_from_spec(self):\n        """a dict in settings specifying model and lookup fields"""\n        self.assertTrue(ajax_select.registry.is_registered(\'author\'))\n\n    def test_unsetting_a_channel(self):\n        """settings can unset a channel that was specified in a lookups.py"""\n        # self.assertFalse(ajax_select.registry.is_registered(\'user\'))\n        self.assertFalse(ajax_select.registry.is_registered(\'was-never-a-channel\'))\n'
u'1540,    def test_lookup_py_is_autoloaded(self):\n        """Django >= 1.7 autoloads tests/lookups.py"""\n        is_registered = ajax_select.registry.is_registered(\'person\')\n        if can_autodiscover():\n            self.assertTrue(is_registered)\n        else:\n            # person is not in settings and this django will not autoload lookups.py\n            # self.assertFalse(is_registered)\n            # test_integration is more important and requires that lookup.py be loaded\n            # Will drop support for 1.6 soon anyway and we know that it does work\n            pass\n'
u'1541,    def test_back_compatible_loads_by_settings(self):\n        """a module and class specified in settings"""\n        self.assertTrue(ajax_select.registry.is_registered(\'book\'))\n'
u'1542,    def test_autoconstruct_from_spec(self):\n        """a dict in settings specifying model and lookup fields"""\n        self.assertTrue(ajax_select.registry.is_registered(\'author\'))\n'
u'1543,    def test_unsetting_a_channel(self):\n        """settings can unset a channel that was specified in a lookups.py"""\n        # self.assertFalse(ajax_select.registry.is_registered(\'user\'))\n        self.assertFalse(ajax_select.registry.is_registered(\'was-never-a-channel\'))\n'
u"1544,\nfrom django.test import TestCase\nfrom django.contrib.auth.models import User\nfrom django.test import Client\n\n\nclass TestViews(TestCase):\n\n    def setUp(self):\n        self.user = User.objects.create_superuser(username='admin',\n            email='email@example.com',\n            password='password')\n        self.client = Client()\n        self.client.login(username='admin', password='password')\n"
u"1545,class TestViews(TestCase):\n\n    def setUp(self):\n        self.user = User.objects.create_superuser(username='admin',\n            email='email@example.com',\n            password='password')\n        self.client = Client()\n        self.client.login(username='admin', password='password')\n"
u"1546,    def setUp(self):\n        self.user = User.objects.create_superuser(username='admin',\n            email='email@example.com',\n            password='password')\n        self.client = Client()\n        self.client.login(username='admin', password='password')\n"
u"1547,\nfrom django.conf.urls import url, include\nfrom django.conf.urls.static import static\nfrom django.contrib import admin\nfrom django.conf import settings\nfrom ajax_select import urls as ajax_select_urls\n\n\nadmin.autodiscover()\n\nurlpatterns = [\n    url(r'^ajax_lookups/', include(ajax_select_urls)),\n    url(r'^admin/', include(admin.site.urls)),\n] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)\n"
u'1548,#!/usr/bin/env python\n# -*-COMMENT utf-8 -*-\n\nfrom setuptools import setup\n\ndev_requires = [\n    "flake8>=2.2.0",\n    "pytest>=2.6.0",\n]\n\nsetup(\n    name="17MonIP",\n    version="0.2.7",\n    description="IP search based on 17mon.cn, the best IP database for China.",\n    author="Lx Yu",\n    author_email="github@lxyu.net",\n    packages=["IP", ],\n    package_data={\'IP\': [\'17monipdb.dat\'], },\n    entry_points={"console_scripts": ["iploc = IP.cmd:main", ]},\n    url="http://lxyu.github.io/17monip/",\n    license="MIT",\n    long_description=open("README.rst").read(),\n    extras_require={\n        "dev": dev_requires,\n    },\n    classifiers=[\n        "Development Status :: 5 - Production/Stable",\n        "License :: OSI Approved :: MIT License",\n        "Intended Audience :: Developers",\n        "Programming Language :: Python :: 2.6",\n        "Programming Language :: Python :: 2.7",\n        "Programming Language :: Python :: 3.2",\n        "Programming Language :: Python :: 3.3",\n        "Programming Language :: Python :: 3.4",\n        "Programming Language :: Python :: Implementation :: CPython",\n        "Programming Language :: Python :: Implementation :: PyPy",\n    ]\n)\n'
u'1549,# -*-COMMENT utf-8 -*-\n\nimport argparse\n\nfrom .ip import find\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument("ip", help="ip or domain")\n    args = parser.parse_args()\n\n    if not args.ip:\n        return\n\n    print(find(args.ip))\n\n\nif __name__ == \'__main__\':\n    main()\n'
u'1550,def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument("ip", help="ip or domain")\n    args = parser.parse_args()\n\n    if not args.ip:\n        return\n\n    print(find(args.ip))\n'
u"1551,# -*-COMMENT utf-8 -*-\n\nfrom .ip import find, IPv4Database\n\n__all__ = ['IPv4Database', 'find']\n"
u'1552,# -*-COMMENT utf-8 -*-\n\nimport os\nimport socket\nimport struct\ntry:\n    import mmap\nexcept ImportError:\n    mmap = None\n\n__all__ = [\'IPv4Database\', \'find\']\n\n_unpack_V = lambda b: struct.unpack("<L", b)[0]\n_unpack_N = lambda b: struct.unpack(">L", b)[0]\n\n\ndef _unpack_C(b):\n    if isinstance(b, int):\n        return b\n    return struct.unpack("B", b)[0]\n\n\ndatfile = os.path.join(os.path.dirname(__file__), "17monipdb.dat")\n\n\nclass IPv4Database(object):\n    """Database for search IPv4 address.\n\n    The 17mon dat file format in bytes::\n\n        -----------\n        | 4 bytes |                     <- offset number\n        -----------------\n        | 256 * 4 bytes |               <- first ip number index\n        -----------------------\n        | offset - 1028 bytes |         <- ip index\n        -----------------------\n        |    data  storage    |\n        -----------------------\n    """\n    def __init__(self, filename=None, use_mmap=True):\n        if filename is None:\n            filename = datfile\n        with open(filename, \'rb\') as f:\n            if use_mmap and mmap is not None:\n                buf = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\n            else:\n                buf = f.read()\n                use_mmap = False\n\n        self._use_mmap = use_mmap\n        self._buf = buf\n\n        self._offset = _unpack_N(buf[:4])\n        self._is_closed = False\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, traceback):\n        self.close()\n\n    def close(self):\n        if self._use_mmap:\n            self._buf.close()\n        self._is_closed = True\n\n    def _lookup_ipv4(self, ip):\n        nip = socket.inet_aton(ip)\n\n        # first IP number\n        fip = bytearray(nip)[0]\n        # 4 + (fip - 1) * 4\n        fip_offset = fip * 4 + 4\n\n        # position in the index block\n        count = _unpack_V(self._buf[fip_offset:fip_offset + 4])\n        pos = count * 8\n\n        offset = pos + 1028\n\n        data_length = 0\n        data_pos = 0\n\n        lo, hi = 0, (self._offset - offset) // 8\n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            mid_offset = pos + 1028 + 8 * mid\n            mid_val = self._buf[mid_offset: mid_offset+4]\n\n            if mid_val < nip:\n                lo = mid + 1\n            else:\n                hi = mid\n\n        offset = pos + 1028 + 8 * lo\n        if offset == self._offset:\n            return None\n\n        data_pos = _unpack_V(self._buf[offset + 4:offset + 7] + b\'\\0\')\n        data_length = _unpack_C(self._buf[offset + 7])\n\n        offset = self._offset + data_pos - 1024\n        value = self._buf[offset:offset + data_length]\n        return value.decode(\'utf-8\').strip()\n\n    def find(self, ip):\n        if self._is_closed:\n            raise ValueError(\'I/O operation on closed dat file\')\n\n        return self._lookup_ipv4(ip)\n\n\ndef find(ip):\n    # keep find for compatibility\n    try:\n        ip = socket.gethostbyname(ip)\n    except socket.gaierror:\n        return\n\n    with IPv4Database() as db:\n        return db.find(ip)\n'
u'1553,def _unpack_C(b):\n    if isinstance(b, int):\n        return b\n    return struct.unpack("B", b)[0]\n'
u'1554,class IPv4Database(object):\n    """Database for search IPv4 address.\n\n    The 17mon dat file format in bytes::\n\n        -----------\n        | 4 bytes |                     <- offset number\n        -----------------\n        | 256 * 4 bytes |               <- first ip number index\n        -----------------------\n        | offset - 1028 bytes |         <- ip index\n        -----------------------\n        |    data  storage    |\n        -----------------------\n    """\n    def __init__(self, filename=None, use_mmap=True):\n        if filename is None:\n            filename = datfile\n        with open(filename, \'rb\') as f:\n            if use_mmap and mmap is not None:\n                buf = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\n            else:\n                buf = f.read()\n                use_mmap = False\n\n        self._use_mmap = use_mmap\n        self._buf = buf\n\n        self._offset = _unpack_N(buf[:4])\n        self._is_closed = False\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, traceback):\n        self.close()\n\n    def close(self):\n        if self._use_mmap:\n            self._buf.close()\n        self._is_closed = True\n\n    def _lookup_ipv4(self, ip):\n        nip = socket.inet_aton(ip)\n\n        # first IP number\n        fip = bytearray(nip)[0]\n        # 4 + (fip - 1) * 4\n        fip_offset = fip * 4 + 4\n\n        # position in the index block\n        count = _unpack_V(self._buf[fip_offset:fip_offset + 4])\n        pos = count * 8\n\n        offset = pos + 1028\n\n        data_length = 0\n        data_pos = 0\n\n        lo, hi = 0, (self._offset - offset) // 8\n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            mid_offset = pos + 1028 + 8 * mid\n            mid_val = self._buf[mid_offset: mid_offset+4]\n\n            if mid_val < nip:\n                lo = mid + 1\n            else:\n                hi = mid\n\n        offset = pos + 1028 + 8 * lo\n        if offset == self._offset:\n            return None\n\n        data_pos = _unpack_V(self._buf[offset + 4:offset + 7] + b\'\\0\')\n        data_length = _unpack_C(self._buf[offset + 7])\n\n        offset = self._offset + data_pos - 1024\n        value = self._buf[offset:offset + data_length]\n        return value.decode(\'utf-8\').strip()\n\n    def find(self, ip):\n        if self._is_closed:\n            raise ValueError(\'I/O operation on closed dat file\')\n\n        return self._lookup_ipv4(ip)\n'
u'1555,def find(ip):\n    # keep find for compatibility\n    try:\n        ip = socket.gethostbyname(ip)\n    except socket.gaierror:\n        return\n\n    with IPv4Database() as db:\n        return db.find(ip)\n'
u"1556,    def __init__(self, filename=None, use_mmap=True):\n        if filename is None:\n            filename = datfile\n        with open(filename, 'rb') as f:\n            if use_mmap and mmap is not None:\n                buf = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\n            else:\n                buf = f.read()\n                use_mmap = False\n\n        self._use_mmap = use_mmap\n        self._buf = buf\n\n        self._offset = _unpack_N(buf[:4])\n        self._is_closed = False\n"
u'1557,    def __enter__(self):\n        return self\n'
u'1558,    def __exit__(self, type, value, traceback):\n        self.close()\n'
u'1559,    def close(self):\n        if self._use_mmap:\n            self._buf.close()\n        self._is_closed = True\n'
u"1560,    def _lookup_ipv4(self, ip):\n        nip = socket.inet_aton(ip)\n\n        # first IP number\n        fip = bytearray(nip)[0]\n        # 4 + (fip - 1) * 4\n        fip_offset = fip * 4 + 4\n\n        # position in the index block\n        count = _unpack_V(self._buf[fip_offset:fip_offset + 4])\n        pos = count * 8\n\n        offset = pos + 1028\n\n        data_length = 0\n        data_pos = 0\n\n        lo, hi = 0, (self._offset - offset) // 8\n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            mid_offset = pos + 1028 + 8 * mid\n            mid_val = self._buf[mid_offset: mid_offset+4]\n\n            if mid_val < nip:\n                lo = mid + 1\n            else:\n                hi = mid\n\n        offset = pos + 1028 + 8 * lo\n        if offset == self._offset:\n            return None\n\n        data_pos = _unpack_V(self._buf[offset + 4:offset + 7] + b'\\0')\n        data_length = _unpack_C(self._buf[offset + 7])\n\n        offset = self._offset + data_pos - 1024\n        value = self._buf[offset:offset + data_length]\n        return value.decode('utf-8').strip()\n"
u"1561,    def find(self, ip):\n        if self._is_closed:\n            raise ValueError('I/O operation on closed dat file')\n\n        return self._lookup_ipv4(ip)\n"
